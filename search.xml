<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[【笔记】核心语法之运算符]]></title>
      <url>https://dudujie0915.github.io/2017/07/28/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>将简单表达式组合成复杂表达式最常用的方法是使用运算符；运算符按照特定的运算规则对操作数（通常是两个）进行运算，并计算出新值；</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】核心语法之类型转换]]></title>
      <url>https://dudujie0915.github.io/2017/07/28/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>JavaScript中的取值类型非常灵活，我们可以提供任意类型值，JavaScript将根据需要自行转换类型；意外的转换类型如下：     </p>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">转换为字符串</th>
<th style="text-align:left">数字</th>
<th style="text-align:left">布尔值</th>
<th style="text-align:left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">undefind</td>
<td style="text-align:left">“undefined”</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">false</td>
<td style="text-align:left">throws TypeError</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">“null”</td>
<td style="text-align:left">0</td>
<td style="text-align:left">false</td>
<td style="text-align:left">throws TypeError</td>
</tr>
<tr>
<td style="text-align:left">true</td>
<td style="text-align:left">“true”</td>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left">new Boolean(true)</td>
</tr>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">“false”</td>
<td style="text-align:left">0</td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Boolean(false)</td>
</tr>
<tr>
<td style="text-align:left">“”(空字符串)</td>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left">false</td>
<td style="text-align:left">new String(“”)</td>
</tr>
<tr>
<td style="text-align:left">“1.2”(非空，数字)</td>
<td style="text-align:left"></td>
<td style="text-align:left">1.2</td>
<td style="text-align:left">true</td>
<td style="text-align:left">new String(“true”)</td>
</tr>
<tr>
<td style="text-align:left">“one”(非空，非数字)</td>
<td style="text-align:left"></td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
<td style="text-align:left">new String(“one”)</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">“0”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(0)</td>
</tr>
<tr>
<td style="text-align:left">-0</td>
<td style="text-align:left">“0”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(-0)</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">“NaN”</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
<td style="text-align:left">new Number(NaN)</td>
</tr>
<tr>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">“Infinity”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(Infinity)</td>
</tr>
<tr>
<td style="text-align:left">-Infinity</td>
<td style="text-align:left">“-Infinity”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(-Infinity)</td>
</tr>
<tr>
<td style="text-align:left">1(无穷大，非零)</td>
<td style="text-align:left">“1”</td>
<td style="text-align:left"></td>
<td style="text-align:left">true</td>
<td style="text-align:left">new Number(1)</td>
</tr>
<tr>
<td style="text-align:left">{}(任意对象)</td>
<td style="text-align:left">参考第三节</td>
<td style="text-align:left">参考第三节</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">{}(任意数组)</td>
<td style="text-align:left">“”</td>
<td style="text-align:left">0</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[9](1个数字元素)</td>
<td style="text-align:left">“9”</td>
<td style="text-align:left">9</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[‘a’](其他数组)</td>
<td style="text-align:left">使用join()方法</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">function(){}(任意函数)</td>
<td style="text-align:left">参考第三节</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">true</td>
<td style="text-align:left">&nbsp;</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>原始值到原始值的转换：     </p>
<ul>
<li>转换为布尔值：<a href="/2017/07/26/JS核心语法之类型简介/">布尔值</a>；     </li>
<li>转换为字符串：表中明确定义；     </li>
<li>转换为数字：以数字表示的字符串可直接转换为数字，也允许在开始和结尾处带空格；在开始和结尾处的任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN；true转换为1，false、空字符串””转换为0；</li>
</ul>
<p>原始值转换为对象：<br>通过调用String()、Number()或Boolean()构造函数，转换为它们各自的<a href="/2017/07/26/JS核心语法之类型简介/">包装对象</a>；<br>null和underfined属于例外，当将它们用在期望是一个对象的地方都会造成一个类型错误异常，而不会执行正常的转换；     </p>
<p>对象到原始值，看第三节；</p>
<h1 id="转换和相等性"><a href="#转换和相等性" class="headerlink" title="转换和相等性"></a>转换和相等性</h1><p>JavaScript中类型灵活变化，”==”相等运算符也随相等的含义灵活多变；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面的比较结果均是true</span><br><span class="line">null == underfined</span><br><span class="line">&quot;0&quot; == 0</span><br><span class="line">0 == false</span><br><span class="line">&quot;0&quot; == false</span><br></pre></td></tr></table></figure></p>
<p>一个值转换为另一个值并不意味着两个值相等，如在期望使用布尔值的地方使用了underfined，它将会转换为false，但不能表明underfined == false；<br>JavaScript运算符和语句期望使用多样化的数据类型，并可以相互转换；</p>
<h1 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h1><p>做显式类型转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数；<br>除了null或underfined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致；<br>JavaScript的某些运算符会做隐式的类型转换，如”+”运算符的一个操作数是字符串，他将会把另一个操作符转换为字符串；一元”+”运算符将其操作数转换为数字；一元”!”运算符将其操作数转换为布尔值并取反；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x + &quot;&quot;  //等价于String(x)</span><br><span class="line">+x      //等价于Number(x)，也可写成x-0</span><br><span class="line">!!x     //等价于Boolean(x)</span><br></pre></td></tr></table></figure></p>
<p>JavaScript中提供了专门的函数和方法用来做更精确的数字到字符串和字符串到数字的转换；<br>Number类定义的toString()方法可以接收表示转换基数的可选参数，如果不指定此参数，转换规则将是基于十进制；亦可以将数字转换为其他进制数；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var n = 17;</span><br><span class="line">binary_string = n.toString(2);   //转换为&quot;10001&quot;</span><br></pre></td></tr></table></figure></p>
<p>Number类定义的toFixed()根据小数点后的指定位数将数字转换为字符串，它从不用指数记数法；toExponential()使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数由参数指定；toPrecision()根据指定的有效数字位数将数字转换成字符串，如果有效数字的位数少于数字整数部分的位数，则转换成指数形式；三个方法都会适当地进行四舍五入或填充0；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var n = 123456.789;</span><br><span class="line">n.toFixed(0);  //&quot;123457&quot;</span><br><span class="line">n.toFixed(2);  //&quot;123456.79&quot;</span><br><span class="line">n.toFixed(5);  //&quot;123456.78900&quot;</span><br><span class="line">n.toExponential(1);  //&quot;1.2e+5&quot;</span><br><span class="line">n.toExponential(3);  //&quot;1.235e+5&quot;</span><br><span class="line">n.toPrecision(4);  //&quot;1.235e+5&quot;</span><br><span class="line">n.toPrecision(7);  //&quot;123456.8&quot;</span><br><span class="line">n.toPrecision(10);  //&quot;123456.7890&quot;</span><br></pre></td></tr></table></figure></p>
<p>通过Number()转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符；<br>parseInt()只解析整数，而parseFloat()则可以解析整数和浮点数，如果字符串前缀是”0x”或者”0X”，parseInt()将其解释为十六进制数；它们两个都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容；如果第一个非空字符是非法的数字直接量，将返回NaN;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;3 d&quot;)  // =&gt; 3</span><br><span class="line">parseFloat(&quot;3.14 d&quot;)  // =&gt; 3.14</span><br><span class="line">parseInt(&quot;-12.3&quot;)  // =&gt; -12</span><br><span class="line">parseInt(&quot;0xff&quot;)  // =&gt; 255</span><br><span class="line">parseInt(&quot;0Xff&quot;)  // =&gt; 255</span><br><span class="line">parseInt(&quot;-0XFF&quot;)  // =&gt; -255</span><br><span class="line">parseFloat(&quot;.1&quot;)  // =&gt; 0.1</span><br><span class="line">parseInt(&quot;0.1&quot;)  // =&gt; 0</span><br><span class="line">parseInt(&quot;.1&quot;)  // =&gt; NaN</span><br><span class="line">parseFloat(&quot;$72.1&quot;)  // =&gt; NaN</span><br></pre></td></tr></table></figure></p>
<p>parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2~36；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&quot;11&quot;,2)  // =&gt; 3(1*2+1)</span><br><span class="line">parseInt(&quot;zz&quot;,36)  // =&gt; 1295(35*36+35)</span><br><span class="line">parseInt(&quot;077&quot;,10)  // =&gt; 77(7*10+7)</span><br></pre></td></tr></table></figure></p>
<h1 id="对象转换为原始值"><a href="#对象转换为原始值" class="headerlink" title="对象转换为原始值"></a>对象转换为原始值</h1><p>对象转换为布尔值：所以的对象(包括数组和函数)都转换为true，对于包装对象亦是如此；<br>对象到字符串和对象到数字的转换时通过调用待转换对象的一个方法来完成的，有两种不同的方法来执行转换，此规则只适用于本地对象；宿主对象根据各自的算法可以转换成字符串和数字；<br>两个转换方法，一个是toString()，它的作用是返回一个反应这个对象的字符串：       </p>
<ul>
<li>默认的toString()方法并不会返回一个有趣的值；</li>
<li>数组类的toString()方法将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串；</li>
<li>函数类的toString()方法返回这个函数的实现定义的表达方式，通常是将用户定义的函数转换为JavaScript源代码字符串；</li>
<li>日期类定义的toString()方法返回了一个可读的日期和时间字符串；</li>
<li>RegExp类定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串；<br>另一个转换对象的函数是valueOf()，默认的valueOf()方法简单地返回对象本身；</li>
<li>数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回对象本身；</li>
<li>日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日以来的毫秒数；<br>JavaScript中对象到字符串的转换有如下步骤：</li>
<li>如果对象具有toString()方法，则调用这个方法；如果它返回一个原始值，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果；</li>
<li>如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法；如果存在这个方法，则JavaScript调用它；如果它返回一个原始值，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果；</li>
<li>否则，JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常；<br>JavaScript中对象到数字的转换有如下步骤：</li>
<li>如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字(如果有需要额话)并返回这个数字；</li>
<li>否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回；</li>
<li>否则，JavaScript抛出一个类型错误异常；<br>对象转换为数字的细节解释了为什么空数组会转换为数字0以及为什么具有单个元素的数组同样会转换成一个数字；数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法；空数组转换为空字符串，空字符串转换为数字0；含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样；如果数组只包含一个数字元素，这个数字转换为字符串，再转换回数字；</li>
</ul>
<p>JavaScript中的”+”运算符可以进行数学加法和字符串连接操作；如果它的其中一个操作数是对象，则JavaScript将使用特殊的方法将对象转换为原始值，而不是使用其他算术运算符的方法执行对象到数字的转换；”==”相等运算符与此类似，如果将对象和一个原始值比较，则转换将会遵照对象到原始值的转换方式进行；”&lt;”运算符以及其他关系运算符也会做对象到原始值的转换，但要除去日期对象的特殊情形：任何对象都会首先尝试调用valueOf()，然后调用toString()，不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串；<br>“+”、”==”、”!=”和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符;</p>
<p>“+”和”==”应用的对象到原始值得转换包含日期对象的一种特殊情形；日期类是JavaScript语言核心中唯一的预先定义类型，它定义了有意义的向字符串和数字类型的转换，对于所有非日期的对象来说，对象到原始值得转换基本上是对象到数字的转换(首先调用valueOf()),日期对象则使用对象到字符串的转换模式，然而这里的转换时通过valueOf或toString()返回的原始值将被直接使用，而不是被强制转换为数字或字符串；</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】核心语法之表达式]]></title>
      <url>https://dudujie0915.github.io/2017/07/28/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>常量是最简单的一类表达式，变量名也是一种简单地表达式，它的值就是赋值给变量的值；复杂表达式是由简单表达式组成的；      </p>
<h1 id="原始表达式"><a href="#原始表达式" class="headerlink" title="原始表达式"></a>原始表达式</h1><p>最简单的表达式是“原始表达式” ，它是表达式的最小单位–它们不再包含其他表达式；JavaScript中的原始表达式包含常量或直接量、关键字和变量；<br>直接量是直接在程序中出现的常数值，有数字直接量、字符串直接量和正则表达式直接量；<br>JavaScript中的一些保留字构成了原始表达式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>  <span class="comment">//返回布尔值：真</span></span><br><span class="line"><span class="literal">false</span>  <span class="comment">//返回布尔值：假</span></span><br><span class="line"><span class="literal">null</span>  <span class="comment">//返回值：空</span></span><br><span class="line"><span class="keyword">this</span>  <span class="comment">//返回“当前”对象</span></span><br></pre></td></tr></table></figure></p>
<p>当JavaScript代码中出现了标识符，JavaScript会将其当做变量而去查找它的值；如果变量名不存在，表达式运算结果为underfined；在ES5严格模式中，对不存在的变量进行求值会抛出一个引用类型错误；</p>
<h1 id="对象和数组的初始化表达式"><a href="#对象和数组的初始化表达式" class="headerlink" title="对象和数组的初始化表达式"></a>对象和数组的初始化表达式</h1><p>对象和数组初始化表达式实际上是一个新创建的对象和数组，它们有时称为“对象直接量”和“数组直接量”，它们不是原始表达式，它们所包含的成员或者元素都是子表达式；     </p>
<p>数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的，初始化的结果是一个新创建的数组；数组的元素是逗号分隔的表达式的值，表达式是可以嵌套的；<br>JavaScript对数组初始化表达式进行求值的时候，数组初始化表达式中的元素表达式也都会各自计算一次，也就是说，数组初始化表达式每次计算的值有可能是不同的；<br>数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值underfined；数值直接量的元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值为underfined的元素；     </p>
<p>对象初始化表达式是通过一对花括号和其内的子表达式（子表达式包含一个属性名和一个冒号作为前缀）；<br>JavaScript求对象初始化表达式的值得时候，对象表达式也都会各自计算一次，并且它们不必包含常数值：它们可以是任意JavaScript表达式；同样，对象直接量中的属性名称可以是字符串而不是标识符（这在那些只能使用保留字或一些非法标识符作为属性名的地方非常有用）；</p>
<h1 id="函数定义表达式"><a href="#函数定义表达式" class="headerlink" title="函数定义表达式"></a>函数定义表达式</h1><p>函数定义表达式定义一个JavaScript函数，表达式的值是这个新定义的函数，函数表达式可称为“函数直接量”；一个典型的函数定义表达式包含关键字function，跟随其后的是一对圆括号，括号内是一个以逗号分隔的列表，列表含有0个或多个标识符（参数名），然后再跟随一个由花括号包裹的JavaScript代码段（函数体）；函数定义表达式同样可以包含函数的名称；函数可以通过函数语句来定义，而不是函数表达式；</p>
<h1 id="属性访问表达式"><a href="#属性访问表达式" class="headerlink" title="属性访问表达式"></a>属性访问表达式</h1>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】核心语法之变量]]></title>
      <url>https://dudujie0915.github.io/2017/07/28/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p>在JavaScript程序中，使用一个变量之前应当先声明；变量是使用关键字var来声明的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> sum;</span><br><span class="line"><span class="comment">//可以通过一个var关键字来声明多个变量：</span></span><br><span class="line"><span class="keyword">var</span> i,sum;</span><br><span class="line"><span class="comment">// 还可以将变量的初始赋值和变量声明合写在一起：</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果未在var声明语句中给变量指定初始值，那么虽然声明了这个变量，但在给它存入一个值之前，它的初始值就是underfined；<br>在for和for/in循环中同样可以使用var语句；<br>JavaScript变量可以是任意数据类型；</p>
<h2 id="重复的声明和遗漏的声明"><a href="#重复的声明和遗漏的声明" class="headerlink" title="重复的声明和遗漏的声明"></a>重复的声明和遗漏的声明</h2><p>使用var语句重复声明变量是合法且无害的；如果重复声明带有初始化器，那么这就和一条简单地赋值语句没什么两样；<br>在ES5严格模式中，给一个没有声明的变量赋值也会报错；从历史上来看，不赋值也可以使用，但是这个不好的习惯会造成很多bug，因此应当始终使用var来声明变量；</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>一个变量的作用域是程序源代码中定义这个变量的区域；全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的；在函数内声明的变量只在函数体内有定义，它们是局部变量，作用域是局部性的；函数参数也是局部变量，它们只在函数体内有定义；<br>在函数体内，局部变量的优先级高于同名的全局变量；如果在函数内声明一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就会被局部变量所遮盖；<br>尽管在全局作用域编写代码时可以不写var语句，但声明局部变量时则必须使用var语句；<br>函数定义是可以嵌套的，由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况；     </p>
<h2 id="函数作用域和声明提前"><a href="#函数作用域和声明提前" class="headerlink" title="函数作用域和声明提前"></a>函数作用域和声明提前</h2><p>JavaScript使用了函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的；<br>JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，这意味着变量在声明之前甚至已经使用，JavaScript的这个特性被非正式地称为声明提前，即JavaScript函数里声明的所有变量(但不涉及赋值)都被“提前”至函数体的顶部；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">//输出"underfined"</span></span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">//输出"local"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码等同于：</span></span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">    scope = <span class="string">"local"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="作为属性的变量"><a href="#作为属性的变量" class="headerlink" title="作为属性的变量"></a>作为属性的变量</h2><p>当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性，这是在ES规范中强制规定的；当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除；未使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量，以这种方式创建的变量是全局对象的正常的可配置属性，并可以删除它们：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="number">1</span>;</span><br><span class="line">f = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.f2 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> t  <span class="comment">// =&gt; false:：变量并没有被删除</span></span><br><span class="line"><span class="keyword">delete</span> f  <span class="comment">// =&gt; true：变量被删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.f2  <span class="comment">// =&gt; true：变量被删除</span></span><br></pre></td></tr></table></figure></p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>JavaScript是基于语法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域；全局变量在程序中始终都是有定义的；局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的；<br>每一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链，这个作用域链是一个对象列表或者链表，这组对象定义了这段代码”作用域中”的变量；当JavaScript需要查找变量x的值的时候（这个过程称为“变量解析”），它会从链表的第一个对象开始查找，如果这个对象由一个名为x的属性，则会直接使用这个属性的值，如果第一个对象没有名为x的属性，JavaScript会继续查找链上的下一个对象；如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推；如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常；<br>在JavaScript的最顶层代码中(也就是不包含任何函数定义内的代码)，作用域链由一个全局变量组成；在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象；在一个嵌套函数体内，作用域链上至少有三个对象；<br>当定义一个函数时，它实际上保存一个作用域链；当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同事创建一个新的更长的表示函数调用作用域的“链”；<br>对于嵌套函数来说，每次调用外部函数时，内部函数在每次定义的时候都有微妙的差别–在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同；</p>
<p><a href="/2017/07/24/JS核心语法之词法结构/">标识符和保留字</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】核心语法之类型简介]]></title>
      <url>https://dudujie0915.github.io/2017/07/26/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>编程语言最基本的特性就是能够支持多种数据类型；<br>变量的工作机制是编程语言的另一个进本特性；<br>JavaScript分类方法：①原始类型和对象类型；②可以拥有方法的类型和不能拥有方法的类型；③可变类型和不可变类型；<br>JavaScript的数据类型分为两类：<br>原始类型：数字、字符串、布尔值、null(空)、underfined(未定义)；<br>对象类型：对象、数组、函数；<br>对象是属性的集合，每个属性都由“名/值对”(值可是原始值，也可是对象)构成，特殊对象–全局对象；<br>特殊对象–数组，表示带编号的值得有序集合，有专用的语法，使数组有一些和普通对象不同的特有行为特性；<br>特殊对象–函数，有专用语法；函数用来初始化(使用new运算符)一个新建的对象，可称为构造函数；每个构造函数定义了一类对象–由构造函数初始化的对象组成的集合；类可以看成对象类型的子类型；除数组类和函数类之外，还有日期(Date)类、正则(RegExp)类、错误(Error)类；<br>JavaScript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收；<br><a id="more"></a><br>我们不用全局的定义函数去操作不同类型的值，数据类型本身可以定义方法来使用值，如a.sort()等；<br>从技术上讲，只有JavaScript对象才能拥有方法，但是，数字、字符串和布尔值也可以拥有自己的方法，只有null和underfined是无法拥有方法的值；<br>可变类型的值是可修改的；对象和数组属于可变类型：可改变对象属性值和数组元素的值；数字、布尔值、null和underfined属于不可变类型；<br>JavaScript可以自由进行数据类型转换；<br>JavaScript变量是无类型的，变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值；使用var关键字来生命变量；JavaScript采用词法作用域；不在任何函数内声明的变量称为全局变量，它在JavaScript程序中的任何地方都是可见的；在函数内声明的变量具有函数作用域，并且只在函数内可见；    </p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>布尔值代指真或假、开或关、是或否，它只有两个值，保留字true和false；<br>JavaScript程序中的比较语句结果通常都是布尔值；<br>布尔值通常用于JavaScript中的控制结构中；<br>任意JavaScript的值都可以转换为布尔值；<br>为false的布尔值有：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">underfined  <span class="literal">null</span>  <span class="number">0</span>  <span class="number">-0</span>  <span class="literal">NaN</span>  <span class="string">""</span>或<span class="string">''</span>  <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>其他值，包括所有对象和数组（包括空数组和空对象）都会转换成true；<br>布尔值包含toString()方法，使用此方法将字符串转换成”true”或”false”，但它并不包含其他有用的方法；<br>布尔运算符：<code>&amp;&amp;(与)</code>当两个操作符都为真时返回true，否则返回false；<code>||(或)</code>当两个操作符中的一个为值时就返回true，如果两个操作符都是假值则返回false；<code>!(非)</code>如果操作数是真值返回false，是假值返回true；<br>相等运算符<code>===,!==,==,!=</code>和比较运算符<code>&gt;,&gt;=,&lt;,&lt;=</code>也会返回布尔值；</p>
<h1 id="null和underfined"><a href="#null和underfined" class="headerlink" title="null和underfined"></a>null和underfined</h1><p>null表示一个”空值”，是关键字，可以将它认为是一个特殊的对象值，含义是”非对象”；实际上，通常认为null是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是”无值”的；<br>underfined表示更深层次的”空值”,不是关键字，是未定义的值，他是变量的一种取值，表示变量没有初始化，查询对象属性或数组元素的值时返回underfined则说明这个属性或元素不存在；如果函数没有返回任何值，则返回undefined，引用没有提供实参的函数形参的值也会得到underfined；underfined是预定义的全局变量，是只读的；使用typeof运算符得到underfined的类型，则返回”underfined”，表示这个值是这个类型的唯一成员；<br>underfined和null往往可以互换，用相等运算符”==”判断两者是相等的(使用严格相等运算符”===”可以区分它们)；在希望值是布尔类型的地方它们都是假值，和false类似；它们都不包含任何属性和方法；<br>如果想将null和underfined赋值给变量或属性，或将它们作为参数传入函数，最佳选择是使用null；</p>
<h1 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h1><p>全局对象的属性是全局定义的符号，JavaScript程序可以直接使用；当JavaScript解释器启动时(或任意Web浏览器加载新页面时)，它将创建一个新的全局对象，并给它一组定义的初始属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全局属性，如underfined、Infinity和NaN</span><br><span class="line">全局函数，如isNaN()、parseInt()和eval()等</span><br><span class="line">构造函数，如Date()、RegExp()、String()、Object()和Array()等</span><br><span class="line">全局对象，如Math和JSON</span><br></pre></td></tr></table></figure></p>
<p>全局对象的初始属性并不是保留字，但它们应该当做保留字来对待；<br>客户端JavaScript中，Window对象定义了一些额外的全局属性；<br>在代码的最顶级–不在任何函数内的JavaScript代码–可以使用JavaScript关键字this来引用全局变量；<br>在客户端JavaScript中，在其表示的浏览器窗口中的所有JavaScript代码中，Windows对象充当了全局对象；它有一个属性window引用其自身，替代了this来引用全局对象；<br>如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性；</p>
<h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><p>JavaScript对象是一种复合值，它是属性或已命名值得集合，通过”.”符号来引用属性值；当属性值是一个函数时，称其为方法；通过o.m()来调用对象o中的方法；<br>字符串、数字和布尔值具有各自的方法：通过String()、Number()和Boolean()构造函数创建一个临时对象，这些方法的调用均来自于这个临时对象；方法被用来处理属性的引用，一旦属性引用结束，这个新创建的对象将会销毁；<br>null和underfined没有包装对象；<br>存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象；通常包装对象只被看成一种实现细节，不用特别关注；由于字符串、数字和布尔值的属性都是只读的，并不能为它们定义新属性，需要明白它们有别于对象；<br>可通过String()、Number()和Boolean()构造函数来显式创建包装对象，JavaScript会在必要时将包装对象转换成原始值，因此”==”等于运算符将原始值和其包装对象视为同等。但”===”全等运算符将它们视为不等；</p>
<h1 id="确认类型的运算符"><a href="#确认类型的运算符" class="headerlink" title="确认类型的运算符"></a>确认类型的运算符</h1><p>JavaScript有三种方法，可以确认一个值到底是什么类型：typeof预算符，instanceof运算符，Object.prototype.toString方法；</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】核心语法之字符串]]></title>
      <url>https://dudujie0915.github.io/2017/07/26/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>字符串(string)是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集；<br>JavaScript通过字符串类型表示文本；<br>字符串的长度(length)是其所含16位值得个数；<br>JavaScript字符串(和其数组)的索引从零开始；<br>空字符串长度为0，JavaScript中并没有表示单个字符的”字符型”；</p>
<h1 id="字符串直接量"><a href="#字符串直接量" class="headerlink" title="字符串直接量"></a>字符串直接量</h1><p>JavaScript中字符串直接量，是由单引号或双引号括起来的字符序列；<br>由单引号定界的字符串可包含双引号，由双引号定界的字符串中也可以包含单引号；<br>ES5中，字符串直接量可以拆分成数行，每行必须以反斜杠(\)结束,反斜线和行结束符都不算是字符串直接量的内容；可以使用转义字符\n使字符串直接量另起一行；<br>当使用单引号来定界字符串是，需要格外小心英文中的缩写和所有格写法，因为撇号和单引号是同一个字符，所以必须使用反斜线(\)来转义所有的撇号；<br>在客户端JavaScript程序设计中，JavaScript代码和HTML代码可能会相互夹杂，它们都是使用单引号或双引号来定界字符串，因此混杂使用时，最好在JavaScript和HTML代码中各自使用独立的引号风格；    </p>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>在JavaScript字符串中，反斜杠(\)符号后加一个字符，就不再表示它们字面含义了，表示一个转义字符，所有的转义字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\o          NUL字符(\u0000)</span><br><span class="line">\b          退格符(\u0008)</span><br><span class="line">\t          水平制表符(\u009)</span><br><span class="line">\n          换号符(\u000A)</span><br><span class="line">\v          垂直制表符(\u000B)</span><br><span class="line">\f          换页符(\u000C)</span><br><span class="line">\r          回车符(\u000D)</span><br><span class="line">\&quot;          双引号(\u0022)</span><br><span class="line">\&apos;          撇号或单引号(\u0027)</span><br><span class="line">\\          反斜杠(\u005C)</span><br><span class="line">\xXX        由两位十六进制数XX指定的Latin-1字符</span><br><span class="line">\uXXXX      由四位十六进制数XXXX指定的Unicode字符</span><br></pre></td></tr></table></figure></p>
<p>如果”\”字符位于没有在上面列出的字符前，则忽略”\”;</p>
<h1 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h1><p>字符串连接是JavaScript的内置功能之一，用加号(+)连接，将第二个字符串拼接在第一个之后；<br>确定一个字符串的长度使用length属性；<br>字符串的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">charAt  substring  slice  lastIndexOf  indexOf</span><br><span class="line">split  replace  toUpperCase</span><br></pre></td></tr></table></figure></p>
<p>在JavaScript中字符串是固定不变的，所以方法都是返回新字符串，原字符串本身没有发生改变；<br>ES5中，字符串可以当做只读数组，除了用charAt()方法，也可以用方括号来访问字符串中的单个字符；     </p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>RegExp()构造函数，用来创建表示文本匹配模式的对象；JavaScript采用Perl中的正则表达式语法；String和RegExp对象均定义了利用正则表达式进行模式匹配和查找与替换的函数；<br>RegExp具有直接量写法，可以直接在JavaScript程序中使用；在两条斜线之间的文本构成了一个正则表达式直接量，在第二条斜线之后也可以跟随一个或多个字母，用来修饰匹配模式的含义；</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】核心语法之数值]]></title>
      <url>https://dudujie0915.github.io/2017/07/26/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%95%B0%E5%80%BC/</url>
      <content type="html"><![CDATA[<p>JavaScript不区分整数值和浮点数值，所有数字均用浮点数值表示；<br>整数范围从 -2的53次方~2的53次方 ，包含边界值；JavaScript中实际操作是基于32位整数；<br>当一个数字直接出现在JavaScript程序中，称之为数字直接量；在任何数字直接量前添加负号(-)可以得到它们的负值，但负号是一元求反运算符，并不是数字直接量语法的组成部分；    </p>
<h1 id="整型直接量"><a href="#整型直接量" class="headerlink" title="整型直接量"></a>整型直接量</h1><p>JavaScript中，用一个数字序列表示一个十进制整数；<br>JavaScript能识别十六进制值，以”0x”或”0X”为前缀，其后跟随十六进制数串的直接量；<br>尽管ECMAScript标准不支持八进制直接量，但JavaScript的某些实现允许采用八进制形式表示整数；八进制直接量以数字0开始，其后跟随一个由0~7(包括0和7)之间的数字组成的序列；在ES6的严格模式下，八进制直接量是明令禁止的，不建议使用；     </p>
<h1 id="浮点型直接量"><a href="#浮点型直接量" class="headerlink" title="浮点型直接量"></a>浮点型直接量</h1><p>浮点型直接量可以包含小数点，是传统的实数写法–由整数部分、小数点和小数部分组成；<br>可以使用指数计数法表示浮点型直接量，即在实数后跟字母e或E，后面再跟正负号，其后再加一个整型的指数；此数值是由前面的实数乘以10的指数次幂; 例如<code>6.02e-2</code>等同于 $6.02*10^{-23}$；</p>
<h1 id="JavaScript中的算术运算"><a href="#JavaScript中的算术运算" class="headerlink" title="JavaScript中的算术运算"></a>JavaScript中的算术运算</h1><p>JavaScript使用语言本身提供的算术运算符进行数字运算，运算符包括加法运算符(+)、减法运算符(-)、乘法运算符(*)、除法运算符(/)和求余运算符(%);<br>更加复杂的运算符作为Math对象的属性定义的函数和常量来实现；<br>JavaScript中的算术运算在溢出、下溢或被零整除时不会报错：    </p>
<ul>
<li>溢出指运算结果超出了JavaScript所能表示的数字上线，结果为一个特殊的无穷大(infinity)指，在JavaScript中以Infinity表示；负数值超过JavaScript所能表示的负数范围，结果为负无穷大，以-Infinity表示，基于无穷大值得加、减、乘和除运算结果还是无穷大值(同样保留正负号)；</li>
<li>下溢指运算结果无线接近于0并且比JavaScript能表示的最小值还小的时候发生的情况，此时，JavaScript会返回0；当负数下溢时，返回特殊的值”-0”(和正常的0一样，很少用到)；</li>
<li>被零整除返回无穷大或负无穷大；但是0除以0没有意义，运算结果是非数字值，用NaN表示；   </li>
</ul>
<p>无穷大除以无穷大、给任意负数作开方运算或算术运算符与不是数字或无法转换为数字的操作符一起使用时都返回NaN；<br>JavaScript预定义全局变量Infinity和NaN，表示正无穷大和非数字值；<br>NaN和任何值都不相同，包括自身；<br>-0和0是相等的(使用严格相等测试判断)，只有它们作为初始的时候例外，会分别得到负无穷大和正无穷大；</p>
<h1 id="二进制浮点数和四舍五入错误"><a href="#二进制浮点数和四舍五入错误" class="headerlink" title="二进制浮点数和四舍五入错误"></a>二进制浮点数和四舍五入错误</h1><p>JavaScript采用了IEEE-754浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，可以精确地表示分数，比如1/1024,但是十进制分数1/10、1/100等不能精确表示；</p>
<h1 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h1><p>Date()构造函数，用来创建表示日期和时间的对象；<br>日期对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date()   getFullYear  getMonth  getDate  getDay  getHours  getUTCHours</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】核心语法之词法结构]]></title>
      <url>https://dudujie0915.github.io/2017/07/24/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/JS%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>JavaScript的词法结构包括字符集、注释、直接量、标识符和保留字、可选的分号五部分组成。</p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>JavaScript程序是用Unicode字符集编成的。Unicode是ASCII和Latin-1的超集，并支持几乎所有的语言。</p>
<h2 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h2><p>JavaScript是区分大小写的语言</p>
<h2 id="空格、换行符和格式控制器"><a href="#空格、换行符和格式控制器" class="headerlink" title="空格、换行符和格式控制器"></a>空格、换行符和格式控制器</h2><p>JavaScript会忽略程序中的标识之间的空格；多少情况下，也会忽略换行符；因此可以采用整齐、一致的缩进来形成统一的编码风格，提高代码可读性。<br>标识为空格的字符：普通的空格符(\u0020)、水平制表符(\u0009)、垂直制表符(\u000B)、换页符(\u000C)、不中断空白(\u00A0)、字节序标记(\uFEFF)、在Unicode中所有Zs类别的字符；<br>标识为行结束符：换行符(\u000A)、回车符(\u000D)、行分隔符(\u2028)、段分隔符(\u2029)；回车符加换行符组成一个单行结束符；<br>Unicode格式控制字符(Cf类)：如从右至左书写标记(\u200F)、从左到右书写标记(\u200E)，可以用在注释、字符串直接量、正则表达式直接量中，不能用在标识符(如变量名)中；有个例外，零宽连接符(\u200D)和零宽非连接符(\uFEFF)可以出现在标识符中，但是不能作为标识符的首字符；<br><a id="more"></a></p>
<h2 id="Unicode转义序列"><a href="#Unicode转义序列" class="headerlink" title="Unicode转义序列"></a>Unicode转义序列</h2><p>使用6个ASCII字符来表示任意16位Unicode内码；Unicode转义序列均以\u为前缀，其后跟随4个十六进制，此写法可用在字符串直接量、正则表达式直接量、标识符中(关键字除外)和注释(不会解析)中;</p>
<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p>Unicode允许使用多种方法对同一个字符进行编码。比如复杂的字符可能用两个字符来表示；</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>两种注释方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于历史上JavaScript兼容HTML代码的注释，所以</span></span><br><span class="line">&lt;!-- </span><br><span class="line">xxx </span><br><span class="line">--&gt;</span><br><span class="line">也被视为单行注释</span><br><span class="line">注：--&gt;只有放在行首，才会被当成注释，否则是一个运算符</span><br></pre></td></tr></table></figure></p>
<h1 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h1><p>直接量就是程序中直接使用的数值量，比如整数、小数、字符串、布尔值、正则表达式直接量(用做模式匹配)、null，更加复杂的表达方式，可以写成数值或对象直接量；</p>
<h1 id="标识符和保留字"><a href="#标识符和保留字" class="headerlink" title="标识符和保留字"></a>标识符和保留字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符就是一个名字，用来对变量和函数进行命名(此两种最常见)，或用在某些循环语句中的跳转位置的标记；<br>命名规则：</p>
<ul>
<li>标识符区分大小写；</li>
<li>必须以字母、下划线(_)、或美元符($)开始；</li>
<li>后续字符可以是字母、数字、下划线或美元符； </li>
<li>中文是合法标识符；<br>出于可移植性和易用性的考虑，通常只用ASCII字母和数字来书写标识符；JavaScript允许标识符中出现Unicode字符全集中的字母和数字；</li>
</ul>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>保留字(即关键字)不能用做标识符。<br>保留字有：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>  <span class="keyword">case</span>  <span class="keyword">catch</span>  <span class="keyword">continue</span>  <span class="keyword">debugger</span>  <span class="keyword">default</span>    </span><br><span class="line"><span class="keyword">delete</span>  <span class="keyword">do</span>  <span class="keyword">else</span>  <span class="literal">false</span>  <span class="keyword">finally</span>  <span class="keyword">for</span>    </span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">if</span>  <span class="title">in</span>  <span class="title">instanceof</span>  <span class="title">new</span>  <span class="title">null</span>    </span></span><br><span class="line"><span class="function"><span class="title">return</span>  <span class="title">switch</span>  <span class="title">this</span>  <span class="title">throw</span>  <span class="title">true</span>  <span class="title">try</span>    </span></span><br><span class="line"><span class="function"><span class="title">typeof</span>  <span class="title">var</span>  <span class="title">void</span> <span class="title">while</span>  <span class="title">with</span></span></span><br></pre></td></tr></table></figure></p>
<p>ES5保留的关键字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">const</span>  <span class="title">enum</span>  <span class="title">export</span>  <span class="keyword">extends</span>  <span class="title">import</span>  <span class="title">super</span></span></span><br></pre></td></tr></table></figure></p>
<p>普通模式合法，严格模式下是保留字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implements  interface  <span class="keyword">let</span>  package  private  protected    </span><br><span class="line">public  <span class="keyword">static</span>  <span class="keyword">yield</span></span><br></pre></td></tr></table></figure></p>
<p>下面的标识符在严格模式下并不完全是保留字，但是不能用做变量名、函数名或参数名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arguments</span>  <span class="built_in">eval</span></span><br></pre></td></tr></table></figure></p>
<p>JavaScript预定义的全局变量和函数，应避免把他们的名字用做变量名和函数名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arguments</span>  <span class="built_in">Array</span>  <span class="built_in">Boolean</span>  <span class="built_in">Date</span>  <span class="built_in">decodeURI</span>  <span class="built_in">decodeURIComponent</span></span><br><span class="line"><span class="built_in">encodeURI</span>  <span class="built_in">encodeURIComponent</span>  <span class="built_in">Error</span>  <span class="built_in">eval</span>  <span class="built_in">EvalError</span>  <span class="built_in">Function</span></span><br><span class="line"><span class="literal">Infinity</span>  <span class="built_in">isFinite</span>  <span class="built_in">isNaN</span> <span class="built_in">JSON</span>  <span class="built_in">Math</span>  <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>  <span class="built_in">Object</span>  <span class="built_in">parseFloat</span>  <span class="built_in">parseInt</span>  RangError  <span class="built_in">ReferenceError</span></span><br><span class="line"><span class="built_in">RegExp</span>  <span class="built_in">String</span>  <span class="built_in">SyntaxError</span>  <span class="built_in">TypeError</span>  <span class="literal">undefined</span>  <span class="built_in">URIError</span></span><br></pre></td></tr></table></figure></p>
<p>每一种特定的JavaScript运行环境(客户端、服务器端等)都有自己的一个全局属性列表；</p>
<h1 id="可选的分号"><a href="#可选的分号" class="headerlink" title="可选的分号"></a>可选的分号</h1><p>JavaScript使用分号(;)将语句分割开；<br>如果语句各自独占一行，通常可以省略语句直间的分号(程序结尾或右花括号”}”之前的分号也可省略)；<br>建议使用分号来明确标记语句的结束；<br>JavaScript并不是在所以换行处都填补分号，只有在缺少了分号无法正常解析代码的时候才会填补分号；<br>如果一条语句以”(“或”[“(此两种比较常见)、”/“或”+”或”-“(此三种不常见)开始，它极有可能和前一条语句合在一起解析；在语句前加上一个分号，可以有效的防止错误；<br>如果当前语句和下一行无法合并解析，JavaScript则在第一行后填补分号，但有两个例外：一个是涉及到return、break和countinue语句的场景中，如果这三个关键词后紧跟着换号，JavaScript会在换行处填补分号；二是在涉及”++”和”–”运算符(它们既可以作为表达式的前缀，也可以当做表达式的后缀)的时候，如果将其用做后缀表达式，它和表达式应当在同一行，否则行尾将填补分号，同时”++”或”–”会作为下一行的前缀操作符并与之一起解析；</p>
<h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><p>所谓“编程风格”，指的是编写代码的样式规则；“编程风格”要考虑如何尽量使代码清晰易读、减少出差；<br>如果选定了一种“编程风格”，就应当坚持遵守，切记多种风格混用；     </p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>空格和Tab键，都可以；Tab可节省击键次数，但是不同文本编辑器对Tab显示不尽相同，空格键可以使得显示效果更统一；<br>始终坚持一种选择；          </p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>如果循环和判断的代码体只有一行，JavaScript允许该区块省略大括号，但是应该总是使用大括号表示区块；<br>区块起首的大括号的位置，最流行的有两种写法：一是起首的大括号另起一行，二是起首的大括号跟在关键词的后面；表示起首的大括号不要另起一行；     </p>
<h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>圆括号在JavaScript中有两种作用，一是表示函数的调用，二是表示表达式的组合；</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】JavaScript概述]]></title>
      <url>https://dudujie0915.github.io/2017/07/21/JavaScript/JS%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h1 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h1><ol>
<li>核心部分：基本的语法构造、标准库</li>
<li>宿主环境：浏览器、服务器（Node项目）    </li>
</ol>
<p>基本的语法构造：数据类型（数值、字符串、对象、数组、函数）、操作符、控制结构、语句、数据类型转换、错误处理机制、变成风格<br>标准库：一系列具有各种功能的对象，如Array、Data、Math、Object、Boolean、包装对象、Number、String、RegExp、JSON、console、属性描述对象<br>浏览器：</p>
<ul>
<li>浏览器控制类：操作浏览器</li>
<li>DOM类：操作网页的各种元素</li>
<li>Web类：实现互联网的各种功能</li>
</ul>
<p>服务器：提供各种操作系统的API，如文件操作API、网络通信API</p>
<h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><ol>
<li>JavaScript 是一种轻量级的脚本语言；</li>
<li>JavaScript 是一种嵌入式（embedded）语言；</li>
<li>从语法角度看，JavaScript语言是一种“对象模型”语言；</li>
<li>JavaScript是一门高端的、动态的、弱类型的编程语言，非常适合面向对象和函数式的编程风格；</li>
<li>JavaScript是一种集健壮性、高效性和通用性为一身的编程语言；<a id="more"></a>
<blockquote>
<ul>
<li>ECMAScript 是在宿主环境中执行计算，处理对象的面向对象编程语言。   </li>
<li>脚本语言 是一种用于操作，自定义，自动化现有系统设施的编程语言。    </li>
<li>WEB 浏览器为引入客户端计算能力而提供 ECMAScript 宿主环境，例如，它提供的对象有：windows，menus，pop-ups，dialog boxes，text areas，anchors，frames，history，cookies 及输入 / 输出等等。</li>
<li>WEB 服务器为了服务端的计算则提供了一个完全不一样的宿主环境，包括的对象有：requests，clients，files 以及数据锁定和分享的机制。</li>
<li>ECMAScript 是基于对象的：基本语言和宿主设施都由对象提供，ECMAScript 程序是一组可通信的对象。ECMAScript 对象 (objects) 是 属性 (properties) 的集合，每个属性有零个或多个 特性 (attributes)，它确定怎样使用此属性。属性是持有其他 对象 (objects)， 原始值 (primitive values)， 函数 (functions) 的容器。原始值是以下内置类型之一的成员：Undefined，Null，Boolean，Number，String；对象是剩下的内置类型 Object 的成员；函数是可调用对象 (callable object)。方法 (method) 是通过属性与对象关联的函数。</li>
<li>ECMAScript 定义一组内置对象 (built-in objects)，勾勒出 ECMAScript 实体的定义。这些内置对象包括 全局对象 (global object) ，Object 对象 ，Function 对象 ，Array 对象 ，String 对象 ，Boolean 对象 ，Number 对象 ，Math 对象 ，Date 对象 ，RegExp 对象 ，JSON 对象，和 Error 对象： Error ，EvalError ，RangeError ，ReferenceError ，SyntaxError ，TypeError ，URIError 。</li>
<li>ECMAScript 中还定义一组内置运算符 (operators)。ECMAScript 运算符包括 一元运算符 ，乘法运算符 ，加法运算符 ，按位移位运算符 ，关系运算符 ，相等运算符 ，二进制位运算符 ，二进制逻辑运算符 ，赋值运算符 ，逗号运算符。</li>
<li>ECMAScript对象可以通过各种方式创建，包括字面符号，或通过 构造器 创建对象然后运行代码初始化其全部或部分属性值，为这些属性分配初始值。每个构造器是一个拥有名为“prototype”的属性的函数。此属性用于实现 基于原型的继承 和 共享属性 。构造器通过 new 表达式创建对象,不使用 new 调用一个构造器的结果，依赖构造器本身。</li>
<li>每个由构造器创建的对象，都有一个隐式引用 ( 叫做对象的原型 ) 链接到构造器的“prototype”属性值。再者，原型可能有一个非空 (non-null) 隐式引用链接到它自己的原型，以此类推，这叫做 原型链 。当向对象的一个属性提出引用，引用会指向原型链中包含此属性名的第一个对象的此属性。换句话说，首先检查直接提及的对象的同名属性，如果对象包含同名的属性，引用即指向此属性，如果该对象不包含同名的属性，则下一步检查对象的原型；以此类推。</li>
<li>一般情况下基于类的面向对象语言的实例拥有状态，类拥有方法，并且只能继承结构和行为。在 ECMAScript 中，对象拥有状态和方法，并且结构，行为，状态全都可继承。</li>
<li>ECMAScript 的严格变体通常被称为语言的 严格模式 (strict mode)。严格模式选择使用的 ECMAScript 严格模式的语法和语义，明确地适用于个别 ECMAScript 代码单元级别。由于严格模式适用于选择的语法代码单元级别，严格模式仅在这个代码单元内施加有局部效果的限制。严格模式不限制或修改任何必须运行在多个代码单元的 ECMAScript 语义层面。一个 ECMAScript 程序可由严格模式和非严格模式的代码单元组成。在这种情况下，严格的模式只适用于严格模式代码单元内实际执行的代码。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>JavaScript ( JS ) 是一种轻量级解释型的，或是JIT编译型的程序设计语言，有着 头等函数 (First-class Function) 的编程语言。虽然它是作为开发web页面的脚本语言而出名的，但是在很多非浏览器环境中也使用JavaScript，例如 node.js 和 Apache CouchDB。JS是一种基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格</li>
</ul>
</blockquote>
<h1 id="为什么学习？"><a href="#为什么学习？" class="headerlink" title="为什么学习？"></a>为什么学习？</h1><ol>
<li>操控浏览器的能力</li>
<li>广泛的使用领域<ul>
<li>浏览器的平台化</li>
<li>Node</li>
<li>数据库操作（NoSQL） </li>
<li>跨移动平台</li>
<li>内嵌脚本语言</li>
<li>跨平台的桌面应用程序</li>
</ul>
</li>
<li>易学性<ul>
<li>学习环境无处不在</li>
<li>简单性</li>
<li>与主流语言的相似性<br>虽然核心语法不难，但是 JavaScript 的复杂性体现在另外两个方面。<br>首先，它涉及大量的外部 API。<br>其次，JavaScript 语言有一些设计缺陷。</li>
</ul>
</li>
<li>强大的性能<ul>
<li>灵活的语法，表达力强 </li>
<li>支持编译运行</li>
<li>事件驱动和非阻塞式设计</li>
</ul>
</li>
<li>开放性</li>
<li>社区支持和就业机会</li>
</ol>
<h1 id="使用-浏览器-："><a href="#使用-浏览器-：" class="headerlink" title="使用(浏览器)："></a>使用(浏览器)：</h1><p>方法一，写在页面上，用<code>&lt;script&gt;...&lt;/script&gt;</code>包含起来，它将直接被浏览器执行；<br>方法二，把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>引入这个文件；</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6]]></title>
      <url>https://dudujie0915.github.io/2017/06/06/JavaScript/ES6/</url>
      <content type="html"><![CDATA[<h1 id="1-块的作用域"><a href="#1-块的作用域" class="headerlink" title="1.块的作用域"></a>1.块的作用域</h1><p>let</p>
<h1 id="2-恒量"><a href="#2-恒量" class="headerlink" title="2.恒量"></a>2.恒量</h1><p>const：只是不能重新生成新的值，但是可以改变它的值</p>
<h1 id="3-解构数组"><a href="#3-解构数组" class="headerlink" title="3.解构数组"></a>3.解构数组</h1>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS揭秘]]></title>
      <url>https://dudujie0915.github.io/2017/04/06/CSS/CSS%E6%8F%AD%E7%A7%98/</url>
      <content type="html"><![CDATA[<h1 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>已彻底掌握CSS 2.1；</li>
<li>了解并使用最流行的CSS 3特性；</li>
<li>了解SVG；</li>
<li>读懂简单、原生的JS代码；</li>
<li>听说过 CSS预处理器；</li>
<li>高一数学；</li>
</ul>
<a id="more"></a>
<h2 id="浏览器支持与退回机制"><a href="#浏览器支持与退回机制" class="headerlink" title="浏览器支持与退回机制"></a>浏览器支持与退回机制</h2><ul>
<li>某些特性得到浏览器支持，但是不同的浏览器表现上有细微的差异，可能需要一个浏览器前缀（应该把标准语法排在最后），或者在语法上存在着细微的差别；</li>
<li>提供退回机制可以确保网站不会在低版本浏览器中挂掉，只是看出来没那么炫而已；</li>
<li>可以使用<a href="http://modernizr.com" target="_blank" rel="noopener">Modernizr</a>这样的工具给根元素（<html>）添加一些辅助类，这样可以针对支持或不支持某些特性的浏览器来分别编写样式；</html></li>
<li>用@supports（慎用）规则实现回退，可以将其视作浏览器“原生”的Modernizr；</li>
<li>可以自己编写JS代码，检测某个样式属性是否被支持，核心思路就是在任一元素的element.style对象上检查该属性是否存在；</li>
<li>浏览器可以解析某个CSS特性并不代表它已经实现（或正确实现）了这个特性；</li>
</ul>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="Web标准：是敌还是友"><a href="#Web标准：是敌还是友" class="headerlink" title="Web标准：是敌还是友"></a>Web标准：是敌还是友</h2><h3 id="标准的制定过程"><a href="#标准的制定过程" class="headerlink" title="标准的制定过程"></a>标准的制定过程</h3><ul>
<li>W3C并不“生成”标准，它扮演了一个论坛的角色，技术规范（基本上）并不是由W3C的工作人员编写完成的，CSS规范通常是由CSS工作组（主要是W3C会员公司，主要包括浏览器厂商等，所有浏览器厂商比W3C有更多的发言权）的成员来编写的；W3C 免费、开放；制定规则不是闭门造车；</li>
<li>规范的制定过程：①编辑草案（ED）；②首个公开工作草案（FPWD）；③工作草案（WD）；④候选推荐规范（CR）；⑤提名推荐规范（PR）；⑥正式推荐规范（REC）；</li>
</ul>
<h3 id="CSS3、CSS4以及其他传说"><a href="#CSS3、CSS4以及其他传说" class="headerlink" title="CSS3、CSS4以及其他传说"></a>CSS3、CSS4以及其他传说</h3><ul>
<li>一项规范如果要推进到最终阶段，其中的每项特性都必须具备两个独立的实现和全面的测试；</li>
<li>尽管“CSS3”这个名词非常流行，但它实际上并没有在任何规范中定义过；</li>
</ul>
<h3 id="冰与火之歌：浏览器前缀"><a href="#冰与火之歌：浏览器前缀" class="headerlink" title="冰与火之歌：浏览器前缀"></a>冰与火之歌：浏览器前缀</h3><ul>
<li>每个浏览器都可以实现这些实验性的（甚至是私有的、非标准的）特性，但是在名称前面加上自己特有的前缀；</li>
<li>最常见的前缀分别是Firefox的-moz-、IE的-ms-、Opera的-o-已经Safari和Chrome的-webkit-；</li>
<li>为了解决浏览器前缀编写困难的问题，用工具自动化来实现：<br>  像<a href="http://css3please.com" target="_blank" rel="noopener">CSS3，Please！</a>和<a href="http://pleeease" target="_blank" rel="noopener">pleeease</a>在线网站，自动生成必要的前缀；<br>  <a href="http://github.com/ai/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a>采用<a href="http://caniuse.com" target="_blank" rel="noopener">Can I Use…</a>的数据库来判断必要的前缀，它是在本地完成编译的，类似预处理器；<br>  <a href="http://leaverou.github.io/prefixfree" target="_blank" rel="noopener">-prefix-free</a>在浏览器中进行特性检测是否需要前缀；<br>  类似<a href="http://stylus-lang.com" target="_blank" rel="noopener">Stylus</a>和<a href="http://lesscss.org" target="_blank" rel="noopener">LESS</a>或<a href="http://sass-lang.com" target="_blank" rel="noopener">Sass</a>的预处理器本身不自带，但第三方有常用属性加前缀的mixin；</li>
<li>浏览器前缀是一场史诗般的失败；</li>
<li>在现在浏览器中，实验性特性主要是通过配置开个来启动；</li>
</ul>
<h2 id="CSS编码技巧"><a href="#CSS编码技巧" class="headerlink" title="CSS编码技巧"></a>CSS编码技巧</h2><h3 id="尽量减少代码重复"><a href="#尽量减少代码重复" class="headerlink" title="尽量减少代码重复"></a>尽量减少代码重复</h3><p>保持代码的DIY和可维护性是代码开发中最大的挑战之一，代码可维护性的最大要素是尽量减少改动时要编辑的地方；这不仅是后期修改的问题，灵活的CSS更容易扩展：在写出基础样式之后，只用极少的代码就可以扩展出不同的变体，因为只需要覆盖一些变量就可以了；<br><a href="http://oboiq86te.bkt.clouddn.com/CSS%E6%8F%AD%E7%A7%98/%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D.html" target="_blank" rel="noopener">减少代码重复</a></p>
<ol>
<li><p>代码易维护 vs. 代码量少<br> 有时间不可兼得，比如上面超链接里的代码，最终的代码比一开始的版本略长，比如下面的代码片段</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-width: 10px 10px 10px 0;</span><br><span class="line">//修改为</span><br><span class="line">border-width: 10px;</span><br><span class="line">border-left-width: 0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>currentColor<br> CSS中有史以来第一个变量；它并没有绑定一个固定的颜色值，而是一直被解析为color；它本身就是很多CSS颜色属性的初始值，比如border-color和outline-color,以及text-shadow和box-shadow的颜色值；</p>
</li>
<li>继承<br> inherit可以用在任何CSS属性中，而且它总是绑定到父元素的计算值（对于伪元素来说，则会取生成该伪元素的宿主元素）；表单元素的字体设置为与页面中其他部分相同，可以使用<code>input,select,button{font:inherit;}</code>；超链接的颜色设定为与页面中其它文本相同，可以使用<code>a{color:inherit;}</code>；对于背景上同样有用；</li>
</ol>
<h3 id="相信你的眼睛，而不是数字"><a href="#相信你的眼睛，而不是数字" class="headerlink" title="相信你的眼睛，而不是数字"></a>相信你的眼睛，而不是数字</h3><ul>
<li>视觉上的错觉在任何形式的视觉设计中都普遍存在，需要我们有针对性的调整；</li>
<li>我们眼睛看到一个完美垂直居中的物体时，会感觉并不居中，需要物体从中心点稍微向上挪一点；</li>
<li>圆形的字体比矩形字体要稍微放大一点；</li>
<li>给容器四边指定相同的内边距，实际效果看起来并不相等，原因在于字母的形状在两端都比较整齐，而顶部和底部则往往参数不齐，需要减少顶部和底部的内边距；</li>
</ul>
<h3 id="关于响应式网页设计"><a href="#关于响应式网页设计" class="headerlink" title="关于响应式网页设计"></a>关于响应式网页设计</h3><ul>
<li>使用媒体查询，每个媒体查询都会增加成本；只要用对了，它就是利器；</li>
<li>媒体查询的断点不应该由具体的设备来决定，而应该根据设计自身来决定；</li>
<li>避免不必要额媒体查询的方法：①使用百分比长度取代固定长度；②当需要在较大分辨率下得到固定宽度，使用max-width而不是width；③为替换元素设置一个max-width，值为100%；④背景铺满一个容器，background-size: cover都可以做到（移动端上不太明智，带宽问题）；⑤当图片（或其它元素）以行列式进行布局时，让视口的宽度来决定列的数量；弹性盒布局或display: inline-block加上常规的文本折行行为，都可以实现；⑥使用多列文本时，指定column-width（列宽）而不是指定column-count（列数），这样可以在较小的屏幕上自动显示为单列布局；</li>
<li>实现弹性可伸缩的布局，并在媒体查询的各个断点区间内指定相应的尺寸；</li>
</ul>
<h3 id="合理使用简写"><a href="#合理使用简写" class="headerlink" title="合理使用简写"></a>合理使用简写</h3><ul>
<li>合理使用简写是一种良好的防卫性编码方式，可以抵御未来的风险；</li>
<li>要明确地去覆盖某个具体的展开式属性并保留其他相关样式，就需要用展开属性；</li>
<li>如果只为某个属性提供一个值，那它会扩散并应用到列表中的每一项；</li>
</ul>
<h3 id="我应该使用预处理器吗？"><a href="#我应该使用预处理器吗？" class="headerlink" title="我应该使用预处理器吗？"></a>我应该使用预处理器吗？</h3><ol>
<li>预处理器的种类：<br> <a href="http://stylus-lang.com" target="_blank" rel="noopener">Stylus</a><br> <a href="http://lesscss.org" target="_blank" rel="noopener">LESS</a><br> <a href="http://sass-lang.com" target="_blank" rel="noopener">Sass</a></li>
<li>优点：<br> 为CSS的编写提供了一些便利，比如变量、mixin、函数、规则嵌套、颜色处理等；<br> 如果使用得当，它们在大型项目中可以让代码更加灵活；</li>
<li>缺点：<br> CSS的文件的体积和复杂性可能会失控；<br> 调试难度会增加（目前问题基本解决）；<br> 在开发过程中引入了一定程度的延时（差不多一秒钟）；<br> 更高的学习成本，要么强制协作者接受我们的选择，要么话费额外的时间来培训；<br> 抽象泄露法则，预处理器有自身的bug；<br> 网站开发者可能会不自觉地“依赖”和“滥用”；</li>
<li>未来：<br> 很多受处理器启发的特性都已经以各种方式融入到原生CSS中了；<br> 原生特性通常比预处理器的版本强大得多，因为它们是动态的；<br> 在引入预处理器的问题上需要冷静决策；</li>
</ol>
<h1 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h1><h2 id="半透明边框（1）"><a href="#半透明边框（1）" class="headerlink" title="半透明边框（1）"></a>半透明边框（1）</h2><p><a href="play.csssecrets.io/translucent-borders">半透明边框</a></p>
<ol>
<li>难题：<br> 默认情况下，背景会延伸到边框所在的区域下面，所以我们设置的边框半透明会被背景颜色所遮挡；</li>
<li>解决方案：<br> CSS3中通过background-clip属性来调整默认行为带来的不便；<br> 这个属性的初始值是border-box，意味着背景会被元素的border-box(边框的外沿框)裁切掉；<br> 如果把这个属性的值设为padding-box，浏览器会用内边距的外沿来把背景裁切掉；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chrome字体小于12px的显示]]></title>
      <url>https://dudujie0915.github.io/2017/03/31/HARK/Chrome%E5%AD%97%E4%BD%93%E5%B0%8F%E4%BA%8E12px%E7%9A%84%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>在IE、Firefox浏览器下，字体可以小于12px显示，但是在Chrome浏览器下字体最小显示为12px，但是有时候需要显示小于12px的字体，如何显示呢？<br><strong>历史解决方案：</strong><code>-webkit-font-size-adjust:none;</code>,新版浏览器已经不支持了；<br><strong>现在解决方案：</strong>配合html，-webkit-transform:scale(num)来解决问题<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>字体为10px<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">font-size</span>:<span class="number">10px</span>;<span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(0.8);<span class="attribute">display</span>:inline-block;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">/*</span><br><span class="line">* 如果<span class="tag">&lt;<span class="name">p</span>&gt;</span>元素有背景的话，transform会是背景随之变化，所有嵌套一个<span class="tag">&lt;<span class="name">span</span>&gt;</span>；</span><br><span class="line">* 因为transfrom只为可以缩放可以定义宽高的元素起作用，<span class="tag">&lt;<span class="name">span</span>&gt;</span>是行内元素，所有设置display:inline-block;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> HARK </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> HARK </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[省略号]]></title>
      <url>https://dudujie0915.github.io/2017/03/31/CSS/%E7%9C%81%E7%95%A5%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>非常实用的CSS片段，包括单行省略号和多行省略号，主要是单行省略号，多行省略号在后端页面输出的时候处理效果更好，不过前端也可以处理，只是有点繁琐；</p>
<ol>
<li>单行显示：   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">160px</span>; <span class="comment">/* 控制显示的宽带,主要是兼容部分浏览器 */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 隐藏超出单元格的部分 */</span></span><br><span class="line">    <span class="attribute">text-overflow</span>:ellipsis; <span class="comment">/* 将被隐藏的那部分用省略号代替 */</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap; <span class="comment">/* 保证文本内容不会自动换行，如果多余的内容会在水平方向撑破单元格 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol start="2">
<li>多行显示<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>; <span class="comment">/* 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示  */</span></span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>; <span class="comment">/* 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 */</span></span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3; <span class="comment">/* 用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： */</span></span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合js优化该方法。 */</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">position</span>: relative; <span class="attribute">line-height</span>: <span class="number">20px</span>; <span class="attribute">max-height</span>: <span class="number">40px</span>;<span class="attribute">overflow</span>: hidden;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>: <span class="string">"..."</span>; <span class="attribute">position</span>: absolute; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将height设置为line-height的整数倍，防止超出的文字露出。</span></span><br><span class="line"><span class="comment">给p::after添加渐变背景可避免文字只显示一半。</span></span><br><span class="line"><span class="comment">由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：&lt;span&gt;…&lt;span/&gt;）；兼容ie8需要将::after替换成:after。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML+HTML5知识点整理]]></title>
      <url>https://dudujie0915.github.io/2016/09/09/HTML/HTML+HTML5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="一、HTML标记语言"><a href="#一、HTML标记语言" class="headerlink" title="一、HTML标记语言"></a>一、HTML标记语言</h1><ol>
<li>HTML语法：<ul>
<li>什么是HTML标记语言</li>
<li>HTML的标记和它的属性</li>
<li>语法不区分字母大小写</li>
<li>文档注释</li>
<li>代码格式</li>
<li>字符实体</li>
</ul>
</li>
<li>HTML的基本结构：<ul>
<li>html</li>
<li>head</li>
<li>title</li>
<li>body</li>
<li>meta<a id="more"></a>    </li>
</ul>
</li>
<li>文档：<ul>
<li>[x] 格式标记（br、p、center、pre、li、ul、ol、dl、dt、dd、hr、div）</li>
<li>文本标记（hn、font、b、sub、sup、i、tt、cite、em、strong、small、big、）</li>
</ul>
</li>
<li>图像标记：img</li>
<li>超文本的使用： a</li>
<li>HTML框架：frameset、frame</li>
<li>表格：<ul>
<li>table</li>
<li>caption</li>
<li>tr</li>
<li>td、th</li>
</ul>
</li>
<li>表单设计：<ul>
<li>表单标记form</li>
<li>文本域text和密码possword–input</li>
<li>提交submit、重置reset、普通按钮button–input</li>
<li>单选框radio和复选框checkbox–input</li>
<li>隐藏域hidden</li>
<li>多行文本域textarea</li>
<li>菜单下拉列表域select</li>
</ul>
</li>
</ol>
<h1 id="二、HTML5标记语言"><a href="#二、HTML5标记语言" class="headerlink" title="二、HTML5标记语言"></a>二、HTML5标记语言</h1><ol>
<li>canvas新元素</li>
<li>SVG新元素</li>
<li>新多媒体元素：<ul>
<li>audio</li>
<li>video</li>
<li>source</li>
<li>embed</li>
<li>track</li>
</ul>
</li>
<li>新表单元素和表单属性<ul>
<li>datalist</li>
<li>keygen</li>
<li>output</li>
<li>form新属性（autocomplete、novalidate）</li>
<li>input新属性（autocomplete、autofocus、form、formaction、formenctype、formmethod、formnovalidate、formtarget、height and width、list、min and max、multiple、pattern、plachholder、required、step、）</li>
</ul>
</li>
<li>新的语义和结构元素<ul>
<li>article</li>
<li>aside</li>
<li>bdi</li>
<li>command</li>
<li>details</li>
<li>dialog</li>
<li>summary</li>
<li>figure</li>
<li>figcaption</li>
<li>footer</li>
<li>header</li>
<li>mark</li>
<li>meter</li>
<li>nav</li>
<li>progress</li>
<li>ruby</li>
<li>rt</li>
<li>rp</li>
<li>section</li>
<li>time</li>
<li>wbr</li>
</ul>
</li>
<li>MathML元素</li>
<li>HTML5拖放（Rrag和Drop）</li>
<li>HTML5地理定位（Geolocation）</li>
<li>HTML新的Input类型：<ul>
<li>color</li>
<li>date</li>
<li>datetime</li>
<li>datetime-local</li>
<li>email</li>
<li>month</li>
<li>number</li>
<li>range</li>
<li>search</li>
<li>tel</li>
<li>time</li>
<li>url</li>
<li>week</li>
</ul>
</li>
<li>HTML5 Web存储：<ul>
<li>localStorage</li>
<li>sessionStorage</li>
</ul>
</li>
<li>HTML5 Web SQL 数据库</li>
<li>HTML5 应用程序缓存</li>
<li>HTML5 Web Workers</li>
<li>HTML5 服务器发送事件(Server-Sent Events)</li>
<li>HTML5 WebSocket</li>
</ol>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML </tag>
            
            <tag> HTML5 </tag>
            
            <tag> 知识点 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【教程】CSS权威指南《第三版》]]></title>
      <url>https://dudujie0915.github.io/2016/08/12/CSS/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8A%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B/</url>
      <content type="html"><![CDATA[<h1 id="一、CSS和文档"><a href="#一、CSS和文档" class="headerlink" title="一、CSS和文档"></a>一、CSS和文档</h1><h2 id="1-CSS2的media属性："><a href="#1-CSS2的media属性：" class="headerlink" title="1. CSS2的media属性："></a>1. CSS2的media属性：</h2><ul>
<li>all，aural，brailla，embossed，handheld，print，projection，screen，tty，tv；</li>
<li>all、screen、print得到广泛支持；</li>
<li>可以直接在link中使用，也可以直接在css文件中使用，或者在style中使用也可以；</li>
</ul>
<h2 id="2-候选样式表："><a href="#2-候选样式表：" class="headerlink" title="2. 候选样式表："></a>2. 候选样式表：</h2><ul>
<li>rel属性的值设为alternate stylesheet，定义候选样式表，用户选择时调用；</li>
<li>浏览器支持的话，会使用link元素的title属性值生成一个候选样式列表，默认显示第一个link或者是title名为Default的（不确定，需要实验）；</li>
<li>为候选样式表定义相同title值，把他们分组在一起，用户可在不同的媒介中选择不同的样式表；<a id="more"></a>
</li>
</ul>
<h2 id="3-import指令："><a href="#3-import指令：" class="headerlink" title="3. @import指令："></a>3. @import指令：</h2><ul>
<li>@import它必须放在其他css规则之前，可以放在style标签中，或者是css文件中；</li>
<li>可以有多个@import，但是低版本解析可能有问题（或许是ie5一下的版本，需要实验）；</li>
<li>可以添加media属性；</li>
<li>绝对路径和相对路径都可以；</li>
</ul>
<h2 id="4-向后可访问性："><a href="#4-向后可访问性：" class="headerlink" title="4. 向后可访问性："></a>4. 向后可访问性：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined">&lt;!--</span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(sheet2.css);</span></span><br><span class="line"><span class="css"><span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:maroon;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span>&#123;<span class="attribute">background</span>:yellow;&#125;</span></span><br><span class="line"><span class="undefined">--&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样表示，较老的浏览器会将style标记完全忽略，还会忽略声明（目前应该不存在这个问题，需要验证）；</p>
<h2 id="5-css注释："><a href="#5-css注释：" class="headerlink" title="5. css注释："></a>5. css注释：</h2><pre><code>不能嵌套；
</code></pre><h2 id="6-内联样式："><a href="#6-内联样式：" class="headerlink" title="6. 内联样式："></a>6. 内联样式：</h2><p>一个内联style属性中只能放一个声明块，二不能放整个样式表，因此，不能在style属性中放@import，也不能包含完整的规则；style属性的值中只能是规则中出现在大括号之间的部分；通常不推荐使用style属性；</p>
<h1 id="二、选择器"><a href="#二、选择器" class="headerlink" title="二、选择器"></a>二、选择器</h1><p><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/css%E5%A3%B0%E6%98%8E.png" alt="css声明"></p>
<ul>
<li>元素选择器（如p{}）、</li>
<li>选择器分组和声明分组（如h2,p{}）、</li>
<li>通配选择器（*{}）、</li>
<li>类选择器和多类选择器（如.class{}）、</li>
<li>ID选择器（如#id{}）、</li>
<li>属性选择器（如h1[class]{}，可以根据具体的属性值选择，也可以根据部分属性值选择）、</li>
<li>特定属性选择类型（如*[lang|=”en”]{}）</li>
<li>使用文档结构：<br>  后代选择器（如 h1 em{}）<br>  选择子元素（如 h1&gt;em{}） （我使用较少）<br>  选择相邻兄弟元素（如 h1+em{}）（我使用较少）</li>
<li>伪类和伪元素：</li>
<li>类选择器和id选择器使用需要主要，还有两类选择器区分大小写；</li>
<li>属性选择器（根据部分选择）（需要验证支持情况）<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="子字符串匹配性选择器"></li>
<li>伪类和伪元素：<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB.png" alt="链接伪类"><br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%8A%A8%E6%80%81%E4%BC%AA%E7%B1%BB.png" alt="动态伪类"><br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%8A%A8%E6%80%81%E4%BC%AA%E7%B1%BB2.png" alt="动态伪类2"><br>  为了为顺序很重要，通常建议“link-visited-hover-active”（具体愿意以后发文说明）；<br>  选择第一个子元素 :first-child<br>  根据语言选择 *:lang(fr){}</li>
<li>伪元素选择器：（属性的限制需要了解）<br>  设置首字母样式 :first-letter<br>  设置第一行样式  :first-line<br>  设置之前和之后元素的样式   :before和:after</li>
</ul>
<h1 id="三、结构和层叠"><a href="#三、结构和层叠" class="headerlink" title="三、结构和层叠"></a>三、结构和层叠</h1><h2 id="1-特殊性："><a href="#1-特殊性：" class="headerlink" title="1. 特殊性："></a>1. 特殊性：</h2><p><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E7%89%B9%E6%AE%8A%E6%80%A7.png" alt="特殊性"><br>    实际上，特殊性值0,0,1,0比值0,0,0,13更高。<br>    通配选择器特殊性：其特殊性为0,0,0,0；<br>    内联样式特殊性：其特殊性为1,0,0,0；<br>    重要声明!important:级别最高；</p>
<h2 id="2-继承："><a href="#2-继承：" class="headerlink" title="2. 继承："></a>2. 继承：</h2><ul>
<li>在HTML中，对于向上传播有一个例外：应用到body元素的背景样式可以传递到html元素（html是文档的根元素），相应地可以定义其画布；</li>
<li>不能继承的属性: 一般的，大多数框模型属性（包括外边距、内边距、背景和边框）都不能继承；a标签的样色，样式；</li>
<li>继承的值根本没有特殊性，甚至连0特殊性都没有；</li>
<li>0特殊性比无特殊性要强；</li>
<li>继承有bug：在不同的浏览器中显示不一样，所有设置global.css（通用样式）；</li>
</ul>
<h2 id="3-层叠："><a href="#3-层叠：" class="headerlink" title="3. 层叠："></a>3. 层叠：</h2><p><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%B1%82%E5%8F%A0.png" alt="层叠"></p>
<ul>
<li>按权重和来源排序：<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%A3%B0%E6%98%8E%E6%9D%83%E9%87%8D.png" alt="声明权重"></li>
<li>按特殊性排序：较高特殊性强于较低特殊性；</li>
<li>按顺序排序：后出现原则；<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E6%8E%92%E5%BA%8F.png" alt="排序"></li>
<li>非CSS表现提示：它被处理为特殊性为0，并出现在创作人员样式表的最前面；只要有创作人员或者读者样式，这种表现提示就会被覆盖，但是用户代理的样式不能将其覆盖。</li>
</ul>
<h1 id="四、值和单位"><a href="#四、值和单位" class="headerlink" title="四、值和单位"></a>四、值和单位</h1><h2 id="1-数字："><a href="#1-数字：" class="headerlink" title="1. 数字："></a>1. 数字：</h2><p>CSS中有两类数字：整数和实数（小数）；</p>
<h2 id="2-百分数"><a href="#2-百分数" class="headerlink" title="2. 百分数"></a>2. 百分数</h2><h2 id="3-颜色："><a href="#3-颜色：" class="headerlink" title="3. 颜色："></a>3. 颜色：</h2><p>颜色名、RGB颜色、RGBA颜色<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E9%A2%9C%E8%89%B2.png" alt="颜色"></p>
<ul>
<li>大多数Web浏览器能够识别多达140个颜色名，包括前面的17个。</li>
<li>RGB颜色可以用百分数值（范围在0%~100%）或者整数（范围在0~255）表示</li>
<li>十六进制RGB颜色（三个数值范围介于00~FF，语法是#RRGGBB）（如果组成十六进制数的3组数各自是成对的，可以采用#RGB的简写记法）<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/web%E5%AE%89%E5%85%A8%E9%A2%9C%E8%89%B2.png" alt="web安全颜色"></li>
</ul>
<h2 id="4-长度单位："><a href="#4-长度单位：" class="headerlink" title="4. 长度单位："></a>4. 长度单位：</h2><ul>
<li>所有长度单位都可以表示为正数或者负数，其后跟一个标签（不过有些属性只接受整数）；另外可以使用实数；所有长度单位后面都有一个长度单位（只有一个例外，长度为0时，后面不需要跟单位）</li>
<li>绝对长度单位：英寸（in）、厘米（cm）、毫米（mm）、点（pt）、派卡（pc）</li>
<li>相对长度单位：em,ex,px,rem等<br>  em:相对于当前元素的font-size值，如字体14px，那么当前内容的 1em=14px；</li>
</ul>
<h2 id="5-URL："><a href="#5-URL：" class="headerlink" title="5. URL："></a>5. URL：</h2><p>相对路径和绝对路径；url与内容之间不能有空格；</p>
<h2 id="6-关键字："><a href="#6-关键字：" class="headerlink" title="6. 关键字："></a>6. 关键字：</h2><p>none，normal，inherit（继承父元素的值）等；</p>
<h2 id="7-其他单位："><a href="#7-其他单位：" class="headerlink" title="7.其他单位："></a>7.其他单位：</h2><p>(其他单位在CSS2中使用，当前是否使用需测试)</p>
<ul>
<li>角度值—-度(deg)、梯度(grad)、弧度(rad)</li>
<li>时间值—-毫米(ms)、秒(s);</li>
<li>频率值—-赫兹(Hz)、兆赫(MHz)</li>
</ul>
<h1 id="五、字体"><a href="#五、字体" class="headerlink" title="五、字体"></a>五、字体</h1><h2 id="1-字体系列"><a href="#1-字体系列" class="headerlink" title="1. 字体系列:"></a>1. 字体系列:</h2><ul>
<li>特定字体系列(如Times、Verdana、Helvetica或Arial)</li>
<li>通用字体系列(Serif字体、Sans-serif字体、Monospace字体、Cursive字体、Fantasy字体)</li>
<li>使用通用字体系列：属性font-family定义</li>
<li>指定字体系列：属性font-family定义<br>  注：强烈建议在所有font-family规则中都提供一个通用字体系列（原因：如果没有找到指定字体，会找一个与指定字体最接近的通用字体）</li>
<li>设置多个字体（首先确定这些字体的优先顺序，然后用逗号把他们连起来，如：<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%A4%9A%E5%AD%97%E4%BD%93.png" alt="多字体"><br>  使用引号：<pre><code>①只有当一个字体名称中有一个或多个空格（如New York），或者如果字体名包括#或者$之类的符号，才需要在font-family声明中加引号；
②如果没有引号，尽管规则的余下的部分会得到处理，但用户代理有可能忽略这个特定的字体名;
③字体名中如果只包含一个词,而且这个词与font-family的任何关键字都不冲突,就不需要加引号,通用字体系列名在指定具体的通用系列时不能加引号,如果加上引号,代表特定字体;
④双引号或单引号都可以,但是如果把一个font-family规则放在style属性里,则需要使用该属性本身未曾使用的那种引号;
</code></pre></li>
</ul>
<h2 id="2-字体加粗和变细："><a href="#2-字体加粗和变细：" class="headerlink" title="2. 字体加粗和变细："></a>2. 字体加粗和变细：</h2><ul>
<li>属性font-weight定义<br>   关键字100-900、bold、bolder,400等价于normal,700等价于bold（bolder的使用方法，根据字体的设置级别）<br>   关键字lighter</li>
</ul>
<h2 id="3-字体大小："><a href="#3-字体大小：" class="headerlink" title="3. 字体大小："></a>3. 字体大小：</h2><ul>
<li>属性font-size定义<br>  2个相对大小关键字larger和smaller；<br>  7个绝对大小值xx-small、x-small、small、medium、large、x-large、xx-large；<br>  百分数值总是根据从父元素继承的大小来计算；<br>  字体可以继承，继承的是计算值而不是百分比，百分比可以累积；<br>  使用长度单位（不建议）；<br>  使用px定义</li>
</ul>
<h2 id="4-字体风格："><a href="#4-字体风格：" class="headerlink" title="4. 字体风格："></a>4. 字体风格：</h2><ul>
<li>属性font-style定义<br>  normal（默认）、italic、oblique<br>  italic（斜体）和oblique（倾斜）的区别</li>
</ul>
<h2 id="5-字体变形"><a href="#5-字体变形" class="headerlink" title="5. 字体变形:"></a>5. 字体变形:</h2><ul>
<li>属性font-variant定义<br>  normal(默认)、small-caps</li>
</ul>
<h2 id="6-font属性"><a href="#6-font属性" class="headerlink" title="6. font属性:"></a>6. font属性:</h2><p><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/font.png" alt="font"></p>
<ul>
<li>①只是font的前3个值允许采用任何的顺序，后两个font-size、font-family要按照以此顺序作为声明中的最后两个值，font声明必须有这两个值；</li>
<li>②font可以设置line-height，并且总是在font-szie之后，两者用斜线(/)与分割；</li>
<li>③适当的使用简写，在使用简写属性font时，所以被忽略的值都会重置为其默认值；</li>
<li>④如果希望一个Web页面结合用户操作系统的设置，使用系统字体，这些值用于取得操作系统中元素的字体大小，自体系列，字体加重，字体风格，字体变形（后面两个被废除），并将其应用到一个元素。这些值如下：caption（用于有标题的控件，如按钮），icon（用于对图标加标签），menu（用于菜单，即下拉菜单和菜单列表），message-box（用于对话框），small-caption（用于对小控件加标签），status-bar（用于窗口状态条）；注意，系统字体可能只能整体设置；（注意，以前不知道）</li>
<li>@font-face规则：<br>  ①重要，在css2中有，但是css2.1中删除，css3中重新；<br>  ②字体名匹配；<br>  ③智能字体匹配；<br>  ④字体合成；<br>  ⑤字体下载；</li>
</ul>
<h1 id="六、文本属性"><a href="#六、文本属性" class="headerlink" title="六、文本属性"></a>六、文本属性</h1><h2 id="1-缩进和水平对齐："><a href="#1-缩进和水平对齐：" class="headerlink" title="1. 缩进和水平对齐："></a>1. 缩进和水平对齐：</h2><ul>
<li>缩进text-indent：①所有元素第一行都可以所以给定长度，可以是负值，最常见的用途是段落的首行缩进；②块级元素可以使用，行内元素无法使用，图像之类的替换元素也无法使用（行内元素的缩进可以使用左内边距或者外边距创造这种效果）；③负值最常见的用途是一种“悬挂缩进”，即第一行悬挂在元素中余下部分的左边；④可以使用所有长度单位（包括百分数值）；⑤这个属性可以继承；</li>
<li>水平对齐text-align：①值left，center，right会导致元素中的文本分别左对齐，居中，右对齐；②只能应用于块级元素；③西方语言默认值是left，希伯来语和阿拉伯语之类的语言默认值是right；④值justify，两段对齐，显示方式有问题，不统一；⑤css没有指定应该如何处理连字符；</li>
</ul>
<h2 id="2-垂直对齐："><a href="#2-垂直对齐：" class="headerlink" title="2. 垂直对齐："></a>2. 垂直对齐：</h2><ul>
<li>行高line-height控制了行间距；</li>
<li>构造文本行；</li>
<li>指定line-height值：默认值normal，通常是字体大小的1.2倍（只是通常），大多数值都是简单的长度单位；</li>
<li>行高和继承：line-height值从父元素继承时，要从父元素计算，而不是在子元素上计算；解决继承问题的办法是制定一个数，有它设置缩放因子，此时缩放因子将是继承值而不是计算值，该数会应用到该元素及其所有的子元素;</li>
</ul>
<h2 id="3-垂直对齐文本"><a href="#3-垂直对齐文本" class="headerlink" title="3. 垂直对齐文本:"></a>3. 垂直对齐文本:</h2><ul>
<li>vertical-align属性值应用与行内元素和替换元素,此属性不能继承;此属性只接受八个关键字、一个百分数值(相对于元素的line-height值)或一个长度值，包括baseline（默认值）、sub、super、bottom、text-bottom、moddle、top、text-top;应用到表单元格时,只能识别baseline、top、middle和bottom等，并且影响元素的垂直对齐；</li>
<li>基线对齐：vertical-align:baseline，如果是一个图像或者表单输入元素，或者是其他替换元素—-那么该元素的底端与其父元素的基线对齐；</li>
<li>上标和下标：vertical-align:sub声明会使用一个元素变成下标，无具体规定元素降低的距离，所以不同用户代理，距离可能不同；super为上标，同样，距离不定；</li>
<li>底端对齐：vertical-align:bottom,text-bottom指行内文本的底端，替换元素或者其它类型的非文本元素会忽略这个值；</li>
<li>顶端对齐：vertical-align:top；</li>
<li>居中对齐：vertical-align:middle,往往应用于图像；</li>
<li>百分数：会把元素的基线（或者替换元素的底边）相对于父元素的基线升高或者降低指定的量（指定的百分数要计算为该元素line-height的百分数，二不是相对于其父元素的line-height），正百分比使元素升高，负值则会使其降低。</li>
</ul>
<h2 id="4-字间隔和字母间隔"><a href="#4-字间隔和字母间隔" class="headerlink" title="4. 字间隔和字母间隔:"></a>4. 字间隔和字母间隔:</h2><ul>
<li>字间隔:word-spacing,可以我正长度值或负长度值,这个长度会增加到字之间的标准间隔,默认值normal与设置值为0是一样的;”字”没有明确定义;</li>
<li>字母间隔:letter-spacing,①值同字间隔一样,与字间隔遇到同样的问题;可以用来突出强调效果;②间隔与对齐:值可能受text-align属性值的影响;无法为word-spacing或letter-spacing定义一个可继承的缩放因子来取代计算值;</li>
</ul>
<h2 id="5-文本转换"><a href="#5-文本转换" class="headerlink" title="5. 文本转换:"></a>5. 文本转换:</h2><p>text-transform,默认值none对文本不做任何改动,将使用源文档中原有的大小写,uppercase和lowercase将文本转换为全大写或全小写字符,capitalize只对每个单词的首字母大写;</p>
<h2 id="6-文本装饰"><a href="#6-文本装饰" class="headerlink" title="6.文本装饰:"></a>6.文本装饰:</h2><ul>
<li>①text-decoration,值underline下划线,overline上划线,line-through贯穿线,blink文本闪烁,none删除装饰;可以在一个规则中结合多种装饰(例如a:link,a:visited{text-decoration:underline overline;} );</li>
<li>②怪异的装饰:text-decoration不能继承；改变装饰的颜色可以定义子元素的颜色和子元素的装饰属性；</li>
</ul>
<h2 id="7-文本阴影："><a href="#7-文本阴影：" class="headerlink" title="7. 文本阴影："></a>7. 文本阴影：</h2><p>text-shadow，CSS2支持，css2.1不支持，css3支持；默认无阴影，可以定义一个或多个阴影；每个阴影由一个颜色和三个长度值定义，前两个长度 值确定了阴影与文本的偏移距离，第三个长度值可选，定义了阴影的“模糊半径”；负长度值会使阴影落在原文的左上方；</p>
<h2 id="8-处理空白符："><a href="#8-处理空白符：" class="headerlink" title="8. 处理空白符："></a>8. 处理空白符：</h2><p>white-space，它会影响用户代理对源文档中空格、换行和tab字符的处理；值normal会丢掉多余的空白符，值pre，空白符不会被忽略；值nowrap会防止元素中的文本换行，可以使用white-space替换表单元格上的nowrap属性；值pre-wrap会使文本保留空白符，但是文本行会正常换行；值pre-line会合并空白符，但保留换行符；<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/white-space.png" alt="white-space"></p>
<h2 id="9-文本方向："><a href="#9-文本方向：" class="headerlink" title="9. 文本方向："></a>9. 文本方向：</h2><ul>
<li>direction，影响块级元素中文本的书写方向，表中列布局的方向、水平内容填充其元素框的方式，及两端对齐元素中最后一行的位置；对于行内元素，只有当unicode-bidi属性设置为embed或bidi-override时才会应用direction属性；有值ltr和rtl；</li>
<li>unicode-bidi：<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/unicode-bidi.png" alt="unicode-bidi"></li>
</ul>
<h1 id="七、基本视觉格式化"><a href="#七、基本视觉格式化" class="headerlink" title="七、基本视觉格式化"></a>七、基本视觉格式化</h1><h2 id="1-基本框"><a href="#1-基本框" class="headerlink" title="1. 基本框"></a>1. 基本框</h2><p>元素框：内容区、内边距、边框、外边距；<br>内容的背景会应用到内边框，外边框通常是透明的，从中可以看到父元素的背景；内边距不能是负值，外边距可以；边框没有设定颜色，那么边框将取元素内容的前景色，边框与内容和内边距有相同的颜色，边框的宽度绝对不能为负；<br>包含块：包含块有最近的块级祖先框、表单元格或者行内块祖先框的内容边界构成；</p>
<h2 id="2-块级元素"><a href="#2-块级元素" class="headerlink" title="2. 块级元素"></a>2. 块级元素</h2><h3 id="2-1-水平格式化："><a href="#2-1-水平格式化：" class="headerlink" title="2.1 水平格式化："></a>2.1 水平格式化：</h3><p>①width影响的是内容区的宽度；<br>②设定padding、border、margin后会隐式的增加width的值；<br>③正常流中块级元素框的水平部分综合就是等于父元素的width；  </p>
<h4 id="2-1-1-水平格式化的“7大属性”："><a href="#2-1-1-水平格式化的“7大属性”：" class="headerlink" title="2.1.1 水平格式化的“7大属性”："></a>2.1.1 水平格式化的“7大属性”：</h4><p>①margin-left,border-left,padding-left,width,padding-right,border-right,margin-right,这些属性和块级框的水平布局有关，这七个属性的值加在一起必须是元素包含块的宽度；<br>②只有3个属性可以设置为auto：width，margin-left，margin-right，其余的必须设置为特定的值，或者默认宽度为0；<br>③width不许设置为auto或者某种类型的非负值；</p>
<h4 id="2-1-2-使用auto"><a href="#2-1-2-使用auto" class="headerlink" title="2.1.2 使用auto"></a>2.1.2 使用auto</h4><p>①从每种程度上讲，可以使用auto弥补实际值与所需总和的差距；（如七个属性和为400px，无内边距或边框，右外边距和width都是100px，做外边距为auto，那么做外编剧的宽度将是200px）；<br>②如果所有的三个属性都设置为非auto的每个值，此时总会把margin-right强制为auto（如三个值都是100px，七个属性和为400px，那么margin-right会自动变为auto，此时margin-right的值为200px）；<br>③如果两个外边距都是显式的设置，而width设置为auto，width值将自动填充所需要的值，从而达到需要的总宽度（即父元素的内容宽度）；</p>
<h4 id="2-1-3-不只一个auto"><a href="#2-1-3-不只一个auto" class="headerlink" title="2.1.3 不只一个auto"></a>2.1.3 不只一个auto</h4><p>①如果两个外边距都设置为auto，那么元素在其父元素中居中；<br>②将某个外边距以及width设置为auto，设置为auto的外边距会减为0，然后width会设置为所需的值，使得元素完全填充其包含块；<br>③如果3个属性都设置为auto，那么两个外边距都会设置为0，而width会尽可能的宽（width默认为auto），这种结果与默认情况是相同的，即没有外边距或者width显式声明任何值；</p>
<h4 id="2-1-4-负外边距"><a href="#2-1-4-负外边距" class="headerlink" title="2.1.4 负外边距"></a>2.1.4 负外边距</h4><p>外边距可以为负，如果设置了负外边框，那么子元素的边框可能会大于父元素的宽；如果子元素的整体的width大于父元素的宽度，那么子元素的margin-right会默认为auto，此时auto的值为负数；<br><strong>内边距、边框和内容宽度（及高度）绝对不能为负，只有外边距能小于0；</strong></p>
<h4 id="2-1-5-百分数"><a href="#2-1-5-百分数" class="headerlink" title="2.1.5 百分数"></a>2.1.5 百分数</h4><p>如果width、内边距和外边距设置为百分数值，会应用相同的基本规则；<strong>基本原则是：只使用百分数将无法创建完全灵活的元素布局（即所有的属性都可设置），，除非你不行使用边框；</strong></p>
<h4 id="2-1-6-替换元素"><a href="#2-1-6-替换元素" class="headerlink" title="2.1.6 替换元素"></a>2.1.6 替换元素</h4><p>非替换元素的所有规则适用于替换块元素，只有一个例外：如果width为auto，元素的宽度则是内容的固有宽度；高宽成比例缩放，除非height自己也显式的设置为一个特定值。</p>
<h3 id="2-2-垂直格式化"><a href="#2-2-垂直格式化" class="headerlink" title="2.2 垂直格式化"></a>2.2 垂直格式化</h3><p>一个元素的more高度由其内容决定，还受内容宽度的影响，宽度越小，高度越高；<br>如果块级元素的指定高度大于显示内容所需的高度，多余的高度会产生一个视觉效果—-好像有额外的内边距一样；   此时用户代理的具体行为将取决于overflow属性的值；<br>如果块级元素的指定高度小于显示内容所需的高度，浏览器一般会向元素增加一个滚动条以便查看所有内容；   </p>
<h4 id="2-2-1-垂直属性"><a href="#2-2-1-垂直属性" class="headerlink" title="2.2.1 垂直属性"></a>2.2.1 垂直属性</h4><p>①垂直格式化也有七个相关的属性：margin-top、margin-bottom、padding-top、pading-bottom、border-top、border-bottom和height；这7分属性的值必须等于元素包含块的height，这往往是块级元素父元素的高度的height值（因为块级元素的父元素几乎都会计元素）；<br>②7个属性值3个可以设置为auto：height、margin-top、margin-bottom；其他的必须设置为特定的值，或者默认为0（没声明border-style）,如果已经设置了border-style，边框的宽度会设置为值medium（这个值的定义并不明确）；<br>③如果正常六种的一个块元素的margin-top和margin-bottom设置为auto，它会自动计算为0，但是这样就不能很容易的将正常流元素在其包含块中垂直居中；<br>④height必须设置为auto或者是某种类型的非负值；</p>
<h4 id="2-2-2-百分比高度"><a href="#2-2-2-百分比高度" class="headerlink" title="2.2.2 百分比高度"></a>2.2.2 百分比高度</h4><p>如果没有显式声明包含块的height，百分比会重置为auto；</p>
<h4 id="2-2-3-auto高度"><a href="#2-2-3-auto高度" class="headerlink" title="2.2.3 auto高度"></a>2.2.3 auto高度</h4><p>最简单的情况下，如果块级正常流元素height:auto，显示其高度将恰好足以包含其内联内容（包括文本）的行高；<br>如果块级正常流元素height:auto，且只有块级子元素，默认高度将是最高块级子元素的外边框到最低块级子元素外边框边界之间的距离，此时子元素的外边距会“超出”包含这些子元素的元素；  </p>
<h4 id="2-2-4-合并垂直外边距"><a href="#2-2-4-合并垂直外边距" class="headerlink" title="2.2.4 合并垂直外边距"></a>2.2.4 合并垂直外边距</h4><p>垂直相邻外边距合并，只是用于外边距，而且是同级元素的合并（不知道此话是否正确）</p>
<h4 id="2-2-5-外负边距"><a href="#2-2-5-外负边距" class="headerlink" title="2.2.5 外负边距"></a>2.2.5 外负边距</h4><p>如果垂直外边距都设置为负值，浏览器会 取两个外边距绝对值的最大值；如果一个正外边距与一个负外边距合并，会从正外边距减去这个负外边距的绝对值；</p>
<h3 id="2-3-列表项"><a href="#2-3-列表项" class="headerlink" title="2.3 列表项"></a>2.3 列表项</h3><p>列表项前面通常有一个标志，这个标志不是列表项内容区的一部分；list-style-position可以决定标志放在列表项的内容之外还是列表项的内容开始处；</p>
<h2 id="3-行内元素"><a href="#3-行内元素" class="headerlink" title="3. 行内元素"></a>3. 行内元素</h2><h3 id="3-1-行布局"><a href="#3-1-行布局" class="headerlink" title="3.1 行布局"></a>3.1 行布局</h3><p>单行行内元素和多行行内元素的比较；<br>text-align设置不同的值的时候显示的不同；</p>
<h3 id="3-2-基本术语和概念"><a href="#3-2-基本术语和概念" class="headerlink" title="3.2 基本术语和概念"></a>3.2 基本术语和概念</h3><ul>
<li>匿名文本：指所有未包含在行内元素中的字符串；空格也是匿名文本的一部分；</li>
<li>em框：在字体中定义，也称为字符框；</li>
<li>内容区：在非替换元素中国，内容区可能有两种，一种是元素中各字符的em框串在一起构成的 框，另一种是由元素中字符字形描述的框；在替换元素中，内容区就是元素的固有高度再加上可能有的外边框。边距和内边距；</li>
<li>行间距：是font-size值和line-height值只差，只能用于非替换元素；</li>
<li>行内框：通过想内容区增加行间距来描述；对于非替换元素，元素行内框的高度等于line-height的值；对于替换元素，元素行内框的高度等于内容区的高度；</li>
</ul>
<hr>
<p><img src="http://i.imgur.com/SKGboDx.png" alt=""></p>
<h3 id="3-3-行内格式化"><a href="#3-3-行内格式化" class="headerlink" title="3.3 行内格式化"></a>3.3 行内格式化</h3><p>line-height实际上只影响行内元素和其他行内内容，而不影响块级元素（至少不会直接影响）；为块级元素设置line-height值，但是这个值只是应用到块级元素的内联内容时才会有视觉影响；   </p>
<h3 id="3-4-行内非替换元素"><a href="#3-4-行内非替换元素" class="headerlink" title="3.4 行内非替换元素"></a>3.4 行内非替换元素</h3><ul>
<li>建立框：行内框是有font-size和line-height的差决定的；</li>
<li>垂直对齐：如果改变行内框的垂直对齐，会应用同样的高度确定原则；</li>
<li>管理line-height：避免内容重叠—-①对font-size有改变的元素结合使用em单位；②增加段落的line-height；</li>
<li>缩放行高：设置line-height的最好办法是使用一个原始数字值（即不带单位的值），这个数会成为缩放因子，该因子是一个继承值而非计算值；如果设置line-height的值1.0，那么行高恰好能包含行内容，而没有多余的空间；</li>
<li>增加框属性：行内元素的边界是由font-size控制；内边距、外边距和边框不改变行高，但是会影响文本的显示样式，这样可能会影响行高，比如设置内边距，外边距等，这样会影响整体的行高；</li>
</ul>
<h3 id="3-5-行内替换元素"><a href="#3-5-行内替换元素" class="headerlink" title="3.5 行内替换元素"></a>3.5 行内替换元素</h3><p>一般认为行内替换元素（如图像）有固定的宽度和高度，这可能导致行框比正常要高；这不会改变行中任何元素的line-heitght值，包括替换元素本身，只会让行框的高度恰好包含替换元素（以及所有框属性）；</p>
<ul>
<li>增加框属性：为行内替换元素增加内边距、边框和外边据会增大其行内框，负外边距会是替换元素行内框小于正常大小，可能大致行内替换元素挤入其他行（这个是唯一办法）；</li>
<li>替换元素和基线：默认行内替换元素位于基线上；替换元素没有自己的基线，实际上下外边距边界与基线对齐；</li>
</ul>
<h2 id="4-改变元素显示"><a href="#4-改变元素显示" class="headerlink" title="4. 改变元素显示"></a>4. 改变元素显示</h2><p>使用display元素改变；</p>
<ul>
<li>改变角色：通过使用diaplay的值block和line改变为块元素或者行内元素的角色，但是元素本身不会改变，只是元素的显示方式不同；</li>
<li>行内块元素：line-block是一个混合产物，它会作为替换元素放在行中；它的底端默认地位于文本框的基线上，而且内部没有分割符；<br>在行内块元素内部，会像块级元素一样设置内容的格式，它有属性width和height；</li>
<li>rin-in元素：rin-in可以使某些块级元素成为下一个元素（一个块级行内框）的行内部分；rin-in框是从文档的父元素中继承属性，而不是说它们放在那个元素中就从哪个元素继承属性；<strong>关注一下支持性！！！</strong></li>
<li>计算值：如果元素是浮动元素或定位元素，display的计算值可能改变；</li>
</ul>
<h1 id="八、内边距、边框和外边距"><a href="#八、内边距、边框和外边距" class="headerlink" title="八、内边距、边框和外边距"></a>八、内边距、边框和外边距</h1><h2 id="1-基本元素框"><a href="#1-基本元素框" class="headerlink" title="1. 基本元素框"></a>1. 基本元素框</h2><p>所有文档元素都生成一个矩形框，这称为元素框，它描述了一个元素在文档布局中所占的空间大小；</p>
<ul>
<li>宽度和高度：一个元素width被定义为从左内边距到右内边距的距离，height被定义为从上内边距到下内边距的距离；它们不能应用到行内非替换元素； <strong>宽高如何显示的问题在CSS3中定义了：<a href="http://www.w3school.com.cn/cssref/pr_box-sizing.asp" target="_blank" rel="noopener">CSS3 box-sizing 属性</a></strong>  </li>
<li>外边距和内边距：如果元素有背景，背景会延伸到内边距中，但不会延伸到外边距；</li>
</ul>
<h2 id="2-外边距"><a href="#2-外边距" class="headerlink" title="2. 外边距"></a>2. 外边距</h2><p>最简单的是设置margin，marging默认值为0；实际中，浏览器对外边距提供了预定的样式，所有最好是进行重置样式；</p>
<ul>
<li>长度值和外边距：（margin: top right bottom left;）   </li>
<li>百分数和外边距：<strong>元素的外边距设置为百分数值，百分数值相对于父元素的width计算的（上下边距也是如此）</strong>；</li>
<li>值复制：(margin: top+bottom right+left) (margin:top+right+bottom+left) (margin:top left+right bottom)</li>
<li>单边外边距属性：margin-left、margin-right、margin-top、margin-bottom,可以同时使用多个单边属性 ；</li>
<li>外负边距和合并外边距：设置外负边距会使内容超过父元素的width；正常流中垂直相邻外边距会合并；</li>
<li>外边距和行内元素：①上下外边距应用到行内非替换元素无效；②左右外边距应用到行内非替换元素有效，并且左外边距应用到此行内元素的开始处，右外边距应用到此行内元素的末尾；③如果对行内非替换元素应用负外边距，元素的上下外边距不受影响，行高不受影响，但是左右两端可能与其他内容重叠；④为行内替换元素设置的外边距影响行高，可能使行高增加或减少，这取决于上下外边距的值，行内替换元素左右外边距与非替换元素的左右外边距的作用一样；</li>
</ul>
<h2 id="3-边框"><a href="#3-边框" class="headerlink" title="3. 边框"></a>3. 边框</h2><p>边框宽度默认为medium，此值无明确定义，通常2px；边框默认样式为none；默认的边框颜色是元素本身的前景色，如果没有声明边框颜色，他将与元素的文本颜色相同，如果一个元素无任何背景，那么元素的边框颜色就是父元素的文本颜色；</p>
<ul>
<li>边框和背景：元素的背景是内容、内边距和边框区的背景；</li>
<li>有样式的边框：border-style定义了10个不同的非inherit样式，包括默认值none；样式值hidden等价于none，不过应用于表时除外，对于表，hidden用于解决边框冲突；double属性值不确定显示样式；①多种样式：(border-style:top right bottom left),可以用多个值设置不同的边框；②单边样式：border-top-style、border-right-style、border-bottom-style、border-left-style；单边样式和多种样式结合使用时，一般把border放在前面，单边颜色放在后面；</li>
<li>边框宽度：可以使用border-width、border-top-width、border-left-width、border-bottom-width、border-right-width，可以设置长度值，或者使用三个关键字（宽度比较：thin&lt;medium（默认值）&lt;thick，具体的宽没有定义，用户代理可以自定义）之一；只有当有边框样式时才有边框宽度，因为边框样式默认为none，所有边框样式需要显式定义，当边框样式为none时，边框宽度为0；</li>
<li>边框颜色：border-color、border-top-color、border-right-color、border-bottom-color、border-left-color；边框颜色值transparent，用于创建有宽度但不可见的边框（透明边框）；</li>
<li>简写边框属性：border-bottom、border-top、border-left、border-right，在设置时，具体值的顺序并不重要，还可以省略一些值（不能省略边框样式，如果省略，默认为none），使用其默认值，且每个值只有一个；</li>
<li>全局边框：border设置，应用到所有4个边，如果希望一个元素有不同的边框，则需要使用另外的某个边框属性（可以利用层叠）；</li>
<li>边框和行内元素：对于行内非替换元素，上下边框增加不会影响行高，但是边框会显示出来，左右边框会正常显示；</li>
</ul>
<h2 id="4-内边框"><a href="#4-内边框" class="headerlink" title="4.内边框"></a>4.内边框</h2><p>使用padding定义；默认元素没有内边距；内边框不合并；</p>
<ul>
<li>百分数值和内边距：内边距可以设置百分数值，百分数值相对于其父元素的width计算；</li>
<li>单边内边距：padding-left、padding-right、padding-top、padding-bottom；</li>
<li>内边距和行内元素：左右内边距可见，行高不变，上下内边距也会向元素上面和下面延伸；</li>
<li>内边距和替换元素：不论替换元素是块级元素还是行内元素，内边距都会围绕其内容，背景色将填入该内边距；可以向图片应用内边距；</li>
</ul>
<h1 id="九、颜色和背景"><a href="#九、颜色和背景" class="headerlink" title="九、颜色和背景"></a>九、颜色和背景</h1><h2 id="1-前景色"><a href="#1-前景色" class="headerlink" title="1. 前景色"></a>1. 前景色</h2><p>设置元素的前景色，最简单的办法是利用属性color；<br>通常最好同时设置前景和背景色；   </p>
<ul>
<li>替换属性：最基本的用法，替换body属性text、link、alink和vlink</li>
<li>影响边框：如果未设置边框颜色，前景色会应用到边框；</li>
<li>影响表单元素：可以为表单元素设置color值；</li>
<li>继承颜色：color是可以继承的；</li>
</ul>
<h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><p>元素的背景区包括内容框和内边距，边框画在背景之上；CSS可以使用纯景作为背景，也可以使用图像做背景；<strong>所有的背景属性都不能继承；</strong></p>
<ul>
<li>背景色：background-color，可以是合法颜色，也可以是transparent（默认值）；不能继承；</li>
<li>背景图像：background-image，默认值是none，可以指定一个url值；允许向任何元素应用背景图像，可以是块级元素也可以是行内元素；不能继承；设置背景图像的同时最好再指定一个背景色；</li>
<li>有方向的重复：background-repeat，值repeat-x和repeat-y分别导致图像只是在水平或者垂直方向上重复，no-repeat则不允许在任何方向上平铺；默认的，背景图像将会从一个元素的左上角开始；</li>
<li>背景定位：①background-position，默认值为0% 0%，可以用关键字top、bottom、left、right、center（通常会成对出现，一个对应水平方向，一个对应垂直方向，如果只出现了一个关键字，则认为另一个关键字是center），②可以使用长度值（以图像的左上角为偏移点），③也可以使用百分数值（如果用百分数值设置位置，水平值总是先出现，如果只有一个百分数值，这额值将作为水平值，垂直值假设为50%；）；④根据background-position，将相对于元素的内边距边界放置原图像；⑤允许关键字与其他值混用；⑥如果使用长度值或者百分数值，可以使用负值将原图像拉出元素的背景区；</li>
<li>有方向的重复（深入）：根据background-position的值的不同，平铺的起始位置也是不同的；</li>
<li>关联：background-attachment，声明原图像相对于可视区是固定（fixed）的；默认值scroll，会导致背景随其余文档滚动；</li>
<li>汇总：background，可以从各个其他背景属性取一个值，而且可以采用任何顺序；实际上对background中值的顺序有一个小小的限制—-如果background-position有两个值，它们必须一起出现，而且如果这两个值是长度值或者百分数值，则必须按水平值在前垂直值在后的顺序；如果省略了某些值，就会自动填入相应属性的默认值；background没有必不可少的值，只要至少出现一个值就行；</li>
</ul>
<h1 id="十、浮动和定位"><a href="#十、浮动和定位" class="headerlink" title="十、浮动和定位"></a>十、浮动和定位</h1><h2 id="1-浮动（float）"><a href="#1-浮动（float）" class="headerlink" title="1. 浮动（float）"></a>1. 浮动（float）</h2><h3 id="1-1-浮动元素"><a href="#1-1-浮动元素" class="headerlink" title="1.1 浮动元素"></a>1.1 浮动元素</h3><ul>
<li>会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局；</li>
<li>一个元素浮动时，其他内容会“环绕”该元素；</li>
<li>浮动元素周围的外边距不会合并；</li>
<li>要浮动一个非替换元素，必须为该元素声明一个width，否则，元素的宽度趋于0；</li>
<li>float:none用于防止元素浮动；默认元素为这个值；</li>
</ul>
<h3 id="1-2-浮动的详细内幕"><a href="#1-2-浮动的详细内幕" class="headerlink" title="1.2 浮动的详细内幕"></a>1.2 浮动的详细内幕</h3><ul>
<li>浮动元素的包含块是其最近的块级祖先元素；</li>
<li>浮动元素会生成一个块级框，而不论这个元素本身是什么；</li>
<li>浮动元素的左（或右）外边框不能超过其包含块的左（或右）内边界；</li>
<li>浮动元素的左（或右）外边界必须是源文档中之前出现的左浮动（或右浮动）元素的右（或左）外边界，除非后出现浮动元素的顶端在先出现浮动元素的底端下面；防止元素相互覆盖；</li>
<li>左浮动元素的右外边界不会在其右浮动元素的左外边界的右边；一个右浮动元素的左外边界不会在其左边任何左浮动元素的右外边界的左边；</li>
<li>一个浮动元素的顶端不能比其父元素的内顶端更高；如果一个浮动元素在两个合并外边距之间，放置这个浮动元素就好像在两个元素之间有一个块级父元素；</li>
<li>浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高；</li>
<li>如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高；</li>
<li>左（或右）浮动元素的左边（右边）有另一个浮动元素，前者的右外边界不能在其包含块的右（左）边界的右边（左边）；即浮动元素不能超过其包含元素的边框，除非它太宽，本身都放不下；</li>
<li>浮动元素必须尽可能高地放置；</li>
<li>左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远；</li>
</ul>
<h3 id="1-3-实用行为"><a href="#1-3-实用行为" class="headerlink" title="1.3 实用行为"></a>1.3 实用行为</h3><ul>
<li>浮动元素比父元素高时，会超出其父元素的底端；</li>
<li>浮动元素会延伸，从而包含其所有后代浮动元素；</li>
<li>负外边距可能导致浮动元素移到其父元素的外面；</li>
<li>浮动元素比其父元素更宽时，浮动元素会超出左或右内边界，究竟是超出左内边界还是右内边界，取决于元素以何种方式浮动；</li>
</ul>
<h3 id="1-4-浮动元素、内容和重叠"><a href="#1-4-浮动元素、内容和重叠" class="headerlink" title="1.4 浮动元素、内容和重叠"></a>1.4 浮动元素、内容和重叠</h3><ul>
<li>行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素“之上”显示；</li>
<li>块框与一个浮动元素重叠时，其边框和背景在该浮动元素“之下”显示，而内容在浮动元素之上显示；</li>
</ul>
<h3 id="1-5-清除"><a href="#1-5-清除" class="headerlink" title="1.5 清除"></a>1.5 清除</h3><p>clear，值有left、right、both、none；<br>清除区域：是在元素上外边距之上增加的额外间隔，不允许任何浮动元素进入这个范围之内；这意味着元素设置clear属性时，它的外边距并不改变；</p>
<h2 id="2-定位"><a href="#2-定位" class="headerlink" title="2. 定位"></a>2. 定位</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul>
<li>定位的类型：通过使用position属性，可以选择4种不同类型的定位：static（元素框正常生成）、relative(元素框偏移某个距离)、absolute（元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块）、fixed（元素框的表现类似与将position设置为absolute，不过其包含块是视窗本身）；</li>
<li>包含块：①“根元素”的包含块是由用户代理建立；②对于一个非根元素，如果其position值是relative或static，包含块则由最近的块级框、表单元格或者行内块祖先框的内容边界构成；③对于一个非根元素，如果其position值是absolute，包含块设置为最近的position值不是static的祖先元素（可以是任何类型）；</li>
<li>偏移属性：三种定位机制使用了4个属性来描述定位元素各边相对于其包含块的便宜，它们是：top、left、right、bottom；</li>
</ul>
<h3 id="2-2-宽度和高度"><a href="#2-2-宽度和高度" class="headerlink" title="2.2 宽度和高度"></a>2.2 宽度和高度</h3><ul>
<li>设置宽度和高度：可以直接使用width和height设置，也可以使用top、left、right、bottom来描述4个边的放置位置，使元素的宽度和高度由这些偏移隐含确定；如何设置了外边距、边框或内边距，此时如果为height和width显式指定了值，可能会使定位元素延伸超出其包含块，解决这个问题可以去除height和width声明，或者显式地将其设置为auto；</li>
<li>限制宽度和高度：使用min-width、min-height、max-width、max-height可以限制宽度和高度；</li>
</ul>
<h3 id="2-3-内容溢出和剪裁"><a href="#2-3-内容溢出和剪裁" class="headerlink" title="2.3 内容溢出和剪裁"></a>2.3 内容溢出和剪裁</h3><ul>
<li>溢出：利用overflow属性控制溢出问题，属性值包含visible（元素的内容在元素框之外也可见）、scroll（元素的内容会在元素框的边界处剪裁，不过始终提供某种滚动机制使额外的内容能够看到）、hidden（元素的内容会在元素框的边界处剪裁，不过不会提供滚动接口使用户访问超出剪裁区域的内容）、auto（允许用户代理来确定采用何种行为，一般解释为“只有必要时提供滚动条”）；</li>
<li>内容剪裁：属性clip可以改变剪裁区域的形状，auto（表示元素的内容不应剪裁）、rect(top,right,bottom,left)（剪裁为一个矩形框，4个值不是边偏移，而是距元素左上角的距离；如果一个剪裁矩形涵盖元素左上角20*20px的一个正方形，可以用rect(0,20px,20px,0)表示；4个值只允许长度值和auto，auto相当于将剪裁边界设置为适当的内容边界）；</li>
</ul>
<h3 id="2-4-元素可见性"><a href="#2-4-元素可见性" class="headerlink" title="2.4 元素可见性"></a>2.4 元素可见性</h3><p>使用visibility控制真个元素的可见性，visible（可见）、hidden（不可见，但是会占据位置，影响布局）、collapse(对于非表元素，collapse与hidden含义相同)；</p>
<h3 id="2-5-绝对定位"><a href="#2-5-绝对定位" class="headerlink" title="2.5 绝对定位"></a>2.5 绝对定位</h3><ul>
<li>包含块和绝对定位元素：①绝对定位元素额包含块是最近的position值不为static的祖先元素；②通常会选择一个元素作为绝对定位元素的包含块，将其position指定为relative而且没有偏移；③可能需要给body元素为其所有的后代建立一个包含块，而不是让用户代理选择初始包含块；④元素绝对定位时，还会为其后代元素建立一个包含块；⑤如果文档可滚动，定位元素会随着它滚动（绝对定位元素是固定定位元素的后代除外）；</li>
<li>绝对定位元素的放置和大小：①如果绝对定位元素设置top、right、bottom、left，不设置宽高，那么宽高会根据四个偏移属性来定位大小；②如果四个偏移属性和宽高同时设置了，那么其中的值可能是错误的，相应的错误值会被忽略掉；③到底哪个值是错误的，取决于很多因素，而且根据元素是否是替换元素有所不同；</li>
<li>自动边偏移：①元素绝对定位时，left设置为auto，元素的左边界会相对于其包含块的左边界放置（假设其包含块是初始包含块）；②对于top，定位元素的顶端要相对于其未定位前本来的顶端位置对齐（换句话说，元素的position值为static时，处于的静态位置就是其顶边应在的位置）；</li>
<li>非替换元素的放置和大小：①一般元素的大小和位置取决于其包含块；②如果left、width和right都设置为auto，左边界置于其静态位置（假设使用从左到右的语言）；③元素的width设置为“收放得正好合适”，说明该元素的内容区宽带恰好只能包含其内容（而没有多余空间）；④非静态位置属性（从左到右的语言是right）要适当设置，以保证余下 的距离；⑤如果左右外边距都设置为auto，而left、width和right不是auto，此时左右外边距会设置为相等的值，实际上让元素居中；如果外边距不为auto，用户代理会忽略right的值（从左到右的语言中），并重置right的值；⑥如果左外边距为auto，则会重置左外边距；⑦一般地，如果只有一个属性设置为auto，就会修改这个属性来满足下面的等式<code>left+margin-left+border-left-width+padding-left+width+padding-right+border-right-width+margin-right+right=包含块的width</code>；⑧如果只是把width设置为auto，left、right，margin-left和margin-right不为auto，元素会延伸到必要的宽度，而不是“收缩”内容；⑨对于垂直轴，规则和水平轴非常类似；</li>
<li>替换元素的放置和大小：①替换元素有固定的高度和宽度，其大小不会改变，因此在替换元素定位中没有“恰当收放”行为的概念；②如果width设置为auto，则width的实际使用值由元素内容的固有宽度决定；如果显式声明了width，则width设置为该值；③从左到右的语言中，如果left值为auto，要把auto设置为静态位置；从右向左的语言中，则吧right的auto值替换为静态位置；④如果left或right仍为auto，则将margin-left或margin-right的auto值替换为0；⑤如果此时margin-left和margin-right都还定义为auto，则把它们设置为相等的值，从而将元素在其包含块中居中；⑥在此之后，如果只剩下一个auto，则将其修改为等于等式的余下部分；⑦与非替换元素一样，如果值过度受限，用户代理会忽略right的值；⑧垂直轴的布局与水平轴的规则类似；</li>
<li>Z轴上的放置：①利用z-index，可以改变元素相互覆盖的顺序，z-index的值越大，层次越靠前，离读者越近；②所有整数都可以作为z-index的值，包括负数，负数层次更靠后，离读者更远；③没有特别要求z-index值是连续的;④为一个元素指定了z-index值（不是auto），该元素就会建立自己的局部叠放上下文（该元素位于此上下文z轴的0位置），这意味着元素的所有后代相对于该祖先元素都有其自己的叠放顺序；⑤如果元素设置为z-index:auto，可以将其处理为z-index:0；</li>
</ul>
<h3 id="2-6-固定定位"><a href="#2-6-固定定位" class="headerlink" title="2.6 固定定位"></a>2.6 固定定位</h3><ul>
<li>固定定位的包含块是视窗，元素完全从文档流中去除；</li>
<li>可以使用固定定位创建帧式界面，也可以在屏幕上放置一个“永久性”元素；</li>
</ul>
<h3 id="2-7-相对定位"><a href="#2-7-相对定位" class="headerlink" title="2.7 相对定位"></a>2.7 相对定位</h3><ul>
<li>通过使用偏移属性移动定位元素；</li>
<li>元素相对定位时，会从其正常位置移走，不过原来占据的空间不会消失；</li>
<li>如果相对定位一个元素，它会立即为其所有子元素建立一个新的包含块；这个包含块相对于该元素原本所在的位置；</li>
<li>如果遇到过度受限的相对定位，一个值会重置为另一个值得相反数，right总是等于-left（从左到右的语言中），bottom总是等于-top；</li>
</ul>
<h1 id="十一、表布局"><a href="#十一、表布局" class="headerlink" title="十一、表布局"></a>十一、表布局</h1><h2 id="1-表格式化"><a href="#1-表格式化" class="headerlink" title="1. 表格式化"></a>1. 表格式化</h2><h3 id="1-1-表的视觉编排"><a href="#1-1-表的视觉编排" class="headerlink" title="1.1 表的视觉编排"></a>1.1 表的视觉编排</h3><ul>
<li>在CSS中，内部表元素生成矩形框，这些框有内容、内边距和边框，但是没有外边距（设置外边距会被忽略，只有总标题例外）；</li>
<li>表编排规则：表格单元是矩形，不过不必都是相同的大小；给定表格列中的所有表格单元宽度相等，一个表格行中的所有表格单元则高度相等；不同表格行的高度可能不相等；</li>
</ul>
<h3 id="1-2-表显示值"><a href="#1-2-表显示值" class="headerlink" title="1.2 表显示值"></a>1.2 表显示值</h3><ul>
<li>在XML中无法从根本上知道哪些元素可能是表的一部分，所有引入了一组display值（在html代码中也可以使用），与表有关的值由table（指定一个元素定义了一个块级表，相当于html元素的table）、inline-table（指定一个元素定义了一个行内级表，与inline-block类似）、table-row（指定一个元素是一个单元格的行，相当于html元素的tr）、table-row-group（指定一个元素是一个或多个行的组，相当于html元素的tbody）、table-header-group（标题行，可以是多行的标题行组，相当于html元素的thead）、table-footer-group（脚注行，可以是多行的脚注行组，相当于html元素的tfoot）、table-column（指定一个元素是一个单元格的列，相当于html元素的col元素）、table-column-group（声明一个元素是一个或多个列的组，相当于html元素的colgroup元素）、table-cell（指定一个元素是表中的单个单元格，相当于html元素的th或td）和table-caption（定义一个表的总标题，建议只有一个）；</li>
<li>以行为主：css将其表模型定义为“以行为主”；</li>
<li>列：在css中列和列组只能接受4种样式border（只有当border-collapse属性值为collapse时才能为列和列组设置边框）、background（只有当单元格及其行有透明背景时，列或列组的背景才可见）、width（定义了列或列组的最小宽度）和visibility（如果一个列或列组的visibility为collapse，则该列或列组中所有单元格都不显示；如果为非collapse值，则会被忽略）；</li>
</ul>
<h3 id="1-3-匿名表对象"><a href="#1-3-匿名表对象" class="headerlink" title="1.3 匿名表对象"></a>1.3 匿名表对象</h3><ul>
<li>可能未包含足够的元素，css为此定义了一种机制，可以将“遗漏的”组件作为匿名对象插入；</li>
<li>插入对象规则：①一个table-cell元素的父元素不是table-row元素，则会在该元素及其父元素直接插入一个匿名table-row对象，所插入的这个对象将包含该table-cell元素的所有连续兄弟；②一个table-row元素的父元素不是table、inline-table或table-row-group元素，则会在该元素及其父元素之间插入一个匿名的table元素，所插入的这个对象将包含该table-row元素的所有连续兄弟；③一个table-column元素的父元素不是table、inline-table或table-row-group元素，则会在该元素及其父元素之间插入一个匿名的table元素;④一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名的table元素；⑤一个table或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素，则在该table元素与其子元素之间插入一个匿名的table-row对象；这个匿名对象将包含该子元素的所有不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的连续兄弟；⑥一个table-row-group、table-header-group、table-footer-group元素的子元素不是table-row元素，则在该元素及其子元素之间插入一个匿名table-row对象，这个匿名对象包含该子元素的所有本身非table-row对象的连续兄弟；⑦一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell对象，这个匿名对象包含该子元素的所有本身非table-cell元素的连续兄弟；</li>
</ul>
<h3 id="1-4-表层"><a href="#1-4-表层" class="headerlink" title="1.4 表层"></a>1.4 表层</h3><p>为了完成表的显示，css定义了6个不同的“层”，可以分别放表的不同方面，如下图所示：<img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/table.png" alt="table"><br>基本上，对应表各个方面的样式都在其各自的层上绘制；顶层对应表单元格，将最后绘制；列样式在行样式的下面，所以行背景会覆盖列背景；默认的，所有元素背景都是透明的；</p>
<h3 id="1-5-表标题"><a href="#1-5-表标题" class="headerlink" title="1.5 表标题"></a>1.5 表标题</h3><ul>
<li>利用属性caption-side，可以把标题内容放在table之上，也可以放在table之下，而不论该表标题出现在表结构中的哪个位置（在HTML中，captain元素只能出现在开始table元素的后面）；</li>
<li>表标题格式化好像它直接放在表框之前（或之后）的一个块框，有两点不同：一是表标题仍能从表y继承值，二是用户代理在考虑如何处理表前面的run-in元素时会忽略表标题框；</li>
<li>captain-side的值有top（默认值）和bottom，应用于display值为table-caption的元素；</li>
</ul>
<h2 id="2-表单元格边框"><a href="#2-表单元格边框" class="headerlink" title="2. 表单元格边框"></a>2. 表单元格边框</h2><ul>
<li>border-collapse：collapse（采用合并边框模型）、separate（默认，采用分隔边框模型）、inherit，应用于display值为table或inline-table的元素；</li>
</ul>
<h3 id="2-1-分隔单元格边框"><a href="#2-1-分隔单元格边框" class="headerlink" title="2.1 分隔单元格边框"></a>2.1 分隔单元格边框</h3><ul>
<li>采用这种模型，表中的每个单元格与其他单元格分开一定距离，而且单元格的边框彼此不会合并；</li>
<li>在分隔边框模型中，不能为行、行组、列和列组设置边框；如果这些元素声明了边框属性，都会被CSS兼容的用户代理所忽略；</li>
<li>边框间距border-spacing:length、inherit,默认值为0；应用于display值为table或inline-table的元素，会应用于表本身，而不是单个的单元格；除非border-collapse值为separate，否则会忽略该属性；可以为这个属性指定一个或两个长度值，如果一个值代表上下左右都是这个值，如果两个值，第一个代表水平间隔，第二个代表垂直间隔；表外围的单元格边框与表元素本身的内边距之间也可以指定间隔值；</li>
<li>处理空单元格empty-cells:<br>  show（默认，会画出空单元格的边框和背景，就好像这些表单元格有内容一样）、hide（不会画出该单元格的任何部分，就好像这个单元格被设置为visibility:hidden）、inherit；应用于display值为table-cell的元素；除非border-collapse值为separate，否则会忽略该属性；<br>  如果一个单元格包含内容（“内容”不仅包含文本、图像、表单元等，还包含&nbsp;和除CR(回车)、LF(换行)、tab和空格符以外的所有其他空白符），则不能认为是空的；<br>  如果一行中所有单元格都为空，而且empty-cells值都是hide，则整行将处理为好像这个行元素设置为display:none；</li>
</ul>
<h3 id="2-2-合并单元格边框"><a href="#2-2-合并单元格边框" class="headerlink" title="2.2 合并单元格边框"></a>2.2 合并单元格边框</h3><p>合并单元格边框和分隔单元格边框的区别<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E8%BE%B9%E6%A1%86.png" alt="合并单元格边框和分隔单元格边框的区别"></p>
<ul>
<li>合并边框布局：<code>row width = (0.5*width0)+padding-left1+width1+padding-right1+border-width1+padding-left2+...+padding-rightn+(0.5*border-widthn)</code>;如果边框的宽度是一个奇数，用户代理将采用合适的方式绝对边框在表格线上显示；</li>
<li>边框合并：<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E8%BE%B9%E6%A1%86%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99.png" alt="边框合并规则"></li>
</ul>
<h2 id="3-表大小"><a href="#3-表大小" class="headerlink" title="3. 表大小"></a>3. 表大小</h2><h3 id="3-1-宽度"><a href="#3-1-宽度" class="headerlink" title="3.1 宽度"></a>3.1 宽度</h3><ul>
<li>确定表的宽度，有两种不同的方法：固定宽度布局和自动宽度布局；无论使用何种宽度算法，高度都是自动计算；两者之间最显著的差异是速度，使用固定宽度表布局时，相对于自动宽度模型，用户代理可以更快地计算出表的布局；</li>
<li>table-layout:auto(默认)、fixed、inherit,应用于display值为table或inline-table的元素；</li>
<li>固定宽度：这种方法的所有列宽度都是由表的第一行定义，非首行的单元格指定的width值都会被忽略；如果一个单元格的内容放不下，该单元格的overflow值将决定单元格内容是剪裁、可见还是生成一个滚动条；<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%9B%BA%E5%AE%9A%E5%B8%83%E5%B1%80.png" alt="固定宽度"></li>
<li>自动布局：在用户代理查看完表的所有内容之前无法确定表的布局（即自动布局要求用户代理每得到一个新单元格时都是完成整个表的布局）；<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%801.png" alt="自动布局1"><br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%802.png" alt="自动布局2"></li>
</ul>
<h3 id="3-2-高度"><a href="#3-2-高度" class="headerlink" title="3.2 高度"></a>3.2 高度</h3><ul>
<li>直接由height属性显示设置高度，代表最小高度；</li>
<li>如果表的高度是auto，其高度则是表中所有行的行高加上所有边框和单元格间隔的综合；</li>
<li>表的高度计算很大程度上留给用户代理来决定，要尽可能避免设置高度；</li>
</ul>
<h3 id="3-3-对齐"><a href="#3-3-对齐" class="headerlink" title="3.3 对齐"></a>3.3 对齐</h3><ul>
<li>水平对齐使用text-align属性；</li>
<li>垂直对齐（很容易影响行高）使用vertical-align属性：①top，单元格内容顶端与其行顶端对齐；对于跨行单元格，单元格内容的顶端与其所跨的第一行的顶端对齐；②bottom，单元格内容底端与其行底端对齐；对于跨行单元格，单元格内容的底端与其所跨的最后一行的底端对齐；③单元格内容的中间与其行中间对齐；对于跨行单元格，单元格内容的中间与其所跨行的中间对齐；④baseline，单元格的基线与其行的基线对齐；对于跨行单元格，该单元格的基线与所跨的第一行的基线对齐；</li>
</ul>
<h1 id="十二、列表与生成内容"><a href="#十二、列表与生成内容" class="headerlink" title="十二、列表与生成内容"></a>十二、列表与生成内容</h1><p>CSS允许创作人员定义自己的计数模式和格式，而且可以将这些计数器与任何元素关联，而不只是有序列表；</p>
<h2 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h2><h3 id="1-1-列表类型"><a href="#1-1-列表类型" class="headerlink" title="1.1 列表类型"></a>1.1 列表类型</h3><p>list-style-type: disc(默认) | circle | square | decimal | decimal-leading-zero | upper-alpha | upper-latin | lower-alpha | lower-lation | upper-roman | lower-roman | lower-greek | armenian | georgian | none,应用于display值为list-item的元素</p>
<h2 id="2-生成内容"><a href="#2-生成内容" class="headerlink" title="2. 生成内容"></a>2. 生成内容</h2><p>CSS2和CSS2.1包含一个称为生成内容的新特性。这是指由浏览器创建的内容，而不是由标志或内容来表示。<br>列表标志就是生成内容。</p>
<h3 id="2-1-插入生成内容"><a href="#2-1-插入生成内容" class="headerlink" title="2.1 插入生成内容"></a>2.1 插入生成内容</h3><p>为了向文档中插入生成内容，可以使用:before和:after伪元素。这些伪元素会根据content属性把生成内容放在一个元素内容的前面或后面。如<code>a[href]:before{content:&quot;(link)&quot;;}</code><br>生成内容会放在元素的内部，所以元素的边框会包围生成内容；在CSS2.1中，除了列表标志，无法把生成内容放在元素框之外；     </p>
<ul>
<li>CSS2和CSS2.1中明确地进制浮点或定位:before和:after内容，还禁止使用列表样式属性以及表属性；     </li>
<li>如果:before和:after选择器的主体是块级元素，则display属性只接受值none、inline、block和marker。其他值都处理为block；     </li>
<li>如果:before和:after选择器的主体是一个行内元素，属性display只能接受值none和inline。所以其他值都处理为inline。    </li>
</ul>
<p>生成内容有一个很有意思的方面，它由与之关联的元素继承值（比如color的继承）；当然，这种继承值只适用于可继承的属性；</p>
<h3 id="2-2-指定内容"><a href="#2-2-指定内容" class="headerlink" title="2.2 指定内容"></a>2.2 指定内容</h3><p>要生成内容，需要利用content属性来描述生成的内容<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E6%8C%87%E5%AE%9A%E5%86%85%E5%AE%B9.png" alt="指定内容"><br><strong>string：</strong><br>①串值会原样显示，即使其中包含某种标记也不例外。如<code>h1:before{content:&quot;&lt;em&gt;&amp;para;&lt;/em&gt;;color:gray;&quot;}</code>会直接把em标签原样显示；<br>②如果要生成一个换行（回车），不能直接使用<code>&lt;br&gt;</code>，而要使用串<code>\A</code>，这是CSS表示换行的方法；如果一个长串，需要分成多行则用<code>\</code>符号转义;还可以使用转义来指示十六进制Unicode值，如<code>\00AB</code>；     </p>
<p><strong>uri：</strong><br>利用URI值，只需要指向一个外部资源（如图像、视频，音频或用户代理支持的其他任何资源），然后插入到文档中适当的位置；如果用户代理出于某种原因不支持所指定的资源，此时要求用户代理完全忽略这个资源，不插入任何内容（如无法识别SVG的浏览器插入SVG图像）；     </p>
<p><strong>attr(\&lt;identifier>)（插入属性值）：</strong><br>获取一个元素的属性值，使之作为文档显示的一部分，如<code>a[href]:after{content:&quot; [&quot; attr(href) &quot;]&quot;;}</code>,前面的示例增加串值的原因是为了使生成内容与具体内容不冲突，可选的；<br>所有属性值都可以作为生成内容插入：alt文本、class或id值 ，以及任何属性；如果一个属性不存在，会在相应位置插入一个空串；<br>CSS2.x定义属性引用的返回值是未解析的串；因此，如果一个属性的值包含标记或字符实体，会原样显示；     </p>
<p><strong>生成引号：</strong><br>生成内容有一种特殊形式，即引号，CSS2.x提供了一种有效的方式来管理引号及其嵌套行为；由于提供了open-quote等成对的content值以及属性quotes，使得生成引号的管理称为可能；<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E7%94%9F%E6%88%90%E5%BC%95%E5%8F%B7.png" alt="生成引号"><br>除了关键字none和inherit外，唯一合法的值是一对或多对串；在一对串中，前一个串定义了开始引号（open-quote），第二个串定义了结束引号；<br>串本身是引号时，也可以用引号将其包围；双引号可以由单引号包围，反之亦然；如<code>quotes: &#39;&quot;&#39; &quot;&#39;&quot;</code>；<br>值open-quote和close-quote用于插入合适的引号符号（不同语言有不同的引号）；它们使用quotes值来确定如何工作；<br>如果想使用“弯引号”而不是普通的直引号，quote规则要写作：<code>quote{quotes: &#39;\201C&#39; &#39;\201D&#39;;}</code>；<br>利用quotes，只要愿意，可以定义任意多层嵌套引用模式；<br>如果引号的嵌套层次大于已定义的引号对数，最后一对引号将重用于更深层次的嵌套；<br>如果有多段引用文本，通常会忽略每一段的结束引号，而只显示开始引号，只是最后一段例外，可以使用no-close-quote值达到这个效果；如果想为最后一段增加一个结束引号，需要为最后一段指定类，并为其:after内容声明一个close-quote；<br>开始一个引用层次时，所有元素都有相同的嵌套层次，知道遇到一个close-quote，此时引用嵌套层次减1；no-open-quote关键字会让引用嵌套层次增1，但不生成符号，其效果与no-close-quote对称；     </p>
<p><strong>计数器：</strong><br>CSS2没有满足于只是提供HTML中的简单计数，它增加了两个属性和两个content值，从而可以定义几乎所有计数格式，包括采用多种样式的小节计数器；<br>创建计数器的基础包括两个方面，一是能设置计数器的起点（counter-reset），二是能将其递增一定的量（counter-increment）；<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/counter-reset.png" alt="counter-reset">      </p>
<ul>
<li>计数器标识符只是创作人员创建的一个标签，可以随便命名；</li>
<li>只要重置（或递增）标识符，就足以使之建立；</li>
<li>默认地，计数器重置为0；</li>
<li>如果重置为另一个数，可以在标识符后面声明这个数；</li>
<li>可以在标识符-整数对中一次重置多个标识符，如果少了一个整数，则默认为0；</li>
<li>计数器的值允许是负值；<br><code>h1{counter-reset: chapter 4 section -1 subsec figure 1;}</code>      </li>
</ul>
<p><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/counter-increment.png" alt="counter-increment"><br>counter-increment接受标识符-整数对，其中整数部分可以是0，也可以是负数或正数；如果它的标识符-整数对少了一个整数，则默认为1而不是0；     </p>
<ul>
<li>要具体显示计数器，还需要结合使用content属性和一个与计数器有关的值；     </li>
<li>任何元素都可以利用计数器；    </li>
<li>计数器由同一个元素递增和使用时，递增发生在计数器显示之前；类似的，如果计数器在同一个元素中重置和显示，重置也在计数器显示发生之前。     </li>
<li>如果希望一个递增计数器第一次显示0，只需将该计数器重置为-1；     </li>
<li>可以利用规则改写BASIC程序清单的传统格式；    </li>
<li>可以为每个计数器定义一个列表样式，作为counter()格式的一部分；    </li>
<li>没有为计数器**指定样式关键字，它默认为decimal计数样式；如果愿意，甚至可以将计数器设置为使用样式disc、circle、square和none；     </li>
<li>即使规则看上去会让计数器递增，但实际上display为none的元素并不会递增计数器；相反，visibility为hidden的元素确实会递增计数器；     </li>
</ul>
<p>把多个计数器串在一起创建一种多级计数；为了达到很深的嵌套层次，需要创建足够多的计数器，这种做法很快会变得相对笨拙；<br>CSS2.x描述了计数器的作用域概念：每层嵌套都会为给定计数器创建一个新的作用域；<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以常规HTML方式实现嵌套表计数：*/</span></span><br><span class="line"><span class="selector-tag">ol</span>&#123;<span class="attribute">counter-reset</span>:ordered;&#125;</span><br><span class="line"><span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;<span class="attribute">counter-increment</span>:ordered; <span class="attribute">content</span>:<span class="built_in">counter</span>(ordered) <span class="string">". "</span>;&#125;</span><br><span class="line"><span class="comment">/*这些规则会使有序列表（甚至嵌套在其他列表中的有序列表）从1开始计数，并且逐项增1，这正是HTML一直以来的做法。*/</span></span><br></pre></td></tr></table></figure></p>
<p>如果希望有序列表这样（如：1、1.1、1.2、1.2.1、1.2.2、1.3、2.1等）计数，使每层嵌套都创建一个新计数器追加到老计数器上，可以用counters()实现；<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span>&#123;<span class="attribute">counter-reset</span>:ordered;&#125;</span><br><span class="line"><span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;<span class="attribute">counter-increment</span>:ordered; <span class="attribute">content</span>:<span class="built_in">counters</span>(ordered) <span class="string">". "</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="十三、用户界面样式"><a href="#十三、用户界面样式" class="headerlink" title="十三、用户界面样式"></a>十三、用户界面样式</h1><h2 id="1-系统字体和颜色"><a href="#1-系统字体和颜色" class="headerlink" title="1. 系统字体和颜色"></a>1. 系统字体和颜色</h2><h3 id="1-1-系统字体"><a href="#1-1-系统字体" class="headerlink" title="1.1 系统字体"></a>1.1 系统字体</h3><p>CSS2定义了6个系统字体关键字：     </p>
<ul>
<li>caption：由标题控件使用的字体样式，如按钮和下拉控件；</li>
<li>icon：操作系统图标标签所用的字体样式，如硬盘驱动器、文件夹和图标文件；</li>
<li>menu：下拉菜单和菜单列表中文本使用的字体样式；</li>
<li>message-box：对话框中文本使用的字体样式；</li>
<li>small-caption：由标题小控件的标签使用的字体样式；</li>
<li>status-bar：窗口状态条中文本使用的字体样式； </li>
</ul>
<p>这些值只能用于font属性，它们本身就是简写形式；<br>如果用户代理想要“抽取”计算环境中显示每种元素所用的字体系列，就绝对能保证这种字体对浏览器一定可用；如果所需的系统字体样式不可用或者无法确定，用户代理可用在一组近似的字体样式中猜测；如果无法做出这种的猜测，用户代理就应当使用一种“用户代理默认字体”；</p>
<h3 id="1-2-系统颜色"><a href="#1-2-系统颜色" class="headerlink" title="1.2 系统颜色"></a>1.2 系统颜色</h3><p>CSS3颜色模块废弃了系统颜色关键字，而增加了新的属性appearance；强烈建议不要使用系统颜色；只在CSS2中使用，CSS2.1中也废弃了这些关键字；<br>总共有28个系统关键字，不过CSS没有明确地定义这些关键字；相反，对各个关键字的含义只有一些概况（而且非常简短）的描述；<br>CSS2将系统颜色关键字定义为不区分大小写，不过建议使用混合大小写写法，这样颜色名更可读；<br>系统颜色关键字本质上是含糊的，这是一个明显的缺点，不同的用户代理可能以不同的方式解析这些关键字，即使这些用户代理在同一个操作系统上运行；因此，在使用这些关键字时，不要指望肯定会有一致的结果；</p>
<h2 id="2-光标"><a href="#2-光标" class="headerlink" title="2. 光标"></a>2. 光标</h2><p>光标（在CSS规范中称为“指示设备”）,它有鼠标、写字板、图形书写板甚至光学读取系统之类的设备控制；在大多数Web浏览器中，光标对于提供交互反馈很有用；<br>CSS2允许改变光标图片，这说明创建一个类似于操作系统中桌面应用的Web应用会容易得多；这是通过cursor属性完成的：<br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/cursor.png" alt="cursor"><br>默认值auto只表示用户代理应当确定最适合当前上下文的光标图标；这与default不同，后者要求图标是操作系统的默认光标；默认光标通常是一个箭头，不过也不一定，这取决于当前的计算环境；</p>
<hr>
<p><strong>指示和选择光标：</strong><br>值pointer会把光标图标改为与移过超链接时的光标相同；利用cursor，可以将任何元素定义为像链接一样改变光标图标；这可能会让用户糊涂，所以建议不要经常这么做；另一方面，利用cursor可以更容易地利用非链接元素创建交互式、脚本驱动的屏幕部件，然后适当地改变图标；<br>Web浏览领域中另一个很常见的光标图标是text图标，只要用户能选择文本，就会出现这个图标；这往往是一个“I”光标，作为一个视觉提示，指示用户可以拖拽-选择光标下的内容；<br>指示交互性的另一个办法是使用值crosshair，它会把光标图标变成一个十字符号，这往往是一对彼此呈直角交叉放置的短信，其中一条垂直，另一条水平，看上去就像一个加号（+）；它也可以类似于称号（或小写的“x”），甚至是手枪瞄准镜内显示的准星图标；十字符号通常用于屏幕捕捉程序，入股用户想准确地知道正在点击哪一个像素，这就很有用；</p>
<hr>
<p><strong>移动光标：</strong><br>创作人员需要指示一个屏幕元素可以移动时就会使用move，它通常显示为一个加粗的十字线，线的两端分别有箭头；也可以显示为一个“拳头”，用户点击并按下鼠标按钮时图标中的“手指”是弯曲的；<br>一些与move相关的cursor值：e-resize、ne-resize等；Windows和大多数图形化Unix-shell用户会把这些值识别为鼠标光标放在窗口一边或角落时出现的图标； </p>
<hr>
<p><strong>等待和前进：</strong><br>wait和progress都指示程序正在忙；它们并不相同：wait表示用户要等待知道程序不忙为止，而progress指示用户完全可以继续与程序交互，尽管它很忙；在大多数操作系统中，wait可能显示为一块表（可能有旋转的指针）或者显示为一个沙漏（可能在自己倒来倒去）；progress通常表示为一个旋转的“沙滩球”，或者是一个箭头，而且在这个箭头的一旁有一个小沙漏； </p>
<hr>
<p><strong>提供帮助：</strong><br>指示用户得到某种形式的帮助，用值help；help有两种常见的表现方式，可能是一个问号；也可能是一个箭头，箭头旁边有一个小问号；如果已经确认某些链接指向更多信息，或者这些链接指向的信息有助于用户更好地理解网页，help就很有用；</p>
<hr>
<p><strong>图形光标：</strong>        </p>
<ul>
<li>使用一个URL值可以指定定制光标，如<code>a{cursor:url{globe.cur},pointer;}</code>；</li>
<li>在cursor语法定义中，URL必须跟有一个由逗号和某个通用关键字；</li>
<li>用户代理必须支持URL里所用的文本格式，如果用户代理不支持这种格式，就会转而使用后面跟着的通用关键字；</li>
<li>对于可能采用的任何图形光标，cursor都要求有后路；</li>
<li>作为后路的关键字之前可以指定多个光标文件；</li>
<li>如果用户代理支持动画图形文件来替换光标，就可以实现动画光标；</li>
</ul>
<h2 id="3-轮廓"><a href="#3-轮廓" class="headerlink" title="3. 轮廓"></a>3. 轮廓</h2><p>轮廓有点类似于边框，不过二者有两个重要的区别：首先，轮廓不像边框那样参与到文档流中，因此轮廓出现或消失时不会影响文档流，即不会导致文档的重新显示，但是轮廓可能会覆盖其他元素；其次，轮廓可能不是矩形，这意味着行内元素的轮廓可能不同于该元素的边框，利用轮廓，用户代理可以“合并”部分轮廓，创建一个连续但非矩形的形状；<br>用户代理不一定需要支持非矩形轮廓；它们可能会像处理边框一样设置行内非替换元素的轮廓格式；不过，兼容用户代理必须确保轮廓不能占据布局空间；<br>轮廓和边框还有一个根本的差异：它们不是同一种东西，所以可以在同一个元素上共存；<br>轮廓画在边框的外面（非强制，但是约定成俗）；<br>一般认为轮廓是用户界面的一部分，这是因为它们最常用于指定当前焦点；如果一个用户使用键盘导航从一个链接跳到另一个链接，那么当前有焦点的链接往往会有一个轮廓；</p>
<h3 id="3-1-设置轮廓样式"><a href="#3-1-设置轮廓样式" class="headerlink" title="3.1 设置轮廓样式"></a>3.1 设置轮廓样式</h3><p>轮廓最基本的方面就是样式，利用outline-style设置；<br>| | |<br>| ————- | —– |<br>| 值 | none、dotted、dashed、solid、double、groove、ridge、inset、outset、inherit |<br>| 初始值： | none |<br>| 应用于： | 所有元素 |<br>| 继承性： | 无 |<br>| 计算值： | 根据指定确定 |<br>轮廓与边框样式的值相比，少了一个关键字hidden；只能为一个outline-style值指定一个关键字（而边框可以指定最多4个关键字）；实际效果是一个元素周围必然有相同的轮廓样式，而不论轮廓是否是矩形；</p>
<h3 id="3-2-设置轮廓宽度"><a href="#3-2-设置轮廓宽度" class="headerlink" title="3.2 设置轮廓宽度"></a>3.2 设置轮廓宽度</h3><p>可以用outline-width定义轮廓的宽度；<br>| | |<br>| ————- | —– |<br>| 值 | thin、medium、thick、\&lt;length>、inherit |<br>| 初始值： | medium |<br>| 应用于： | 所有元素 |<br>| 继承性： | 无 |<br>| 计算值： | 绝对长度；如果轮廓的样式是none或hidden，则为0 |<br>outline-width与border-width直接唯一真正的区别是整个轮廓只能声明一个宽度（类似于轮廓样式）；一个值只允许有一个关键字；</p>
<h3 id="3-3-设置轮廓颜色"><a href="#3-3-设置轮廓颜色" class="headerlink" title="3.3 设置轮廓颜色"></a>3.3 设置轮廓颜色</h3><p>可以用outline-color定义轮廓的颜色；<br>| | |<br>| ————- | —– |<br>| 值 | invert、\&lt;color>、inherit |<br>| 初始值： | invert（或用户代理特定的值；） |<br>| 应用于： | 所有元素 |<br>| 继承性： | 无 |<br>| 计算值： | 根据指定确定 |<br>边框与轮廓之间最有意思的差别就出现在这里：轮廓颜色有关键字invert，而且这是默认值；反色轮廓意味着要对轮廓所在的像素完成反色转换，这个过程可以确保无论轮廓后面是什么都将可见；如果一个用户代理出于某种原因无法支持反色转换，则会使用元素的color计算值；<br>如果想为轮廓定义一种特定的颜色，只需使用任何合法的颜色值；这里可能存在一个缺点，轮廓颜色有可能与其周围额像素颜色很接近，这种情况下用户将无法看清，正是如此才定义了invert；<br>类似于轮廓样式和宽度，对整个轮廓只能定义一种颜色；</p>
<h3 id="3-3-设置轮廓颜色-1"><a href="#3-3-设置轮廓颜色-1" class="headerlink" title="3.3 设置轮廓颜色"></a>3.3 设置轮廓颜色</h3><p>类似于border属性，轮廓也有一个简写属性outline，允许一次就完成轮廓样式、宽度和颜色的设置；<br>| | |<br>| ————- | —– |<br>| 值 | \&lt;outline-color> \&lt;outline-style> \&lt;outline-width>、inherit |<br>| 初始值： | 对简写属性未定义 |<br>| 应用于： | 所有元素 |<br>| 继承性： | 无 |<br>| 计算值： | 见各个属性（outline-color）等等 |<br>由于给定轮廓必须采用某种统一的样式、宽度和颜色，所以outline是关于轮廓的唯一简写属性；<br>如果想要模拟一个反色边框，可以先设置一个轮廓，为其宽度制定一个长度值，然后设置该元素的外边距等于或大于该宽度；由于轮廓画在外边距“之上”，所以它会填入其部分空间；<br>轮廓不会参与到文档流中，因此即使因为焦点的改变使轮廓从一个链接移动到另一个链接上，也不会导致文档重新显示；如果创作人员使用边框指示焦点，文档布局就会不停地变化和跳跃；轮廓可以得到与边框相同的效果，但不会跳跃；<br>CSS2中轮廓不会覆盖元素框的可见部分，而只可能覆盖外边距（透明外边距）；<br>CSS2有一些方面很模糊，其中包括它明确地拒绝两个轮廓相互重叠时的行为，也没有定义元素被其他元素部分模糊时对其轮廓会有怎样的影响；</p>
<h1 id="十四、非屏幕媒体"><a href="#十四、非屏幕媒体" class="headerlink" title="十四、非屏幕媒体"></a>十四、非屏幕媒体</h1><h2 id="1-设计特定于媒体的样式表"><a href="#1-设计特定于媒体的样式表" class="headerlink" title="1. 设计特定于媒体的样式表"></a>1. 设计特定于媒体的样式表</h2><p>利用HTML和CSS中定义的机制，可以将样式表限制为仅用于某种特定媒体；对于基于HTML的样式表，可以通过media属性对媒体做出限制，在link和style元素中用法是一样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="stylesheet" type="text/css" media="print" href="aa.css"&gt;</span><br><span class="line">&lt;style type="text/css" media="projection，screen"&gt;</span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:sans-serif;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>media属性可以接受一个媒体值或者媒体值表（各媒体值之间用逗号分隔）；<br>在样式表本身，还可以在@import规则上限制媒体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import url(aa.css) screen,projection;</span><br><span class="line">@import url(bb.css) print;</span><br></pre></td></tr></table></figure></p>
<p>如果没有为样式表增加媒体信息，他会应用于所有媒体；如果希望一组样式只应用于一种媒体，那么就要向样式表显式地增加媒体信息；<br>@media块的大小不限，可以包含任意多个规则；如果创作人员只能控制一个样式表，@media块则可能是定义特定媒体样式表的唯一途径；如果使用CSS对一个使用XML语言的文档应用样式，而这个XML语言中没有media属性或相应属性，这种情况下，也必须使用@media块；</p>
<h2 id="2-分页媒体"><a href="#2-分页媒体" class="headerlink" title="2. 分页媒体"></a>2. 分页媒体</h2><p>在CSS术语中，分页媒体是把文档表示处理为一系列离散“页面”的媒体；屏幕没提示一种连续性媒体：文档表示为一个可滚动的“页面”；实例：打印资料（书，杂志和激光打印机输出等）、幻灯片；</p>
<h3 id="2-1-打印样式"><a href="#2-1-打印样式" class="headerlink" title="2.1 打印样式"></a>2.1 打印样式</h3><p>最常见到的分页媒体是文档的打印输出（如Web页面、字处理文档、电子表格或成张的输出），打印样式会应用于“打印预览”模式的文档显示；<br><strong>屏幕与打印的区别：</strong>     </p>
<ul>
<li>除了明显的物理差异外，还有很多样式上的不同；</li>
<li>最基本的差别是字体选择，最合适屏幕设计的字体是sans-serif字体，但是在打印媒体中serif字体更可读；</li>
<li>另一个主要区别在于字体大小，点作为Web上的字体大小不是一个好的选择（在不同浏览器和操作系统上会有不一致大小的显示），使用点（甚至厘米或派卡）在打印设计中是完全可行的（因为打印设备知道其输出区域的物理大小，打印机可以处理物理世界的长度单位，如点）；</li>
<li>另外，大多数打印输出中都没有背景，为了节省用户的打印油墨，大多数Web浏览器都预先配置为不打印背景色和图像；如果确实想要在打印输出宏看到这些背景，就必须在首选项中修改一个选项；无法通过CSS强制打印背景色 ，不过可以使用一个打印样式表确保不打印背景；</li>
<li>在分页媒体中更难使用多列布局；解决方法是使用CSS建立多列布局（可能通过浮动实现），然后编写一个打印样式表，将内容回复称单列打印；     </li>
</ul>
<hr>
<p><strong>定义页面大小：</strong><br>CSS定义了描述页面组件的页框，页框基本上由两个区组成：    </p>
<ul>
<li>页面区，这是页面中放内容的部分；它类似于正常元素框中的内容区，因为页面区的边界相当于页面中布局的初始包含块；</li>
<li>外边距框，这是围绕页面区的部分；</li>
</ul>
<p>在CSS2.1中，创作人员只能设置外边距区的大小，使用@page规则来完成设置；<em>在CSS2中还可以设置页框的大小，用属性size设置，这个属性从CSS2.1中去除了，原因是缺乏实现支持</em>；<br>关于页框真正有意思的是，它与字体没有任何关系，所以不能使用长度单位em和ex来描述外边距区或页面区，这里只允许指定百分数和“尺度”单位，如英寸、厘米或点；</p>
<hr>
<p><strong>选择页面类型：</strong><br>CSS2允许通过命名@page规则创建不同的页面类型；<em>可以通过page属性实现向文档中的不同元素指定命名页面类型（此属性也已经从CSS2.1中去除）</em>；<br>通过特殊伪类，可以处理更多通用页面类型，在CSS2和CSS2.1中都有定义；<code>:first</code>允许向文档中的第一个页面应用特殊样式，可以使用<code>:left</code>和<code>:right</code>对左页和右页分别设置样式，模拟书脊左右两边的书页；</p>
<hr>
<p><strong>分页：</strong><br><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%88%86%E9%A1%B5.png" alt="分页"><br>可以使用属性page-break-before和page-break-after影响分页，它们接受同样的一组值；<br>默认值auto只是说明不要求在元素之前或之后分页，这与正常的打印输出相同；<br>always值导致在设置样式的元素之前（或之后）放一个分页符；<br>值left（元素在左页的顶部打印）和right（元素在右页的顶部打印）的做法与always相同，只不过它们更进一步定义了继续打印哪种类型的页面，前面可能插入一个或两个分页符；<br>值avoid，它会让用户代理尽量避免（无法绝对保证）在一个元素之前或之后放置分页符；      </p>
<p><img src="http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%88%86%E9%A1%B52.png" alt="分页2"><br>利用page-break-inside，可以不采用默认做法而另作选择：请求用户代理尽量避免在一个元素内部放置分页符；</p>
<hr>
<p><strong>orphans和widows：</strong><br>为了对分页提供更精确的控制，CSS2定义了传统打印排版和桌面发布中都很常见的两个属性orphans和widows，它们目的一样，只是实现角度不同；值widows定义了放在页面顶部的元素在不导致前面增加分页符的前提下所包含的最小行框数；orphans的作用恰好与之对应：它定义了不会导致元素前增加分页符的前提下可以出现在页面底部的最小行框数；orphans和widows都必须满足；</p>
<hr>
<p><strong>分页行为：</strong><br>由于CSS2允许一些奇怪的分页样式，它关于所允许的分页符和“最佳”分页符定义了一组行为；这些行为可以知道用户代理如何在不同的情况下处理分页；<br>实际上只有两个通用位置上允许有分页符：<br>第一个是两个块级元素框之间；如果分页符在两个块框之间，则分页符之前的元素的margin-bottom值重置为0，分页符后的元素的margin-top值也重置为0；不过以下两个规则允许在两个元素框之间放置分页符：     </p>
<ul>
<li>第一个元素的page-break-after值或第二个元素的page-break-before值是always、left或right；不论其他元素的值是什么（甚至可能是avoid），都必须在元素间放置分页符（这是强制分页符）；</li>
<li>第一个元素的page-break-after值是auto，第二个元素的page-break-before值也是auto，而且它们没有一个page-break-inside值不为avoid的共同祖先元素；</li>
</ul>
<p>第二个允许放分页符的通用位置是一个块级框中的两个行框直接；这是由两个规则控制：</p>
<ul>
<li>只有当元素开始于分页符之前之间的行框数小于该元素的orphans值时，才可能在两个行框之间出现分页符；类似的，值只有当分页符之后行框与元素结束处之间的行框数小于widows值时，才可能在两个行框直接插入分页符；</li>
<li>如果元素的page-break-inside值不是avoid，可能在行框之间放分页符；</li>
</ul>
<p>在这两种情况下，倘若无论分页符如何放置都无法使这两个规则同时满足，则会忽略控制分页符放置的第二条规则；一个元素指定了page-break-inside:avoid，但是它比一整页还长，则允许在该元素内部插入一个分页符，换句话说，会忽略在行框之间放置分页符的第二个规则；<br>如果忽略各组规则中的第二个规则后扔不能很好地放置分页符，还可以忽略其他规则；在这种情况下，用户代理很可能忽略所有分页属性值，就好像它们都设置为auto一样，不过这种方法在CSS规范中没有定义（或未做要求）；<br>除了前面的规则外，css还定义了一组“最佳”分页行为（非必要，但是是合理的指导，有助于得到理想的分页行为）：</p>
<ul>
<li>尽可能少分页；</li>
<li>让所有不是以强制分页符结尾的页面都有相同的高度；</li>
<li>避免在有边框的块内部分页；</li>
<li>避免在表内部分页；</li>
<li>避免在浮动元素内部分页；</li>
</ul>
<hr>
<p><strong>重复元素：</strong><br>分页媒体往往要求有一个页头；页头是指在每个页面上都出现的一个元素；在CSS2中可以使用固定定位元素指定页头，如<code>div#runhead{position:fixed;top:0;right:0;}</code>,在文档输出到一个分页媒体时，这会把它放到每个页框的右上角；这个规则也会把该元素放在连续媒体视窗的右上角；</p>
<hr>
<p><strong>页面外的元素：</strong><br>对于元素定位在页框之后的情况，CSS2没有指出用户代理应该怎么做，所以要由用户代理自己确定解决方案；<br>有两个建议非常重要：首先，内容应该能稍稍超出页框，从而允许生成”出血版”，这说明对于超出页框的部分内容，不会生成额外的页面；其次，用户代理要注意不能只是为了满足定位信息而生成太多空页面；<br>还有两个建议指出，用户代理不能只是 为了避免某些元素而把元素定位到奇怪的位置，另外放在页框之外的内容也能以多种方式表现（CSS的某些元素很有用也很复杂，不过有些看上去则很直接明了）；</p>
<h3 id="2-2-投影样式"><a href="#2-2-投影样式" class="headerlink" title="2.2. 投影样式"></a>2.2. 投影样式</h3><p>投影是一种常用的分页媒体，它描述了投影到一个大屏幕上的信息，适合很多观众观看，PPT是当前最知名的投影媒体之一；<br>支持透明媒体CSS的浏览器（<em>需要确认，不清楚支持情况</em>）</p>
<hr>
<p><strong>建立幻灯片：</strong><br>如果把一个文档分成一系列幻灯片，需要一种办法来定义各幻灯片之间的界限，这个工作使用分页属性完成；到底使用page-break-before还是page-break-after，很大程度上取决于文档如何构造；</p>
<hr>
<p><strong>定位元素：</strong><br>在定位元素时，其初始包含块就是元素所在的页框；因此，如果希望每个幻灯片的标题出现在幻灯片的底部，可以用<code>h2{page-break-before:always;position:absolute;bottom:0;right:0;}</code>表示；<br>类似于打印媒体，固定定位元素会出现在幻灯片中的每一个页框中；这说明可以将一个元素（如文档标题）放在每一个幻灯片上，这种技术可以用于创建每一页上的页脚、图形边栏等；</p>
<hr>
<p><strong>关于投影的考虑：</strong><br>创建投影样式表时需要提前考虑一个特定的分辨率；可能需要对不同的分辨率创建不同的样式表；如果采用对比强烈的颜色，投影文档对观众来说往往更可读；</p>
<h2 id="3-声音样式"><a href="#3-声音样式" class="headerlink" title="3. 声音样式"></a>3. 声音样式</h2><p>CSS2.1废弃了媒体类型aural以及与之相关的所有属性，CSS3使用媒体类型speech来表示文档的语音表现；</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【教程】Node.js]]></title>
      <url>https://dudujie0915.github.io/2016/08/05/nodejs/</url>
      <content type="html"><![CDATA[<h1 id="一、Node-js创建第一个应用"><a href="#一、Node-js创建第一个应用" class="headerlink" title="一、Node.js创建第一个应用"></a>一、Node.js创建第一个应用</h1><p>Node.js应用的组成部分：</p>
<ul>
<li>引入required模块；</li>
<li>创建服务器；</li>
<li>接收请求与响应请求；</li>
</ul>
<h1 id="二、NPM-使用介绍"><a href="#二、NPM-使用介绍" class="headerlink" title="二、NPM 使用介绍"></a>二、NPM 使用介绍</h1><p>npm是NodeJS的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景如下：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用；</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用；</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用；<a id="more"></a>
<h1 id="三、Node-jsREPL（交互式解释器）"><a href="#三、Node-jsREPL（交互式解释器）" class="headerlink" title="三、Node.jsREPL（交互式解释器）"></a>三、Node.jsREPL（交互式解释器）</h1>Node自带了交互式解释器，可以执行以下任务：</li>
<li>读取：读取用户数据，解析输入了JavaScript数据结构并存储在内存中；</li>
<li>执行：执行输入的数据结构；</li>
<li>打印：输出结果；</li>
<li>循环：循环操作以上步骤知道用户两次按下ctrl+c或者直接按下ctrl+d按钮退出；</li>
</ul>
<h1 id="四、Node-js回调函数"><a href="#四、Node-js回调函数" class="headerlink" title="四、Node.js回调函数"></a>四、Node.js回调函数</h1><p>Node.js异步编程的直接体现就是回调；异步编程依托于回调来实现，Node使用了大量的回调函数，Node所有的API都支持回调函数；</p>
<h1 id="五、Node-js-事件循环"><a href="#五、Node-js-事件循环" class="headerlink" title="五、Node.js 事件循环"></a>五、Node.js 事件循环</h1><p>Node.js是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高；<br>Node.js的每一个API都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发；<br>Node.js基本上所有事件机制都是用设计模式中观察者模式实现；<br>Node.js单线程类似进入一个while（true）的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数；</p>
<h1 id="六、Node-js-EventEmitter"><a href="#六、Node-js-EventEmitter" class="headerlink" title="六、Node.js EventEmitter"></a>六、Node.js EventEmitter</h1><p>Node.js所有的异步I/O操作在完成时都会发送一个事件打牌事件列队；<br>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件，一个fs.readStream对象会在文件被打开的时候发出一个事件，所有这些产生事件的对象都是events.EventEmitter的实例；</p>
<h1 id="七、Node-js-Buffer-缓冲区"><a href="#七、Node-js-Buffer-缓冲区" class="headerlink" title="七、Node.js Buffer(缓冲区)"></a>七、Node.js Buffer(缓冲区)</h1><p>JavaScript语言 自身只有字符串数据类型，没有二进制数据类型，但是在处理像TCP流或文件流时，必须使用到二进制数据，因此在Node.js中定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓存区；</p>
<h1 id="八、Node-js-Stream-流"><a href="#八、Node-js-Stream-流" class="headerlink" title="八、Node.js Stream(流)"></a>八、Node.js Stream(流)</h1><p>Stream是一个抽象接口，Node.js有四种流类型：Readable（可读操作）、Writable（可写操作）、Duplex（可读可写操作）、Transform（操作被写入数据，然后读出结果）；<br>所有的Stream对象都是Emitter对象都是EventEmitter的实例，常用的事件有：data（当有数据可读时触发）、end（没有更多数据可读时触发）、error（在接收和写入过程中发生错误时触发）、finish（所有数据已被写入到底层系统时触发）；</p>
<h1 id="九、Node-js模块系统"><a href="#九、Node-js模块系统" class="headerlink" title="九、Node.js模块系统"></a>九、Node.js模块系统</h1><p>模块是Node.js应用程序的基本组成部分，文件和模块是一一对应的，换言之，一个Node.js文件就是一个模块，这个文件可能是JavaScript代码、JSON或者编译过的C/C++扩展；</p>
<h1 id="十、Node-js函数"><a href="#十、Node-js函数" class="headerlink" title="十、Node.js函数"></a>十、Node.js函数</h1><h1 id="十一、Node-js路由"><a href="#十一、Node-js路由" class="headerlink" title="十一、Node.js路由"></a>十一、Node.js路由</h1><p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由根据这些数据来执行相应的代码；我们需要查看HTTP请求，从中提取出来请求的URL一级GET/POST参数；<br>我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递，为了解析这些数据，我们需要额外的Node.js模块，它们分别是url和querystring模块；</p>
<h1 id="十二、Node-js全局对象"><a href="#十二、Node-js全局对象" class="headerlink" title="十二、Node.js全局对象"></a>十二、Node.js全局对象</h1><p>Node.js中的全局对象是global，所有全局变量（除了global本身以外）都是global对象的属性，我们可以直接访问到global的属性，而不需要在应用中包含它；</p>
<h2 id="1-全局对象和全局变量"><a href="#1-全局对象和全局变量" class="headerlink" title="1. 全局对象和全局变量"></a>1. 全局对象和全局变量</h2><p>global最根本的作用是作为全局变量的宿主，满足一下条件的变量是全局变量：①在最外层定义的变量；②全局对象的属性；③隐式定义的变量（未定义直接赋值的变量）；<br>当定义一个全局变量时，这个变量同时称为全局对象的属性，反之亦然；<br>在Node.js中不可能在最外层定义变量，因为所有用户代码都属于当前模块，而模块本身不是最外层上下文；永远使用var定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险；</p>
<h1 id="十三、Node-js常用工具"><a href="#十三、Node-js常用工具" class="headerlink" title="十三、Node.js常用工具"></a>十三、Node.js常用工具</h1><p>util是一个Node.js核心模块，提供常用函数的集合，用于弥补核心JavaScript的功能过于精简的不足；</p>
<h1 id="十四、文件系统"><a href="#十四、文件系统" class="headerlink" title="十四、文件系统"></a>十四、文件系统</h1><p>Node.js提供一组类似UNIX（POSIX）标准的文件操作API；</p>
<h1 id="十五、GET-POST请求"><a href="#十五、GET-POST请求" class="headerlink" title="十五、GET/POST请求"></a>十五、GET/POST请求</h1><p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包含了?后面的部分，因此可以手动解析后面的内容作为GET请求的参数，Node.js中url模块中的parse函数提供了这个功能；<br>POST请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一个耗时的工作；</p>
<h1 id="十六、Node-js-Web模块"><a href="#十六、Node-js-Web模块" class="headerlink" title="十六、Node.js Web模块"></a>十六、Node.js Web模块</h1><p>目前最主流的三个Web服务器是Apache、Nginx、IIS；</p>
]]></content>
      
        <categories>
            
            <category> Nodejs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Nodejs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【教程】JavaScript_DOM编程艺术第二版]]></title>
      <url>https://dudujie0915.github.io/2016/08/05/JavaScript/JavaScript_DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E7%AC%AC%E4%BA%8C%E7%89%88/</url>
      <content type="html"><![CDATA[<h1 id="一、JavaScript简史"><a href="#一、JavaScript简史" class="headerlink" title="一、JavaScript简史"></a>一、JavaScript简史</h1><h2 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h2><h2 id="2-DOM"><a href="#2-DOM" class="headerlink" title="2. DOM"></a>2. DOM</h2><p>DOM是一套对文档的内容进行抽象和概念化的方法；</p>
<h2 id="3-浏览器战争"><a href="#3-浏览器战争" class="headerlink" title="3. 浏览器战争"></a>3. 浏览器战争</h2><h3 id="3-1-DHTML"><a href="#3-1-DHTML" class="headerlink" title="3.1 DHTML"></a>3.1 DHTML</h3><p>DHTML的含义是：</p>
<ul>
<li>利用HTML把网页标记为各种元素；</li>
<li>利用css设置元素样式和他们的位置；</li>
<li>利用JavaScript实时地操控页面和改变样式；<a id="more"></a>
</li>
</ul>
<h3 id="3-2-浏览器之间的冲突"><a href="#3-2-浏览器之间的冲突" class="headerlink" title="3.2 浏览器之间的冲突"></a>3.2 浏览器之间的冲突</h3><p>不同的浏览器之间不同的实现方式，在早期的Nerscape和IE之间出现（现在IE低版本也是这个问题），这促使标准的出现；</p>
<h2 id="4-制定标准"><a href="#4-制定标准" class="headerlink" title="4. 制定标准"></a>4. 制定标准</h2><p>W3C组织发起，Netscape、微软和其他一些浏览器制造商联合制定，影响深远；</p>
<ul>
<li>浏览器以外的考虑</li>
<li>浏览器战争的结局</li>
<li>崭新的起点</li>
</ul>
<h1 id="二、JavaScript语法"><a href="#二、JavaScript语法" class="headerlink" title="二、JavaScript语法"></a>二、JavaScript语法</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>程序设计语言分为解释型和编译型两大类，Java或C++等语言需要一个编译器，编译器是一种程序，能够把用Java等高级语言编写出来的源代码翻译成直接在计算机上执行的文件；解释型应用程序只需要解释器，对于JavaScript语言，在互联网环境下，Web浏览器负责完成有关的解释和执行工作；</p>
<h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><h3 id="2-1-语句"><a href="#2-1-语句" class="headerlink" title="2.1 语句"></a>2.1 语句</h3><p>语句用”;”区分<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多行语句</span></span><br><span class="line">first statement;</span><br><span class="line">second statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单行语句</span></span><br><span class="line">first statement;  second statement;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line">&lt;!--单行注释，HTML风格，没有闭合标签，只能用于单行注释，容易混淆，最好不要用</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多行</span></span><br><span class="line"><span class="comment">  注释*/</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><ul>
<li>变量和赋值，变量可以不用提前声明，但是建议提前声明，用“var”完成声明；</li>
<li>不必单独声明每个变量，可以一条语句一次声明多个变量；</li>
<li>可以把声明变量和对该变量赋值一次完成； </li>
<li>在JavaScript中，变量和其他语法元素的名字都是区分字母大小写的；</li>
<li>JavaScript变量名中不允许包含空格或标点符号（美元符号“$”例外）；</li>
<li>JavaScript变量名允许包含字母、数字、美元符和下划线（但是第一个字符不允许是数字）；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line">mood = <span class="string">"happy"</span>;</span><br><span class="line">age = <span class="number">33</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">var</span> mood;</span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一条语句一次声明多个变量</span></span><br><span class="line"><span class="keyword">var</span> mood,age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把声明变量和对该变量赋值一次完成</span></span><br><span class="line"><span class="keyword">var</span> mood =<span class="string">"happy"</span>;</span><br><span class="line"><span class="keyword">var</span> age =<span class="number">33</span>;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">var</span> mood =<span class="string">"happy"</span>,age=<span class="number">33</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的语句是对两个不同的变量进行赋值</span></span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">"happy"</span>;</span><br><span class="line">MOOD = <span class="string">"sad"</span>;</span><br><span class="line">Mood = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名方法一：</span></span><br><span class="line"><span class="keyword">var</span> my_mood = <span class="string">"happy"</span>;</span><br><span class="line"><span class="comment">//命名方法二（驼峰格式）：</span></span><br><span class="line"><span class="keyword">var</span> myMod = <span class="string">"happy"</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4 数据类型"></a>2.4 数据类型</h3><p>有些语言要求在声明变量的同事必须声明变量的数据类型，这种做法称为类型声明（typing）；<br>必须明确类型声明的语言称为强类型（strongly typed）语言；JavaScript不需要进行类型声明，是一种弱类型（weakly typed）语言，这意味可以在任何阶段改变变量 的数据类型；  </p>
<ul>
<li>字符串、数值和布尔值都是标量（scalar）；</li>
<li>字符串：有0个或多个字符构成，字符包括（但不限于）字母 、数字、标点符号和空格。字符串必须包在引号里，单引号或者双引号都可以；</li>
<li>数值：可以是任意位的小数（浮点数），整数，可以是负数（早有关数值前面加一个减号“-”），可以是负浮点数；</li>
<li>布尔值：布尔（boolean）类型，只有两个可选值–true和false；</li>
<li>数组：  <ol>
<li>指用一个变量表示一个值的集合，集合中的每个值都是这个数组的一个元素（element） ；  </li>
<li>在JavaScript中，数组可以用关键字Array声明，声明数组的同时可以指定数组初始元素个数，也就是数组的长度（length）；  </li>
<li>向数组添加元素的操作称为填充，填充数组时，不仅需要给出新元素的值，还需要给出新元素在数组中的存放位置，这个位置就是这个元素的下      标，数组里一个元素一个下标；用0作为第一个下标；可以在声明数组的同时对他进行填充；数组元素可以是字符串、布尔值、一组数值，也可以是三者的混合，还可以是变量，数组元素的值可以是另外一个数组的元素，数组可以包含其他数组，数组中的任何一个元素都给可以把一个数组作为它的值；  </li>
<li>关联数组：如果在填充数组是只给出了元素的值，这个数组就是传统数组，它的各个元素的下标将自动创建和刷新；可以通过在填充数组的时候为每个新元素明确地给出下标来改变这种默认的行为，下标不必局限于整数数字，这样的数组叫关联数组；</li>
</ol>
</li>
<li>对象：对象使用一个名字表示一组值，对象的每个值都是对象的一个属性；创建对象使用Object关键字，使用点好来获取属性，属性值可以是任何JavaScript值，包括其他对象；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="comment">//下面两个完全一样</span></span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">"happy"</span>;</span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">'happy'</span>;</span><br><span class="line"><span class="comment">//单双引号的表示</span></span><br><span class="line"><span class="keyword">var</span> mood =<span class="string">"don't ask"</span>;</span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">'don\'t ask'</span>; <span class="comment">//字符转义</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="string">"about 5'10\" tall"</span>; <span class="comment">//字符转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数值</span></span><br><span class="line"><span class="keyword">var</span> tem = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">var</span> tem = <span class="number">20.33</span>;</span><br><span class="line"><span class="keyword">var</span> tem = <span class="number">-33</span>;</span><br><span class="line"><span class="keyword">var</span> tem = <span class="number">-20.33</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔值</span></span><br><span class="line"><span class="keyword">var</span> sleeping = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> sleeping = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> sleeping = <span class="string">"true"</span>; <span class="comment">//这个是字符串类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> beatles = <span class="built_in">Array</span>(<span class="number">4</span>); <span class="comment">//数组的长度为4</span></span><br><span class="line"><span class="keyword">var</span> beatles = <span class="built_in">Array</span>（）; <span class="comment">//未给出元素个数</span></span><br><span class="line"><span class="comment">//数据填充</span></span><br><span class="line">array[index] = element;</span><br><span class="line">beatles[<span class="number">0</span>] = <span class="string">"John"</span>; <span class="comment">//用0作为第一个下标</span></span><br><span class="line"><span class="comment">//声明和填充beatles数组的全过程:</span></span><br><span class="line"><span class="keyword">var</span> beatles = <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">beatles[<span class="number">0</span>] = <span class="string">"John"</span>;</span><br><span class="line">beatles[<span class="number">1</span>] = <span class="string">"Paul"</span>;</span><br><span class="line">beatles[<span class="number">2</span>] = <span class="string">"George"</span>;</span><br><span class="line">beatles[<span class="number">3</span>] = <span class="string">"Ringo"</span>;</span><br><span class="line"><span class="comment">//简单的方法声明和填充beatles数组:</span></span><br><span class="line"><span class="keyword">var</span> beatles = <span class="built_in">Array</span>(<span class="string">"John"</span>,<span class="string">"Paul"</span>,<span class="string">"George"</span>,<span class="string">"Ringo"</span>);</span><br><span class="line"><span class="comment">//简写形式</span></span><br><span class="line"><span class="keyword">var</span> beatles = [<span class="string">"John"</span>,<span class="string">"Paul"</span>,<span class="string">"George"</span>,<span class="string">"Ringo"</span>];</span><br><span class="line"><span class="comment">//数组存放数值</span></span><br><span class="line"><span class="keyword">var</span> year = [<span class="number">1940</span>,<span class="number">1955</span>,<span class="number">1963</span>,<span class="number">1994</span>];</span><br><span class="line"><span class="comment">//数组存放混合数据类型</span></span><br><span class="line"><span class="keyword">var</span> lennon = [<span class="string">"John"</span>,<span class="number">1940</span>,<span class="literal">false</span>];</span><br><span class="line"><span class="comment">//数组元素可以是变量</span></span><br><span class="line"><span class="keyword">var</span> name =<span class="string">"John"</span>;</span><br><span class="line">beatles[<span class="number">0</span>] = name;</span><br><span class="line"><span class="comment">//数组元素的值可以是另一个数组的元素</span></span><br><span class="line"><span class="keyword">var</span> name = [<span class="string">"Ringo"</span>,<span class="string">"John"</span>,<span class="string">"George"</span>,<span class="string">"Paul"</span>];</span><br><span class="line">beatles[<span class="number">1</span>] = name[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//数组可以包含其他数组</span></span><br><span class="line"><span class="keyword">var</span> lennon =  [<span class="string">"John"</span>,<span class="number">1940</span>,<span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> beatles = [];</span><br><span class="line">beatles[<span class="number">0</span>] = lennon;</span><br><span class="line"><span class="comment">//关联数组</span></span><br><span class="line"><span class="keyword">var</span> lennon = <span class="built_in">Array</span>();</span><br><span class="line">lennon[<span class="string">"name"</span>] = <span class="string">"John"</span>;</span><br><span class="line">lennon[<span class="string">"year"</span>] = <span class="number">1940</span>;</span><br><span class="line">lennon[<span class="string">"living"</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">var</span> lennon = <span class="built_in">Object</span>();</span><br><span class="line">lennon.name = <span class="string">"John"</span>;</span><br><span class="line">lennon.year = <span class="number">1940</span>;</span><br><span class="line">lennon.living = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//创建对象的简洁语法--花括号语法：</span></span><br><span class="line"><span class="keyword">var</span> lennon = &#123;<span class="attr">name</span>:<span class="string">"John"</span>,<span class="attr">year</span>:<span class="number">1940</span>,<span class="attr">living</span>:<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-操作"><a href="#3-操作" class="headerlink" title="3. 操作"></a>3. 操作</h2><h3 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h3><p>加（+）减（-）乘（*）除（/）;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量可以包含操作</span></span><br><span class="line"><span class="keyword">var</span> tatal = (<span class="number">1</span>+<span class="number">4</span>)*<span class="number">5</span></span><br><span class="line"><span class="comment">//可以对变量进行操作</span></span><br><span class="line"><span class="keyword">var</span> temp_fahrenheit = <span class="number">95</span>;</span><br><span class="line"><span class="keyword">var</span> temp_celsius = (temp_fahrenheit - <span class="number">32</span>) / <span class="number">1.8</span>;</span><br><span class="line"><span class="comment">//常用操作缩写</span></span><br><span class="line">year = year + <span class="number">1</span>;可以缩写为year++;</span><br><span class="line">year = year - <span class="number">1</span>;可以缩写为year--;</span><br><span class="line"><span class="comment">//加号（+）即可以用于数值，也可以用用于字符串</span></span><br><span class="line"><span class="comment">//把多个字符串收尾相连在一起的操作叫做拼接</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"I am grrling"</span> + <span class="string">"happy"</span>;</span><br><span class="line"><span class="comment">//可以通过变量完成拼接</span></span><br><span class="line"><span class="keyword">var</span> mood = <span class="string">"happy"</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"I am feeling"</span> + mood;</span><br><span class="line"><span class="comment">//可以把数值和字符串拼接在一起，此时，数值自动转换为字符串</span></span><br><span class="line"><span class="keyword">var</span> year = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">"The year is"</span> + year;</span><br><span class="line"><span class="comment">//比较字符串和数值</span></span><br><span class="line">alert(<span class="string">"10"</span>+<span class="number">20</span>);<span class="comment">//返回字符串“1020”</span></span><br><span class="line">alert(<span class="number">10</span>+<span class="number">20</span>);<span class="comment">//返回数值30</span></span><br><span class="line"><span class="comment">//快捷操作符+=，它一次完成“加法和赋值”（“或拼接和赋值”）</span></span><br><span class="line"><span class="keyword">var</span> year = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">var</span> message == <span class="string">"The year is"</span>;</span><br><span class="line">message += year; 等同于 message = message + year;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-条件语句"><a href="#4-条件语句" class="headerlink" title="4. 条件语句"></a>4. 条件语句</h2><p>最常见的条件语句是if语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(condition)&#123;值为true时执行;&#125;else&#123;值为false时执行;&#125;</span><br><span class="line">iff(condition) 值为true时执行;</span><br></pre></td></tr></table></figure></p>
<p>条件放在if后面的圆括号里，条件的求值结果永远是一个布尔值，即只能是true或false；<br>花括号本事并不是必不可少的，如果if语句中花括号部分值包含这一条语句，那么它就可以不使用花括号，而且这条语句的内容可以写在同一行上；它可以提高脚本的可读性，推荐使用；</p>
<h3 id="4-1-比较操作符"><a href="#4-1-比较操作符" class="headerlink" title="4.1 比较操作符"></a>4.1 比较操作符</h3><p>大于(&gt;)、小于(&lt;)、大于等于(&gt;=)、小于等于(&lt;=)、等于(==)、不等于(!=)、全等于(===)，严格不相等(!==)<br>单个等号(=)是用于完成赋值操作的；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b)&#123;alert();&#125;<span class="comment">//求值结果为true</span></span><br><span class="line"><span class="keyword">if</span>(a === b)&#123;alert();&#125;<span class="comment">//求值结果为false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-逻辑操作符"><a href="#4-2-逻辑操作符" class="headerlink" title="4.2 逻辑操作符"></a>4.2 逻辑操作符</h3><p>逻辑与（&amp;&amp;）、逻辑或（||）、逻辑非（!）<br>JavaScript允许把条件语句的操作组合在一起；<br>逻辑操作符的操作对象是布尔值，每个逻辑操作数返回一个布尔值true或false；<br>逻辑与只有在所有的操作数都是true时才会是true；<br>逻辑或只要有一个操作数为true时就是true，只有当所有的操作数为false时才为false；<br>逻辑非只能用于单个逻辑操作数，其结果是把那个逻辑操作数返回的布尔值取反；</p>
<h2 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5. 循环语句"></a>5. 循环语句</h2><p>循环语句可以让我们反复的执行同一段代码；</p>
<h3 id="5-1-while循环"><a href="#5-1-while循环" class="headerlink" title="5.1 while循环"></a>5.1 while循环</h3><p>while循环：与if语句唯一的区别就是：只要给定条件的求值结果是true，包括在花括号里的代码就将反复地执行下去；<br>while循环的花括号部分所包含的语句有可能不被执行，因为对循环控制条件的求值发生在每次循环开始之前，所有如果循环控制条件的首次求值结果是false，那么代码将一次也不会被执行；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt; <span class="number">11</span>)&#123;</span><br><span class="line">    alert(count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>do…while循环：在循环语句的代码至少执行一次；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    alert(count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;<span class="keyword">while</span>(count&lt;<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-for循环"><a href="#5-2-for循环" class="headerlink" title="5.2 for循环"></a>5.2 for循环</h3><p>用for循环来重复执行一些代码的好处是循环控制结构更加清晰<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">var</span> beatles = <span class="built_in">Array</span>(<span class="string">"John"</span>,<span class="string">"Paul"</span>,<span class="string">"George"</span>,<span class="string">"Ringo"</span>);</span><br><span class="line"><span class="keyword">for</span>（<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; beatles.length; count++）&#123;</span><br><span class="line">    alert(beatles[count]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><p>函数就是一组允许在你的代码里随时调用的语句，事实上，每个函数实际上是一个短小的脚本;<br>应该先对函数做出定义再调用它们；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> beatles = <span class="built_in">Array</span>(<span class="string">"John"</span>,<span class="string">"Paul"</span>,<span class="string">"George"</span>,<span class="string">"Ringo"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; beatles.length; count++)&#123;</span><br><span class="line">        alert(beatles[count]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shout();</span><br></pre></td></tr></table></figure></p>
<p>JavaScript提供了许多内置函数，比如alert；<br>在定义函数时，可以为它声明任意多个参数，只要用逗号分割开来就行；在函数内部，可以像使用普通变量那样使用它的任何一个参数；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multily</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = num1 * num2;</span><br><span class="line">    alert(total);</span><br><span class="line">&#125;</span><br><span class="line">multily(<span class="number">10</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>函数的真正价值体现在，我们可以把它们当做一种数据类型来使用，这意味着可以把一个函数的调用结果赋给一个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToCelsius</span>(<span class="params">temp</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = temp - <span class="number">32</span>;</span><br><span class="line">    result = result / <span class="number">1.8</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> temp_fahrenheit = <span class="number">95</span>;</span><br><span class="line"><span class="keyword">var</span> temp_celsius = convertToCelsius(temp_fahrenheit);</span><br><span class="line">alert(temp_celsius);</span><br></pre></td></tr></table></figure></p>
<p><strong>在命名变量时，用下划线分隔各个单词；在命名函数时，从第二个单词开始把每个单词的第一个字母变成大写形式（驼峰命名法）；在命名css的名称时，用“-”分隔单词（非强制，但是好习惯，自己的风格，并且符合规范）</strong></p>
<h3 id="6-1-变量的作用域"><a href="#6-1-变量的作用域" class="headerlink" title="6.1 变量的作用域"></a>6.1 变量的作用域</h3><p>变量既可以是全局的，也可以是局部的；<br>全局变量：可以在脚本的任意位置被引用，全局变量的作用域是整个脚本；<br>局部变量：只存在声明它的那个函数的内部，在那个函数的外部是无法引用它的，局部变量的作用域仅限于某个特定的函数；<br>可以用var关键字明确地为函数变量设定作用域；如果某个函数中使用了var，那么变量就将被视为一个局部变量，它只存在于这个函数的上下文中；反之，如果没有使用var，那么变量就将被视为一个全局变量，如果脚本里已经存在一个与之同名的全局变量，这个函数就会改变那个全局变量的值；<br><strong>函数在行为方面应该像一个自给自足的脚本，在定义一个函数时，一定要 把它内部的变量全部都明确地声明为局部变量；如果总是在函数里使用var关键字来定义变量，就能避免任何形式的二义性隐患；</strong></p>
<h2 id="7-对象"><a href="#7-对象" class="headerlink" title="7. 对象"></a>7. 对象</h2><p>对象是自包含的数据集合，包含在对象里面的数据可以通过两种形式访问—-属性（property）和方法（method）； </p>
<ul>
<li>属性是隶属于每个特定的对象的变量；</li>
<li>方法是只有某个特定对象才能调用的函数；<br>对象就是由一些属性和方法组合在一起而构成的一个数据实体；<br>在JavaScript里，属性和方法都使用“点”语法来访问；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.property</span><br><span class="line">object.method()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-1-内建对象"><a href="#7-1-内建对象" class="headerlink" title="7.1 内建对象"></a>7.1 内建对象</h3><p>JavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象；<br>数组是一种内建对象，当我们用new关键字去初始化一个数组时，其实就是在创建一个Array对象的新实例<code>var beatles = new Array();</code>当需要了解某个数组有多少个元素时，利用Array对象的length属性来获取这一信息<code>beatles.length;</code><br>Math对象（处理数值）、Date对象（处理日期值）</p>
<h3 id="7-2-宿主对象"><a href="#7-2-宿主对象" class="headerlink" title="7.2 宿主对象"></a>7.2 宿主对象</h3><p>可以在JavaScript脚本中使用一些已经 预先定义好的其他对象，在web应用中，是有浏览器提供的；由浏览器提供的预先定义对象称为宿主对象；<br>宿主对象包括Form、Image、Element、document等；</p>
<h1 id="三、-DOM"><a href="#三、-DOM" class="headerlink" title="三、 DOM"></a>三、 DOM</h1><p>5个常用的DOM方法：getElementById、getElementsByIagName、getElementsByClassName、getAttribute、setAttribute  </p>
<h2 id="1-文档：DOM中的“D”"><a href="#1-文档：DOM中的“D”" class="headerlink" title="1. 文档：DOM中的“D”"></a>1. 文档：DOM中的“D”</h2><p>document（文档）</p>
<h2 id="2-对象：DOM中的“O”"><a href="#2-对象：DOM中的“O”" class="headerlink" title="2. 对象：DOM中的“Ｏ”"></a>2. 对象：DOM中的“Ｏ”</h2><p>JavaScript中对象分三类：</p>
<ul>
<li>用户定义对象：由程序员自行创建的对象；</li>
<li>内建对象：内建在JavaScript语言里的对象；</li>
<li>宿主对象：有浏览器提供的对象；<br>最基础的对象是window对象，window对象对应这浏览器窗口本身，这个对象的属性和方法通常称为BOM（浏览器对象模型，或者称为Window Object Model–窗口对象模型），BOM对象提供了window.open和window.blur等方法；</li>
</ul>
<h2 id="3-模型：DOM中的“M”"><a href="#3-模型：DOM中的“M”" class="headerlink" title="3. 模型：DOM中的“M”"></a>3. 模型：DOM中的“M”</h2><p>“M”代表着“Model”（模型），也可以说它代表着“Map”（地图）；</p>
<h2 id="4-节点"><a href="#4-节点" class="headerlink" title="4. 节点"></a>4. 节点</h2><p>元素节点、文本节点、属性节点</p>
<h3 id="4-1-元素节点"><a href="#4-1-元素节点" class="headerlink" title="4.1 元素节点"></a>4.1 元素节点</h3><p>就是指html、head、body、ul、li、div等元素（页面的结构）</p>
<h3 id="4-2-文本节点"><a href="#4-2-文本节点" class="headerlink" title="4.2 文本节点"></a>4.2 文本节点</h3><p>文本节点就是指文本内容；<br>在HTML文档里，文本节点总是被包含在元素节点内部，但并非所有的元素节点都包含有文本节点，比如ul节点包含li节点；</p>
<h3 id="4-3-属性节点"><a href="#4-3-属性节点" class="headerlink" title="4.3 属性节点"></a>4.3 属性节点</h3><p>属性节点用来对元素做出更具体的描述，例如所有的元素都有一个title属性，在DOM中title=”*”是一个属性节点；<br>因为属性节点总是放在起始标签里，所以属性节点总是被包含在元素节点中；<br>并非所有的元素都包含属性，但是所有的属性都被元素包含；</p>
<h3 id="4-4-CSS"><a href="#4-4-CSS" class="headerlink" title="4.4 CSS"></a>4.4 CSS</h3><p>css的语法，继承，class属性，id属性</p>
<h3 id="4-5-获取元素"><a href="#4-5-获取元素" class="headerlink" title="4.5 获取元素"></a>4.5 获取元素</h3><p>有3种DOM方法可以获取元素节点，分别是通过元素的ID、通过标签名称和通过类名字来获取；</p>
<ol>
<li><p><strong>getElementById：</strong>返回一个与那个有着给定id属性值的元素节点对应的对象，它是document对象特有的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(id)</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"purchases"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>getElementsByTagName：</strong>返回一个对象数组，每个对象分别对应着文档里有着给定标签的一个元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">element.getElementsByTagName(tag)</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>)</span><br><span class="line"><span class="comment">//获取每个元素的对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>).length; i++)&#123;</span><br><span class="line">    alert(<span class="keyword">typeof</span> <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>)[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量替换</span></span><br><span class="line"><span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>)；</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;items.length; i++)&#123;</span><br><span class="line">    alert(<span class="keyword">typeof</span> items[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回文档总共元素节点</span></span><br><span class="line">alert(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>).length);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>即使整个文档里标签只有一个，getElementsByTagName也返回一个数组，此时数组的长度为1；</p>
<ol start="3">
<li><strong>getElementsByClassName：</strong>HTML5支持，低版本浏览器需要做兼容性处理，<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//实例</span></span><br><span class="line">document.getElementsByClassName("sale")</span><br><span class="line"><span class="comment">//可以查找带有多个类名的方法,类名的先后顺序不重要，只要元素中的class属性中，有这两个类名就能匹配该元素</span></span><br><span class="line">alert(<span class="built_in">document</span>.getElementsByClassName(<span class="string">"important sale"</span>).length);</span><br><span class="line"><span class="comment">//实例--判断id下面有多少个class元素</span></span><br><span class="line"><span class="keyword">var</span> shopping = <span class="built_in">document</span>.getElementById(<span class="string">"purchases"</span>);</span><br><span class="line"><span class="keyword">var</span> sales = shopping.getElementsByClassName(<span class="string">"sale"</span>);</span><br><span class="line">alert(sales.length);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>重要，getElementsByClassName的兼容性写法(此方法不适用于多个类名)：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementsByClassName</span>(<span class="params">node,classname</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.getElementsByClassName)&#123;</span><br><span class="line">        <span class="comment">//使用现有方法</span></span><br><span class="line">        <span class="keyword">return</span> node.getElementsByClassName(classname);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> results = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">var</span> elems =node.getElementsByTagName(<span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;elems.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(elems[i].className.indexOf(classname) != <span class="number">-1</span>)&#123;</span><br><span class="line">                results[results.length] = elems[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-6-盘点知识点"><a href="#4-6-盘点知识点" class="headerlink" title="4.6 盘点知识点"></a>4.6 盘点知识点</h3><ul>
<li>一份文档就是一棵节点树；</li>
<li>节点分为不同的类型：元素节点、属性节点和文本节点等；</li>
<li>getElementById将返回一个对象，该对象对应着文档里的一个特定的元素节点；</li>
<li>getElementsByTagName和getElementsByClassName将返回一个对象数组，它们分别对应着文档里的一组特定的元素节点；</li>
<li>每个节点都是一个对象；</li>
</ul>
<h2 id="5-获取和设置属性"><a href="#5-获取和设置属性" class="headerlink" title="5. 获取和设置属性"></a>5. 获取和设置属性</h2><p>获取属性getAttribute,改变属性节点的值setAttribute</p>
<h3 id="5-1-getAttribute"><a href="#5-1-getAttribute" class="headerlink" title="5.1 getAttribute"></a>5.1 getAttribute</h3><p>getAttribute是一个函数，只有一个参数—-查询的属性名字<code>object.getAttribute(attribute)</code>,它只能通过元素节点对象调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;paras.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> title_text = paras[i].gatAttribute(<span class="string">"title"</span>);</span><br><span class="line">    <span class="keyword">if</span>(title_text) alert(title_text);<span class="comment">//简写形式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解释：如果p标签上没有title属性，则会返回null值，通过if语句判断是否有值，只有当有值的时候才执行alert，if(title_text != null)&#123;alert(title_text);&#125;是上面的语句的完整写法；</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-setAttribute"><a href="#5-2-setAttribute" class="headerlink" title="5.2 setAttribute"></a>5.2 setAttribute</h3><p>语法<code>object.setAttribute(attribute,value)</code><br>如果元素上原先没有需要赋值的属性，那么setAttribute会先创建这个属性，然后设置它的值；如果setAttribute用在一个本身就有这个属性的元素节点上，这个属性的值就会被覆盖掉；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;paras.length; I++)&#123;</span><br><span class="line">    <span class="keyword">var</span> title_text = paras[i].getAttribute(<span class="string">"title"</span>);</span><br><span class="line">    <span class="keyword">if</span>(title_text)&#123;</span><br><span class="line">        paras[i].setAttribute(<span class="string">"title"</span>,<span class="string">"新的标题"</span>);</span><br><span class="line">        alert(paras[i].getAttribute(<span class="string">"title"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>DOM的五个方法：getElementById、getElementsByTagName、getElementsByClassName、getAttribute、setAttribute;<br>DOM的其他属性和方法：nodeName、nodeValue、childNodes、nextSibling和parentsNode等；</p>
<h1 id="四、案例研究：JavaScript图片库"><a href="#四、案例研究：JavaScript图片库" class="headerlink" title="四、案例研究：JavaScript图片库"></a>四、案例研究：JavaScript图片库</h1><p>DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/index.html" target="_blank" rel="noopener">index.html</a></p>
<h2 id="1-标记"><a href="#1-标记" class="headerlink" title="1. 标记"></a>1. 标记</h2><p>使用ul》li&gt;a建立一个无需列表；</p>
<h2 id="2-JavaScript"><a href="#2-JavaScript" class="headerlink" title="2. JavaScript"></a>2. JavaScript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPic</span>(<span class="params">whichpic</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> source = whichpic.getAttribute(<span class="string">"href"</span>);</span><br><span class="line">    <span class="keyword">var</span> text = whichpic.getAttribute(<span class="string">"title"</span>);</span><br><span class="line">    <span class="comment">//两种实现赋值的方法</span></span><br><span class="line">    <span class="comment">//使用setAttribute赋值（setAttribute方法是“第一级DOM”的组成部分，它可以设置任意元素节点的任意属性）</span></span><br><span class="line">    placeholder.setAttribute(<span class="string">"src"</span>,source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非DOM解决方案（可以解决大部分元素的属性）</span></span><br><span class="line">    <span class="comment">//placeholder.src = source;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-应用这个JavaScript函数"><a href="#3-应用这个JavaScript函数" class="headerlink" title="3. 应用这个JavaScript函数"></a>3. 应用这个JavaScript函数</h2><p><code>onclick= showPic(this);return false;</code></p>
<h2 id="4-对这个函数进行扩展"><a href="#4-对这个函数进行扩展" class="headerlink" title="4. 对这个函数进行扩展"></a>4. 对这个函数进行扩展</h2><p>让图片链接的title属性显示在页面上；</p>
<h3 id="4-1-childNodes"><a href="#4-1-childNodes" class="headerlink" title="4.1 childNodes"></a>4.1 childNodes</h3><p>在一棵节点树上，childNodes属性可以用来获取任何一个元素的所有子元素，他是一个包含这个元素全部子元素的数组：<code>element.childNodes</code>，获取body原色的全体子元素，使用<code>document.getElementsByTagName(&quot;body&quot;)[0].childNodes</code></p>
<h3 id="4-2-nodeType属性"><a href="#4-2-nodeType属性" class="headerlink" title="4.2 nodeType属性"></a>4.2 nodeType属性</h3><p>由childNodes属性返回的数组包含所有类型的节点，不仅仅是元素节点。事实上，文档里几乎每一样东西都是一个节点，甚至连空格和换行符都会被解释为节点，而它们也包含在childNodes属性所返回的数组中；<br>每一个节点都有nodeType属性<code>node.nodeType</code>，nodeType的值是一个数字，共有12种可取值，其中：①元素节点的nodeType属性值是1；②属性节点的nodeType属性值是2；③文本节点的 nodeType属性值是3；   </p>
<h3 id="4-3-在标记里增加一段描述"><a href="#4-3-在标记里增加一段描述" class="headerlink" title="4.3 在标记里增加一段描述"></a>4.3 在标记里增加一段描述</h3><p>定义一个文本节点，在显示图片时，把这个文本节点的值，替换成目标图片链接的title值；</p>
<h3 id="4-4-用JavaScript改变这段描述"><a href="#4-4-用JavaScript改变这段描述" class="headerlink" title="4.4 用JavaScript改变这段描述"></a>4.4 用JavaScript改变这段描述</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先，获取whichpic对象的title属性值，并赋值给变量</span></span><br><span class="line"><span class="keyword">var</span> text =whichpic.getAttribute(<span class="string">"title"</span>);</span><br><span class="line"><span class="comment">//创建新的变量存放文本段落</span></span><br><span class="line"><span class="keyword">var</span> description = <span class="built_in">document</span>.getElementById(<span class="string">"description"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-5-nodeValue属性"><a href="#4-5-nodeValue属性" class="headerlink" title="4.5 nodeValue属性"></a>4.5 nodeValue属性</h3><p>nodeValue属性得到（和设置）一个节点的值<code>node.nodValue</code>；<br>在用nodeValue属性获得description属性的值时，得到的并不是包含在这个段落里的文本，而是返回一个null值； p元素里的文本，是p元素的第一个子节点，要想获取p元素的文本值，用<code>description.childNode[0].nodeValue</code>;</p>
<h3 id="4-6-firstChild和lastChild属性"><a href="#4-6-firstChild和lastChild属性" class="headerlink" title="4.6 firstChild和lastChild属性"></a>4.6 firstChild和lastChild属性</h3><p>数组元素childNodes[0]有个更直观易读的同义词firstChild；<br>node.lastChild代表这childNodes数组的最后一个元素，等同于node.childNodes[node.childNodes.length - 1];</p>
<h3 id="4-7-利用nodeValue属性刷新这段描述"><a href="#4-7-利用nodeValue属性刷新这段描述" class="headerlink" title="4.7 利用nodeValue属性刷新这段描述"></a>4.7 利用nodeValue属性刷新这段描述</h3><p>使用<code>description.firstChild.nodeValue = text;</code>可以刷新描述文字</p>
<h1 id="五、最佳实践"><a href="#五、最佳实践" class="headerlink" title="五、最佳实践"></a>五、最佳实践</h1><h2 id="1-过去的错误"><a href="#1-过去的错误" class="headerlink" title="1. 过去的错误"></a>1. 过去的错误</h2><ul>
<li>不要怪罪JavaScript：不是语言的问题，而是使用语言的问题；</li>
<li>Flash的遭遇：没有不好的技术，只有没有用好的技术； </li>
<li>质疑一切：使用JavaScript时考虑是否必要？对用户的浏览体验产生怎样的影响？浏览器不支持JavaScript怎么办？</li>
</ul>
<h2 id="2-平稳退化"><a href="#2-平稳退化" class="headerlink" title="2. 平稳退化"></a>2. 平稳退化</h2><p>让浏览器不支持JavaScript的情况下仍能顺利地浏览网页，这就是所谓的平稳退化；</p>
<ul>
<li>“JavaScript:”伪协议：通过一个链接调用JavaScript函数，<code>如&lt;a href=&quot;javascript:popup(&#39;http://www.baidu.com&#39;)&quot;;&gt;baidu&lt;/a&gt;</code>；<strong>“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议（http://）、FTP协议（ftp://）等，伪协议则是一种非标准化的协议；</strong></li>
<li>内嵌的事件处理函数：<code>如&lt;a href=&quot;#&quot; onclick=&quot;popup(&#39;http://www.baidu.com&#39;);return false;&quot;&gt;baidu&lt;/a&gt;</code>；</li>
<li>谁关心这个：搜索引擎、用户等；</li>
</ul>
<h2 id="3-像CSS学习"><a href="#3-像CSS学习" class="headerlink" title="3. 像CSS学习"></a>3. 像CSS学习</h2><ul>
<li>结构和样式的分离</li>
<li>渐进增强：就是用一些额外的信息层去包裹原始数据；按照“渐进增强”原则创建出来的页面几乎都符合“平稳退化”原则；</li>
</ul>
<h2 id="4-分离JavaScript"><a href="#4-分离JavaScript" class="headerlink" title="4. 分离JavaScript"></a>4. 分离JavaScript</h2><p>JavaScript代码和HTML文档分离，文档里面的JavaScript属性也进行分离；<br>通过window.onload加载函数；</p>
<h2 id="5-向后兼容"><a href="#5-向后兼容" class="headerlink" title="5. 向后兼容"></a>5. 向后兼容</h2><ul>
<li>对象检查：<code>if(method){statements}</code>,使用<code>if(!method) return false;</code>更好；如果需要检查多个方法或属性是否存在，可以用<code>if (!method-one || method-two) return false;</code></li>
<li>浏览器嗅探技术：指通过提取浏览器供应商提供的信息来解决向后兼容问题，这是一种风险非常大的技术（原因：①浏览器有时会“撒谎”；②为了适应多种不同的浏览器，嗅探脚本会变的越来越复杂；③许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配；）</li>
</ul>
<h2 id="6-性能考虑"><a href="#6-性能考虑" class="headerlink" title="6. 性能考虑"></a>6. 性能考虑</h2><ul>
<li>尽量少访问DOM和尽量减少标记；</li>
<li>合并和放置代码：多代码合并到一个文件，放到的前面；</li>
<li>压缩脚本；</li>
</ul>
<h1 id="六、案例研究：图片库改进版"><a href="#六、案例研究：图片库改进版" class="headerlink" title="六、案例研究：图片库改进版"></a>六、案例研究：图片库改进版</h1><h2 id="1-平稳退化"><a href="#1-平稳退化" class="headerlink" title="1. 平稳退化"></a>1. 平稳退化</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//代码1：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"images/one.jpg"</span> <span class="attr">onclick</span>=<span class="string">"showPic(this);return false;"</span> <span class="attr">title</span>=<span class="string">"A"</span>&gt;</span>Fireworks<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">//代码2：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:showPic('images/one.jpg');return false;"</span> <span class="attr">title</span>=<span class="string">"A"</span>&gt;</span>Fireworks<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">//代码3：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"showPic('images/one.jpg');return false;"</span> <span class="attr">title</span>=<span class="string">"A"</span>&gt;</span>Fireworks<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">代码1能够平稳退化，代码2和代码3不可以；</span><br></pre></td></tr></table></figure>
<h2 id="2-JavaScript和HTML标签分离"><a href="#2-JavaScript和HTML标签分离" class="headerlink" title="2. JavaScript和HTML标签分离"></a>2. JavaScript和HTML标签分离</h2><p>上面的代码1没能做到，如何添加：</p>
<h3 id="2-1-添加事件处理函数"><a href="#2-1-添加事件处理函数" class="headerlink" title="2.1 添加事件处理函数"></a>2.1 添加事件处理函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareGallery</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">document</span>.getElementsByTagName || !<span class="built_in">document</span>.getElementById) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">document</span>.getElementById(<span class="string">"imagegallery"</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> gellery = <span class="built_in">document</span>.getElementById(<span class="string">"imagegallery"</span>);</span><br><span class="line">    <span class="keyword">var</span> links = gellery.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;links.length; i++)&#123;</span><br><span class="line">        links[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//判断是否能够正常执行showPic的函数，并进行取反，如果正常执行函数，那么取消默认事件；否则执行默认事件；</span></span><br><span class="line">            <span class="comment">//return !showPic(this);</span></span><br><span class="line">            <span class="keyword">return</span> showPic(<span class="keyword">this</span>)?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//键盘访问</span></span><br><span class="line">        links[i].onkeypress = links[i].onclick;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 检查点：确保当前浏览器能够执行正常运行DOM方法，如果无法使用则不执行此函数；</span><br><span class="line"><span class="number">2.</span> 定义变量，减少工作量；</span><br><span class="line"><span class="number">3.</span> 遍历处理links数组里的各个元素，用<span class="keyword">for</span>循环完成；</span><br><span class="line"><span class="number">4.</span> 通过onclick事件添加匿名函数，改变各个元素的行为；</span><br></pre></td></tr></table></figure>
<h3 id="2-2-共享onload事件"><a href="#2-2-共享onload事件" class="headerlink" title="2.2 共享onload事件"></a>2.2 共享onload事件</h3><p>如下面代码所示，页面上有两个（或更多）函数同时绑定在onload事件上，只有最后那个才能被实际执行；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = firstFunction;</span><br><span class="line"><span class="built_in">window</span>.onload = secondFunction;</span><br></pre></td></tr></table></figure></p>
<p>通过匿名函数可以容纳两个（或更多）函数,能够解决不能同时执行的问题，但是在需要绑定的函数有很多场合需要的时候，不能很好的工作（必须写在一起，而不能随时随地的执行）；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    firstFunction();</span><br><span class="line">    secondFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义一个函数共享onload事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLoadEvent</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>)&#123;</span><br><span class="line">		<span class="built_in">window</span>.onload = func;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			oldonload();</span><br><span class="line">			func();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">addLoadEvent(firstFunction);</span><br><span class="line">addLoadEvent(secondFunction);</span><br></pre></td></tr></table></figure></p>
<h2 id="3-不要做太多的假设"><a href="#3-不要做太多的假设" class="headerlink" title="3. 不要做太多的假设"></a>3. 不要做太多的假设</h2><p>修改showPic函数，需要对元素做检查<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPic</span>(<span class="params">whichpic</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">document</span>.getElementById(<span class="string">"placeholder"</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">var</span> source = whichpic.getAttribute(<span class="string">"href"</span>);	</span><br><span class="line">	<span class="keyword">var</span> placeholder = <span class="built_in">document</span>.getElementById(<span class="string">"placeholder"</span>);</span><br><span class="line">	placeholder.setAttribute(<span class="string">"src"</span>,source);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">document</span>.getElementById(<span class="string">"description"</span>))&#123;</span><br><span class="line">		<span class="keyword">var</span> text = whichpic.getAttribute(<span class="string">"title"</span>);</span><br><span class="line">		<span class="keyword">var</span> description = <span class="built_in">document</span>.getElementById(<span class="string">"description"</span>);		</span><br><span class="line">		description.firstChild.nodeValue = text;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查title属性是否存在</span></span><br><span class="line"><span class="keyword">var</span> text = whichpic.getAttribute(<span class="string">"title"</span>)?whichpic.getAttribute(<span class="string">"title"</span>):<span class="string">""</span>;</span><br><span class="line"><span class="comment">//检查图片是否存在</span></span><br><span class="line"><span class="keyword">if</span>(placeholder.nodeName != <span class="string">"IMG"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//检查是否是文本元素</span></span><br><span class="line"><span class="keyword">if</span>(description.firstChild.nodeType == <span class="number">3</span>)&#123;</span><br><span class="line">    description.firstChild.nodeValue = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-键盘访问"><a href="#5-键盘访问" class="headerlink" title="5. 键盘访问"></a>5. 键盘访问</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> links[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> showPic(<span class="keyword">this</span>)?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> links[i].onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> showPic(<span class="keyword">this</span>)?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码可以简化为</span></span><br><span class="line">links[i].onkeypress = links[i].onclick;</span><br></pre></td></tr></table></figure>
<h2 id="6-把JavaScript与CSS结合起来"><a href="#6-把JavaScript与CSS结合起来" class="headerlink" title="6. 把JavaScript与CSS结合起来"></a>6. 把JavaScript与CSS结合起来</h2><p>css引入外部文件</p>
<h2 id="7-DOM-Core和HTML-DOM"><a href="#7-DOM-Core和HTML-DOM" class="headerlink" title="7. DOM Core和HTML-DOM"></a>7. DOM Core和HTML-DOM</h2><p>getElementById、getElementsByTagName、getAttribute、setAttribute，这些方法都是DOM Core的组成部分，它们并不属于JavaScript，支持DOM的任何一种程序设计语言都可以使用它们，它们的用途并非仅限于处理网页，它们可以用来处理任何一种标记语言（如XML）编写出来的文档；<br>属性onclick属于HTML-DOM，HTML-DOM提供了许多描述各种HTML元素的属性，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(&quot;form&quot;)</span><br><span class="line">简化为：</span><br><span class="line">documents.forms</span><br><span class="line"></span><br><span class="line">element.getAttribute(&quot;src&quot;)</span><br><span class="line">简化为：</span><br><span class="line">element.src</span><br><span class="line"></span><br><span class="line">element.setAttribute(&quot;src&quot;,source)</span><br><span class="line">简化为：</span><br><span class="line">element.src = source;</span><br></pre></td></tr></table></figure></p>
<p>HTML-DOM代码通常会更短，但是它们只能用来处理Web文档；</p>
<h1 id="七、动态创建标记"><a href="#七、动态创建标记" class="headerlink" title="七、动态创建标记"></a>七、动态创建标记</h1><h2 id="1-一些传统的方法"><a href="#1-一些传统的方法" class="headerlink" title="1. 一些传统的方法"></a>1. 一些传统的方法</h2><p>document.write和innerHTML</p>
<ul>
<li>document.write最大的缺点是它违背了“行为应该与表现分离”的原则；通过document.write创建的文档容易导致验证错误；MIME类型applocation/xhtml+xml与document.write不兼容，浏览器在程序这种XHTML文档时根本不会执行document.write方法；</li>
<li>innerHTML属性不是W3C DOM标准的组成部分，不过已经包含在HTML5规范中，它可以用来读、写某给定元素的HTML内容；innerHTML只能进行赋值，如果被赋值的元素有内容，则会替换；innerHTML属性比document.write()方法耿直的推荐；innerHTML也是HTML专有属性，不能用于任何其他标记语言文档,这一点和document.write方法一样；(DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/test.html" target="_blank" rel="noopener">test.html</a>)</li>
</ul>
<h2 id="2-DOM方法"><a href="#2-DOM方法" class="headerlink" title="2.DOM方法"></a>2.DOM方法</h2><p>DOM是文档的表示，是一条双向车道；DOM不仅可以获取文档的内容，还可以更新文档的内容；在浏览器看来，DOM节点数才是文档；    </p>
<ul>
<li><code>document.createElement(nodeName)</code>用来创建元素节点；</li>
<li>把新创建的节点插入某个文档的节点数的最简单的方法是让它成为这个文档某个现有节点的一个子节点，可以使用<code>parent.appendChild(child)</code>来实现；</li>
<li><code>document.createTextNode(text)</code>用来创建一个文本节点；</li>
</ul>
<h2 id="3-重回图片库"><a href="#3-重回图片库" class="headerlink" title="3. 重回图片库"></a>3. 重回图片库</h2><h3 id="3-1-在已有元素前插入一个新元素"><a href="#3-1-在已有元素前插入一个新元素" class="headerlink" title="3.1 在已有元素前插入一个新元素"></a>3.1 在已有元素前插入一个新元素</h3><p>DOM提供了名为insertBefore()方法，这个方法把一个新元素插入到一个现有元素的前面，使用<code>parentElement.insertBefore(newElement,targetElement)</code>来调用，在调用此方法时，需要告诉它三件事：</p>
<ul>
<li>新目标：你想插入的元素（newElement）；</li>
<li>目标元素：你想把这个新元素插入到那个元素（targetElement）之前；</li>
<li>父元素：目标元素的父元素（parentElement）； </li>
</ul>
<p>我们不必搞清楚父元素到底是哪个，因为targetElement元素的parentNode属性值就是它，所以<code>parentElement</code>可以用<code>targetElement.parentNode</code>来替换；</p>
<h3 id="3-2-在现有方法后插入一个新元素"><a href="#3-2-在现有方法后插入一个新元素" class="headerlink" title="3.2 在现有方法后插入一个新元素"></a>3.2 在现有方法后插入一个新元素</h3><p>DOM没有提供现成的方法，需要进行编写；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先，函数有两个参数，一个是将被插入的新元素（newElement）,另一个是目标元素（targetElement）；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">insertAfter</span>(<span class="params">newElement,targetElement</span>)</span>&#123;</span><br><span class="line"><span class="comment">//把目标元素的parentNode属性值包含到变量parent里</span></span><br><span class="line">    <span class="keyword">var</span> parent = targetElement.parentNode;</span><br><span class="line"><span class="comment">//接下来，检查目标元素是不是parent的最后一个子元素，即比较parent元素的lastChild属性值与目标元素是否存在“等于”关系</span></span><br><span class="line">    <span class="keyword">if</span>(parent.lastChild == targetElement)&#123;</span><br><span class="line"><span class="comment">//如果是，就用appendChild方法把新元素追加到parent元素上，这样新元素就恰好被插入到目标元素之后</span></span><br><span class="line">        parent.appendChild(newElement);    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果不是，就把新元素插入到目标元素和目标元素的下一个兄弟元素之间；目标元素的下一个兄弟元素即目标元素的nextSibling属性；用insertBefore方法把新元素插入到目标元素大的下一个兄弟元素之前；</span></span><br><span class="line">        parent.insertBefore(newElement,targetElement.nextSibling);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面编写的函数用到了以下DOM方法和属性：parentNode属性、lastChild属性、appendChild方法、insertBefore方法、nextSibling属性；  </p>
<h2 id="4-Ajax"><a href="#4-Ajax" class="headerlink" title="4. Ajax"></a>4. Ajax</h2><p>Ajax的主要优势就是对页面的请求以异步的方式发送到服务器；Ajax依赖JavaScript；搜索引擎的蜘蛛程序也不会抓取到Ajax的有关内容；<br>Ajax技术的核心就是XMLHttpRequest对象，这个对象充当着浏览器中的脚本（客户端）与服务器之间的中间人的脚色；以往的请求都是有浏览器发出，而JavaScript通过这个对象可以自己发送请求，同事也自己处理响应；<br>不同的浏览器实现XMLHttpRequest对象的方式不太一样，为了保证跨浏览器，需要进行兼容性JavaScript代码编写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHTTPObject</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> XMLHttpRequest == <span class="string">"underfinde"</span>)</span><br><span class="line">        XMLHttpRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP.6.0"</span>);&#125;</span><br><span class="line">                <span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP.3.0"</span>);&#125;</span><br><span class="line">                <span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);&#125;</span><br><span class="line">                <span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>XMLHttpRequest对象有许多的方法，最有用的是open方法，它用来指定服务器上要访问的文档，请求指定类型：GET、POST和SEND，这个方法的第三个参数用来指定请求是否以异步的方式发送和处理；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNewContent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = getHTTPObeject();</span><br><span class="line">    <span class="keyword">if</span>(request)&#123;</span><br><span class="line">        request.open(<span class="string">"GET"</span>,<span class="string">"需要获取的文件url"</span>,<span class="literal">true</span>);</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(request.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="comment">//如果成功,执行此代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        request.send(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">"Sorry,your browser doesn\'t support XMLHttpRequest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">addLoadEvent(getNewContent);</span><br></pre></td></tr></table></figure></p>
<p>需要获取的文件url：这个可以使用绝对定位，也可以使用相对定位，如果不在同一个域名下面的话会出现跨域问题，只能获取相同域名下面的数据；有些浏览器会限制Ajax请求使用的协议；<br>服务器在向XMLHttpRequest对象发回响应时，该对象有多种属性可用，浏览器会在不同阶段更新readyState属性的值，它有5个可能的值：0表示未初始化，1表示正在加载，2表示加载完成，3表示正在交互，4表示完成；只要readyState属性的值变成了4，就可以访问服务器发送回来的数据了；<br>访问服务器发回来的数据要通过两个属性完成；一个是reponseText属性，这个属性用于保存文本字符串形式的数据；另一个属性是responseXML属性，用于保存Content-Type头部中指定为“text/xml”的数据，是其是一个DocumentFragment对象；<br>构建Ajax网站的最好方法，是先构建一个常规网站，然后Hijax（渐进增强地使用Ajax）它；<br>DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/ajax.html" target="_blank" rel="noopener">ajax.html</a></p>
<h1 id="八、充实文档的内容"><a href="#八、充实文档的内容" class="headerlink" title="八、充实文档的内容"></a>八、充实文档的内容</h1><h2 id="1-不应该做什么"><a href="#1-不应该做什么" class="headerlink" title="1. 不应该做什么"></a>1. 不应该做什么</h2><p>应该时刻牢记两项原则：渐进增强和平稳退化；不要通过JavaScript把重要的内容添加到网页上，这样一来JavaScript就没有任何空间去平稳退化了；</p>
<h2 id="2-把“不可见”变成“可见”"><a href="#2-把“不可见”变成“可见”" class="headerlink" title="2. 把“不可见”变成“可见”"></a>2. 把“不可见”变成“可见”</h2><p>绝大多数属性的内容（即属性值）在Web浏览器里都是不显示的，只有极少数属性例外，但不同的浏览器在呈现这些属性的时候却常常千态百姿；比如title属性和alt属性；</p>
<h2 id="3-内容"><a href="#3-内容" class="headerlink" title="3. 内容"></a>3. 内容</h2><ul>
<li>选用标记语言：使用HTML、XHTML、HTML5都可以，推荐使用HTML5，它的文档声明类型非常简单，并且向下兼容；</li>
<li>CSS：可以自定义CSS样式；</li>
<li>JavaScript：使用DOM改变浏览器的默认行为，比如让title属性集中显示；</li>
</ul>
<h2 id="4-显示“缩略语列表”（实例）"><a href="#4-显示“缩略语列表”（实例）" class="headerlink" title="4. 显示“缩略语列表”（实例）"></a>4. 显示“缩略语列表”（实例）</h2><p>实现方法:</p>
<ol>
<li>编写displayAbbreviations函数：遍历文档中的所有abbr元素，保存每个abbr元素的title属性及包含的文本；</li>
<li>创建标记：创建一个“定义列表”元素（dl）,遍历刚刚保存的title属性和abbr元素的文本；创建一个“定义标题”元素（dt），把abbr元素的文本插入到这个dt元素；创建一个“定义描述”元素（dd）,把title属性插入到这个dd元素；把dt元素追加到dl元素上，把dd元素追加到dl元素上；</li>
<li>添加到文档：把dl元素追加到文档的body元素上并检查兼容性；</li>
</ol>
<p>注意：低版本的IE浏览器（IE6及以前）不支持abbr元素，需要做到平稳退化；<br>显示“文献来源链接表”同上面的显示“缩略图列表”；<br>DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/explanation.html" target="_blank" rel="noopener">explanation.html</a></p>
<h1 id="九、CSS-DOM"><a href="#九、CSS-DOM" class="headerlink" title="九、CSS-DOM"></a>九、CSS-DOM</h1><h2 id="1-三位一体的页面"><a href="#1-三位一体的页面" class="headerlink" title="1. 三位一体的页面"></a>1. 三位一体的页面</h2><p>网页是有一下三层信息构成的一个共同体，并且进行分离：</p>
<ul>
<li>结构层：由HTML、XHTML或HTML5之类的标记语言负责创建；</li>
<li>表示层：由CSS负责完成，用来描述页面内容应该如何呈现；</li>
<li>行为层：负责内容应该如何相应事件这一问题，这是JavaScript语言和DOM主宰的领域；</li>
</ul>
<h2 id="2-style属性"><a href="#2-style属性" class="headerlink" title="2. style属性"></a>2. style属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">"example"</span> style=<span class="string">"color:grey;font-family:'Arial',sans-serif;"</span>&gt;An example <span class="keyword">of</span> a paragraph&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var para = document.getElementById("example);</span></span><br><span class="line"><span class="regexp">alert(typeof para.nodeName);/</span><span class="regexp">/返回字符串“string”</span></span><br><span class="line"><span class="regexp">alert(typeof para.style);/</span><span class="regexp">/返回字符串“object”</span></span><br><span class="line"><span class="regexp">alert("This color is"+ para.style.color);/</span><span class="regexp">/返回值“grey”</span></span><br><span class="line"><span class="regexp">alert("This font-family is"+ para.style.fontFamily);/</span><span class="regexp">/返回值“Arial',sans-serif”</span></span><br><span class="line"><span class="regexp">para.style.color = "black";/</span><span class="regexp">/设置样式</span></span><br></pre></td></tr></table></figure>
<p>不管css样式属性的名字有多少个连字符，DOM一律采用驼峰命名法来表示它们；<br>style属性只能返回内嵌样式；<br>通过<code>element.style.property=value</code>设置样式；<br>DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/example.html" target="_blank" rel="noopener">example.html</a></p>
<h2 id="3-何时该用DOM脚本设置样式"><a href="#3-何时该用DOM脚本设置样式" class="headerlink" title="3. 何时该用DOM脚本设置样式"></a>3. 何时该用DOM脚本设置样式</h2><ul>
<li>根据元素在节点树里的位置来设置样式：遍历所有的h1（可以是其它元素）元素，把当前h1元素的下一个节点找出来，把这个选择的节点进行赋值；</li>
<li>根据某种条件反复设置某种样式：遍历所有的table元素，对每个table元素创建odd变量并把它初始化为false；遍历这个表格的所有数据行；如果变量odd的值为true，设置样式并把odd变量修改为false；如果变量odd的值为false，设置样式并把odd变量修改为true；</li>
<li>响应事件：类似:hover实现的效果，通过JavaScript实现；在这一类场合，需要利用DOM设置样式还是采用纯粹的CSS来解决需要考虑一下因素：①这个问题最简单的解决方案是什么；②哪种解决方案会得到更多的浏览器支持；<br>DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/story.html" target="_blank" rel="noopener">story.html</a> / <a href="http://oboiq86te.bkt.clouddn.com/gellery/itinerary.html" target="_blank" rel="noopener">itinerary.html</a></li>
</ul>
<h2 id="4-className属性"><a href="#4-className属性" class="headerlink" title="4. className属性"></a>4. className属性</h2><p>通过<code>elem.className = name</code>设置某个元素的class样式，但这样是替换（而不是追加）该元素原有的class样式；<br>通过<code>elem.className += name</code>可以利用字符串拼接操作，把新的class设置追加到className属性上去（主要name的一个字符是空格，比如” intro”）,但只有在原来确实有一个class的情况下才能这么做；<br>在需要给一个元素追加新的class时，可以按照以下步骤操作：<br>检查className属性的值是否为null；如果是，把新的class属性值直接赋值给className属性；如果不是，把一个空格和新的class设置值追加到className属性上去；</p>
<p>把函数进行抽象，能够使一个非常具体的东西改进为一个较为通用的东西；</p>
<h1 id="十、用JavaScript实现动画效果"><a href="#十、用JavaScript实现动画效果" class="headerlink" title="十、用JavaScript实现动画效果"></a>十、用JavaScript实现动画效果</h1><h2 id="1-动画基础知识"><a href="#1-动画基础知识" class="headerlink" title="1. 动画基础知识"></a>1. 动画基础知识</h2><ul>
<li>位置：通过设置position、left、top等值进行定位；</li>
<li>时间：setTimeout能够让某个函数在经过一定预定的时间之后才开始执行<code>var variable = setTimeout(&quot;function&quot;,interval)</code>；想要取消某个正在排队等待执行的函数，必须事先把setTimeout函数的返回值赋值给一个变量<code>clearTimeout(variable)</code>；</li>
<li>时间递增量：让元素的移动等以渐变的方式发生：①获取元素的当前位置；②如果元素已经到达目的地，则退出这个函数；如果元素尚未到达目的地，则把它向目的地移近一点；④经过一段时间间隔之后从步骤①开始重复上述步骤；</li>
<li>抽象：把一个只能完成一下非常特定任务的函数改成一个能够通用的函数，这就是抽象了，比如把一些常量变为变量；<br>DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/message.html" target="_blank" rel="noopener">message.html</a><br>DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/list.html" target="_blank" rel="noopener">list.html</a></li>
</ul>
<h1 id="十一、HTML5"><a href="#十一、HTML5" class="headerlink" title="十一、HTML5"></a>十一、HTML5</h1><h2 id="1-HTML5简介"><a href="#1-HTML5简介" class="headerlink" title="1. HTML5简介"></a>1. HTML5简介</h2><p>结构层、样式层和行为层共同构成了一个网页，共同组成了HTML5；   </p>
<ul>
<li>在结构层，HTML5添加了新的标记元素，如<code>&lt;section&gt;、&lt;article&gt;、&lt;header&gt;、&lt;footer&gt;</code>；HTML5还提供了更多交互及媒体元素，例如<code>&lt;canvas&gt;、&lt;audio&gt;、&lt;video&gt;</code>；表单得到了加强，新增了颜色拾取器、数据拾取器、滑动条和进度条；(DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/canvas.html" target="_blank" rel="noopener">canvas.html</a> / <a href="http://oboiq86te.bkt.clouddn.com/gellery/grayscale.html" target="_blank" rel="noopener">grayscale.html</a>)</li>
<li>在行为层，HTML5规定了DOM中每个元素的交互方式，以及新的API；新JavaScript API还包含其他很多模块，比如Geolocation、Storage、Drap-and-Drop、Socket以及多线程等；(DEMO:<a href="http://oboiq86te.bkt.clouddn.com/gellery/movie.html" target="_blank" rel="noopener">movie.html</a>)</li>
<li>在表现层，CSS3的多个模块囊括了高级选择器、渐变、变换，还有动画；</li>
</ul>
<h2 id="2-来做朋友的忠告"><a href="#2-来做朋友的忠告" class="headerlink" title="2. 来做朋友的忠告"></a>2. 来做朋友的忠告</h2><p>Modernizr是一个开源的JavaScript库，利用它的富特性检测功能，可以对HTML5文档进行更好的控制；<br>HTML5在低版本的浏览器上支持不好，需要进行降级处理，平稳退化；HTML5需要Safari 5+、Chrome 6+、Mozilla Firefox 3.6+、Opera 10.6+、IE 9+；</p>
<h2 id="3-几个示例"><a href="#3-几个示例" class="headerlink" title="3. 几个示例"></a>3. 几个示例</h2><ul>
<li>Canvas：可以动态创建和操作图形图像；</li>
<li>video和audio：视频和音频，对于视频格式的支持有点问，目前主要有Ogg、MP4、WebM等格式；可以进行自定义控件；</li>
<li>表单：HTML5中新的输入类型包括email、url、date、number、range、search、tel、color等；HTML5中新增的表单属性包括autocomplete、autofocus、form、min、max、step、pattern、placeholder、required等；需要对浏览器进行兼容性测试；</li>
</ul>
<h1 id="十三、JavaScript库"><a href="#十三、JavaScript库" class="headerlink" title="十三、JavaScript库"></a>十三、JavaScript库</h1><p>库（就是可重用的代码包）的优点：</p>
<ul>
<li>库代码应该大量用户的测试和验证；</li>
<li>库能够很容易地与已有的开发框架集成；</li>
<li>库为大多数日常琐碎的DOM编程工作提供了方便、简洁的方案，每个函数都能节省很多代码；</li>
<li>库很好的解决了跨浏览器的问题，更省心；<br>库的缺点：</li>
<li>库是别人编写的，自己可能不了解内部工作机制，因此很难调试bug或解决由它所导致的问题；</li>
<li>要使用库，就要把它集成在脚本中，这样会加重页面加载的负担，挤占用户的宽带；</li>
<li>混合使用多个库可能导致冲突，同时造成功能浪费；</li>
</ul>
<h2 id="1-选择合适的库："><a href="#1-选择合适的库：" class="headerlink" title="1.选择合适的库："></a>1.选择合适的库：</h2><ul>
<li>它具备你需要的所有的功能吗？</li>
<li>它的功能是否比你想要的还多？</li>
<li>它是模块化的吗？</li>
<li>它的支持情况怎么样？</li>
<li>它有文档吗？</li>
<li>它的许可合适吗？</li>
</ul>
<h3 id="1-1-有代表性的库"><a href="#1-1-有代表性的库" class="headerlink" title="1-1.有代表性的库"></a>1-1.有代表性的库</h3><ul>
<li>JQuery</li>
<li>Prototype</li>
<li>YUI</li>
<li>Dojo</li>
<li>MooTools</li>
</ul>
<h3 id="1-2-内容分发网络（CDN）"><a href="#1-2-内容分发网络（CDN）" class="headerlink" title="1-2.内容分发网络（CDN）"></a>1-2.内容分发网络（CDN）</h3><ul>
<li>它解决分布共享库的问题；</li>
<li>Google、baidu等提供了免费的CDN服务；</li>
<li>为了保险起见，可以提供一个后背<script>标签，以便在CDN不可用时从本地服务器下载相应文件；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;!<span class="built_in">window</span>.jQuery &amp;&amp; <span class="built_in">document</span>.write(unscape(<span class="string">'%3C script src="文件路径"%3E%3C/script%3E'</span>))&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2.语法"></a>2.语法</h2><ul>
<li>JQuery等许多库，把$()函数作为其选择器方法的缩写；</li>
<li>方法连缀：多数库都支持以点将方法连缀起来的语法，也就是通过点操作符把多个方法调用连接成一行；</li>
<li>迭代</li>
</ul>
<h2 id="3-选择元素"><a href="#3-选择元素" class="headerlink" title="3.选择元素"></a>3.选择元素</h2><ul>
<li>CSS选择器</li>
<li>库所提供的专有选择器</li>
<li>使用回调函数筛选</li>
</ul>
<h2 id="4-操作DOM元素"><a href="#4-操作DOM元素" class="headerlink" title="4.操作DOM元素"></a>4.操作DOM元素</h2><ul>
<li>生成内容</li>
<li>操作内容</li>
</ul>
<h2 id="5-处理事件"><a href="#5-处理事件" class="headerlink" title="5.处理事件"></a>5.处理事件</h2><ul>
<li>加载事件</li>
<li>其它事件</li>
</ul>
<h2 id="6-Ajax"><a href="#6-Ajax" class="headerlink" title="6.Ajax"></a>6.Ajax</h2><ul>
<li>$.post(url,params,callback)</li>
<li>$.get(url,params,callback)</li>
<li>$.getJSON(url,params,callback)</li>
<li>$.getScript(url,params,callback)</li>
<li>$(expression).load(url,params,callback)</li>
</ul>
<h2 id="7-动画和效果"><a href="#7-动画和效果" class="headerlink" title="7.动画和效果"></a>7.动画和效果</h2><ul>
<li>基于CSS属性的动画（animate）</li>
<li>组合动画</li>
<li>注意可访问性</li>
</ul>
</script></li></ul>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【教程】git学习]]></title>
      <url>https://dudujie0915.github.io/2016/07/28/git%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p>
<h2 id="1-Git的诞生"><a href="#1-Git的诞生" class="headerlink" title="1. Git的诞生"></a>1. Git的诞生</h2><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！<br>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。<br><a id="more"></a></p>
<h2 id="2-集中式vs分布式"><a href="#2-集中式vs分布式" class="headerlink" title="2. 集中式vs分布式"></a>2. 集中式vs分布式</h2><p>中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。<br>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<h1 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h1><p><strong>在Windows上安装Git：</strong><a href="http://pan.baidu.com/s/1skFLrMt#path=%252Fpub%252Fgit" target="_blank" rel="noopener">下载地址</a><br>安装完成后，还需要最后一步设置，在命令行输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>
<h1 id="三、创建版本库"><a href="#三、创建版本库" class="headerlink" title="三、创建版本库"></a>三、创建版本库</h1><p>版本库又名仓库（repository），可简单理解为一个目录，这个目录里的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都能追踪历史，或者在将来某个时刻可以“还原”。  </p>
<h2 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1. 创建版本库"></a>1. 创建版本库</h2><p>①创建一个空目录，自己选择合适的地方；<br><strong>使用windows系统，为了避免各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文；</strong><br>②通过命令<code>git init</code>把目录变成可以管理的仓库；<br>可以通过命令<code>git init file</code>创建一个文件夹并把这个文件夹变成Git可以管理的仓库；<br>上面创建的是一个空的仓库（empty Git repository），此目录下有个<code>.git</code>的目录，这个目录是用了跟踪管理版本库的，谨慎修改；如果为看到此目录，使用<code>ls -ah</code>命令可以使默认隐藏的目录显示出来；  </p>
<h2 id="2-把文件添加到版本库"><a href="#2-把文件添加到版本库" class="headerlink" title="2. 把文件添加到版本库"></a>2. 把文件添加到版本库</h2><p>所以的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，程序代码等，都能明确地知道每次的改动内容；而图片，视频这些二进制文件，虽然能通过版本控制系统管理，但是没法跟踪文件的变化，只能把二进制文件每次改动串起来，例如图片从100k变为120k，但是到底改了什么，版本控制系统不知道，也没法知道；<br><strong>文本是有编码的，强烈建议使用标准的UTF-8，所有语言使用同一种编码，既没有冲突，又被所有平台所支持；</strong><br><strong>windows系统中，不要使用自带的记事本！！！</strong><br>①创建一个文件，并放在Git仓库的目录下（子目录也行）；<br>②用命令<code>git add</code>把文件添加到仓库；执行完成后，无任何显示，说明添加成功；<br>③用命令<code>git commit</code>把文件提交到仓库；一般使用<code>git commit -m &quot;xxx&quot;</code>的方式提交，<code>-m</code>后面输入的是本地提交的说明，最好是有意义的，这样可以从历史记录中方便地找到改动记录；    </p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>初始话一个Git仓库，使用<code>git init</code>命令；<br>添加文件到Git仓库，分两步：</p>
<ul>
<li>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>第二步，使用命令<code>git commit</code>，完成。<h1 id="四、时光穿梭机"><a href="#四、时光穿梭机" class="headerlink" title="四、时光穿梭机"></a>四、时光穿梭机</h1></li>
<li>命令<code>git status</code>使我们时刻掌握仓库当前的状态；  </li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容；<h2 id="1-版本回退"><a href="#1-版本回退" class="headerlink" title="1. 版本回退"></a>1. 版本回退</h2>使用<code>git log</code>命令查看历史记录；如果感觉内容太多，可以使用<code>git log --pretty=oneline</code>命令；<br><code>git log</code>命令可以看到一大串的字符是<code>commit id</code>（版本号）；<br>回退到上一个版本，首先，Git必须知道是当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本用<code>HEAD^</code>表示，上上一个版本就是<code>HEAD^^</code>，往上100个版本就写<code>HEAD~100</code>;<br>版本回退使用<code>git reset</code>命名，回到上一个版本用命令<code>git reset --hard HEAD^</code>;<br>想回到未来的某个版本：如果命令窗口未关闭，可以找到想回到的未来版本的<code>commit id</code>,使用命令<code>git reset --hard commit id</code>;如果命令窗口关闭，那么可以使用命令<code>git reflog</code>查看自己的每一次命令，找到要回到的未来版本的<code>commit id</code>,使用命令<code>git reset --hard commit id</code>；<h2 id="2-工作区和暂存区"><a href="#2-工作区和暂存区" class="headerlink" title="2. 工作区和暂存区"></a>2. 工作区和暂存区</h2>工作区（Working Directory）：在自己的电脑里能看到的目录；<br>版本库（Repository）：工作区有一个隐藏目录<code>.git</code>，这个是Git的版本库；Git版本库里最重要的是stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<br><code>git add</code>把文件添加进去，实际上把文件修改添加到暂存区；<br><code>git commit</code>提交修改，实际上把暂存区的所有内容提交到当前分支；<h2 id="3-管理修改"><a href="#3-管理修改" class="headerlink" title="3. 管理修改"></a>3. 管理修改</h2>Git跟踪并管理的是修改，并非文件；<br>如果暂存区和工作区存在差异，那么通过<code>git diff HEAD --file</code>查看差异；<br>提交文件的时候，可以把多次提交到暂存区的文件一次提交到HEAD里面；<h2 id="4-撤销修改"><a href="#4-撤销修改" class="headerlink" title="4. 撤销修改"></a>4. 撤销修改</h2>①当自己改乱了工作区的每个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>;<br>②当自己不但改乱了某个文件的内容，还添加到了缓存区，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>,就回到了①，第二版按①操作；<br>③已经提交了不合适的修改到版本库时，想要撤销本次修改，版本回退（前提是没有推送到远程库）；<h2 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5.删除文件"></a>5.删除文件</h2>在Git中，删除也是一个修改操作；<br>一般情况下，通常直接在文件管理器中把没用的文件删了，或者是用<code>rm</code>命令删了；<br>如果确实要从版本库中删除该文件，那就用命令<code>git rm file</code>删掉，并且<code>git commit</code>，现在文件从版本中被删除了  ；<br>如果是删错了，因为版本库里还有，所有可以轻松的把误删的文件恢复到最新版本，使用命令<code>git checkout -- flie</code>;<br><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”；<br>命令<code>git rm</code>用于删除一个文件；如果一个文件已经被提交到版本库，那么不用担心误删，但是要小心，只能恢复到最新版本，会丢失最近一次提交后修改的内容；  <h1 id="五、远程仓库"><a href="#五、远程仓库" class="headerlink" title="五、远程仓库"></a>五、远程仓库</h1><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>提供Git仓库托管服务，只需要注册帐号，就能免费获得Git远程仓库；  </li>
</ul>
<ol>
<li>创建SSH Key：在用户主目录下，如果有.ssh目录，并且目录下面有<code>id_rsa</code>(这个是私钥，不能泄漏)和<code>id_rsa.pub</code>（这个是公钥，可以放心的告诉任何人）这两个文件直接跳到下一步；如果没有，打开Git Bash（window下），用命令<code>ssh-keygen -t rsa -C &quot;your email@example.com&quot;</code>创建；</li>
<li>登录GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的Key；<h2 id="1-添加到远程仓库"><a href="#1-添加到远程仓库" class="headerlink" title="1. 添加到远程仓库"></a>1. 添加到远程仓库</h2>现在是本地已经创建了一个Git仓库后，又想在GitHub上创建一个Git仓库，并且让两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让他人通过该仓库来协作；<br>①登录GitHub，在右上角找到“New repository”按钮，创建一个新的仓库，在Repository name填上名称，其他保持默认设置，点击“Create Repository”按钮，就成功创建一个新的Git仓库；<br>②此时，GitHub上的这个仓库还是空的，我们把本地的仓库通过命令<code>git remote add origin git@server-name:path/repo-name.git</code>和远程库连接起来，用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；<br>③此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；<h2 id="2-从远程仓库克隆"><a href="#2-从远程仓库克隆" class="headerlink" title="2. 从远程仓库克隆"></a>2. 从远程仓库克隆</h2>假设从零开始，那么最好的方法是先创建远程库，然后从远程库克隆；<br>①首先，登录GitHub，创建一个新的仓库，名称自定义；勾选<code>Initialize this repository with a README</code>,这样GitHub会自动为我们创建一个README.md文件，创建完成后，可以直接看到；<br>②现在远程库已经准备好了，下一步用命令 <code>git clone 远程库地址</code> 克隆一个本地库；  </li>
</ol>
<p>Git支持多种协议，默认的<code>git://</code>（速度最快）使用ssh，也可以使用<code>https</code>（速度慢，最大的麻烦是每次推送都必须输入口令，但在某些只开放http端口的公司内部只能使用次协议）等协议；</p>
<h1 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h1><h2 id="1-创建与合并分支"><a href="#1-创建与合并分支" class="headerlink" title="1. 创建与合并分支"></a>1. 创建与合并分支</h2><p>每次提交，Git把它们串成一条时间线，这条时间线就是一个分支；到目前为止，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支；<code>HEAD</code>严格来说并不是指向提交，而是指向<code>master</code>，<code>master</code>才指向提交，所以<code>HEAD</code>指向的就是当前分支；<br>①一开始，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，在用<code>HEAD</code>指向<code>master</code>，就能确定当前分支及当前分支的提交点，每次提交，<code>master</code>分支就会向前移动一步，这样随着自己不断提交，<code>master</code>分支的线越来越长；<br>②当我们创建新的分支，例如<code>dev</code>时，Git新建一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上（Git创建分支除了增加一个指针，改改<code>HEAD</code>的指向，工作区的文件没有任何变化！）；<br>③从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针向前移动一步，而<code>master</code>指针不变；假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上，最简单的方法就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并（合并分支只是改变指针，工作区内容无变化！）；   </p>
<h2 id="④合并完成后，甚至可以删除dev分支，删除dev分支就是把dev指针给删掉，删掉后，我们就剩下一条master分支；"><a href="#④合并完成后，甚至可以删除dev分支，删除dev分支就是把dev指针给删掉，删掉后，我们就剩下一条master分支；" class="headerlink" title="④合并完成后，甚至可以删除dev分支，删除dev分支就是把dev指针给删掉，删掉后，我们就剩下一条master分支；  "></a>④合并完成后，甚至可以删除<code>dev</code>分支，删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下一条<code>master</code>分支；  </h2><p>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code>   </p>
<h2 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2. 解决冲突"></a>2. 解决冲突</h2><p>如果两个分支都有提交新内容，并且新内容为一个地方，那么会产生冲突，此时Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，此时，必须手动解决冲突后再提交，通过<code>git status</code>可以告诉我们冲突的文件，直接修改冲突文件，再提交，此时冲突解决；<br>用带参数的<code>git log</code>可以看到分支合并情况：<code>git log --graph --pretty=oneline --abbrev-commit</code>;<br>最后删除分支;</p>
<h2 id="3-分支管理策略"><a href="#3-分支管理策略" class="headerlink" title="3. 分支管理策略"></a>3. 分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>（快速合并）模式，但这种模式下，删除分支后，会丢掉分支信息；  如果要强制禁用<code>Fast forward</code>模式，Git会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息；<br>合并分支的时候，使用命令<code>git merge --no-ff -m &quot;合并记录&quot; &lt;name&gt;</code>，表示禁用<code>Fasr forward</code>模式，用<code>git log</code>可以查看分支历史；<br><strong>在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>
<ol>
<li>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>
<li>干活都在<code>dev</code>分支上，<code>dev</code>分支是不稳定的，到每个时候，发布版本时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支上发布版本； </li>
<li>多人合作时，每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时的往<code>dev</code>分支上合并就可以了；</li>
</ol>
<hr>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做个合并；</p>
<h2 id="4-Bug分支"><a href="#4-Bug分支" class="headerlink" title="4. Bug分支"></a>4. Bug分支</h2><p>在Git中，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除；<br>接到一个bug时，我们想创建一个分支 <code>issue-1</code>来修复它，但是当前正在<code>dev</code>上进行的公司还没有提交（工作进行到一半，无法提交），Git提供了一个<code>stash</code>功能，可以把当前工作现场“存储”起来，等修改完成后可恢复现场后继续工作，使用命令<code>git stash</code>进行存储，此时用<code>git status</code>查看工作区，是干净的（除非有没有被Git管理的文件），此时可以放心的创建分支来修改bug；<br>首先确定在那个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支，然后修复bug，合并分支，删除临时分支<code>issue-1</code>；<br>现在接着回到<code>dev</code>分支上干活，用命令<code>git stash list</code>查看隐藏起来的内容，现在有两种方法恢复：①用<code>git stash apply</code>恢复，但是恢复后stash内容并未删除，需要用<code>git stash drop</code>来删除；②用<code>git stash pop</code>,恢复内容的同时把stash内容也删了； 用命令<code>git stash list</code>查看，此时为空；<br>可以多次stach，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令<code>git stash apply stash@{0}</code>;</p>
<h2 id="5-Feature"><a href="#5-Feature" class="headerlink" title="5. Feature"></a>5. Feature</h2><p>添加一个新功能时，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支；<br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除；</p>
<h2 id="6-多人协作"><a href="#6-多人协作" class="headerlink" title="6. 多人协作"></a>6. 多人协作</h2><p>当从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是origin；<br>查看远程库的信息，用<code>git remote</code>，或者用<code>git remote -v</code>显示更详细的信息；  </p>
<ol>
<li>推送分支：<br>推送分支就是把该分支上的所有本地提交推送到远程库；推送时，要指定本地分支，这样Git就会把该分支推送带远程库对应的远程分支上，比如推送到master分支<code>git push origin master</code>，推送到dev分支<code>git push origin dev</code>;<br>但是并不是一定要把本地分支往远程推送，判读方法：   <ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修改bug，没必要推送到远程（除非老板要看修复的bug）；</li>
<li>feature分支是否推动到远程，取决与自己是否和小伙伴合作在上面开发； </li>
</ul>
</li>
<li>抓取分支：<br>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改；<br>当从远程库clone时，默认情况下，只能看到本地的<code>master</code>分支，要是需要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>和<code>dev</code>分支到本地，用命令<code>git checkout -b dev origin/dev</code>命令创建本地<code>dev</code>分支；<br>进行远程推送，如果失败，因为远程库的代码和自己试图推送的提交有冲突，解决办法是：先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后本地合并，解决冲突，在推送；<br><code>git pull</code>也失败了，原因是没有指定本地的<code>dev</code>分支和远程的<code>origin/dev</code>分支的链接，用命令<code>git branch --set-upstream dev origin/dev</code>设置链接，然后再pull；如果<code>git pull</code>成功，但是合并有冲突，需手动解决，解决后提交再push；<br>多人协作的工作模式通常是这样;<ul>
<li>首先，试图同过用<code>git push origin branch-name</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比自己的本地更新，需要先<code>git pull</code>试图合并（如果<code>git pull</code>提示”no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>）；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或解决掉冲突之后，再用<code>git push origin branch-name</code>推送就能成功；</li>
</ul>
</li>
<li>小结：</li>
</ol>
<ul>
<li>查看远程库信息，使用<code>git remote -v</code>;</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git push</code>抓去远程的新提交；</li>
<li>在本地创建和远程分支对应的分支,使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；- 建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，先处理冲突；<h1 id="七、标签管理"><a href="#七、标签管理" class="headerlink" title="七、标签管理"></a>七、标签管理</h1>在发布新本版时，通常现在版本库中打一个标签，这样就唯一确定了打标签时刻的版本，将来无论何时取某个标签的版本，就是把那个打标签的时刻的历史版本取出来，所以标签也是版本库的一个快照；GIt的标签虽然是版本库的快照，但其实它就是指向某个commit的指针；   <h2 id="1-创建标签"><a href="#1-创建标签" class="headerlink" title="1. 创建标签"></a>1. 创建标签</h2></li>
<li>切换到需要创建标签的分支上，通过命令<code>git tag &lt;name&gt;</code>可以打一个新标签（这个标签默认是打在最新提交的commit上的）；</li>
<li>通过命令<code>git tag</code>查看所有标签；</li>
<li>通过命令<code>git tag &lt;name&gt; commit id</code>可以在任意一次提交的信息上打上标签；</li>
<li>标签不是按照时间顺序列出，而是按字母排序的；</li>
<li>可以用<code>git show &lt;name&gt;</code>查看标签信息；可以创建带有说明的标签，用命令<code>git tag -a &lt;tagname&gt; -m &quot;解释文字&quot; commit id</code>；</li>
<li>可以通过命令<code>git tag -s &lt;tagname&gt; - m &quot;解释文字&quot; commit id</code>用私密签名一个标签（签名采用PGP签名，因此首先安装gpg（GnuPG）,如果没有找到gpg，或者没有gpg密钥对，就会报错，如果报错，请参考GnuPG帮助文档配置Key）；<h2 id="2-操作标签"><a href="#2-操作标签" class="headerlink" title="2. 操作标签"></a>2. 操作标签</h2></li>
<li>如果标签打错了，用命令<code>git tag -d &lt;tagname&gt;</code>删除；</li>
<li>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>；</li>
<li>如果一次推送所有标签到远程，使用命令<code>git  push origin --tags</code>；</li>
<li>删除已经推送到远程的标签，先用命令<code>git tag -d &lt;tagname&gt;</code>从本地删除,然后用命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>从远程删除（要查看是否真的从远程库删除了标签，可以登录GitHub查看）；<h1 id="八、使用GitHub"><a href="#八、使用GitHub" class="headerlink" title="八、使用GitHub"></a>八、使用GitHub</h1></li>
<li>如何克隆别人的项目：Fork；</li>
<li>如何把项目拉取到本地，使用命令`git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:用户名/项目名.git（一定要从自己的帐号下clone仓库，这样才能推送修改）；</li>
<li>如果想修改别人的项目，需要在GitHub上发起一个pull request；<h1 id="九、自定义Git"><a href="#九、自定义Git" class="headerlink" title="九、自定义Git"></a>九、自定义Git</h1>Git显示不同的颜色<code>git config --gobal color.ui true</code>;    <h2 id="1-忽略特殊文件"><a href="#1-忽略特殊文件" class="headerlink" title="1. 忽略特殊文件"></a>1. 忽略特殊文件</h2>某些时候，必须把某些文件放到Git工作目录中，但又不能提交他们，比如保存了数据库密码的配置文件等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这限额文件；GitHub为我们准备了各种配置文件，只需要组合一下就可以使用了；<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a><br>忽略文件的原则是：</li>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另外一个文件自动生成的，那自动生成的文件没必要放进版本库，比如jaca编译产生的.class文件；</li>
<li>忽略自己的带有敏感信息的配置文件，比如存放口令的配置文件；</li>
</ul>
<hr>
<p><strong>小结：</strong></p>
<ul>
<li>忽略某些文件时，需要编写<code>,gitignore</code>;</li>
<li><code>.gitignore</code>文件本身要放在版本库里，并且可以对<code>.gitignore</code>做版本管理；<h2 id="2-配置别名"><a href="#2-配置别名" class="headerlink" title="2.配置别名"></a>2.配置别名</h2><code>git config --global alias.st status</code>等；<br>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用；<br>每个仓库的Git配置文件都放在<code>.git/config</code>文件里；<br>别名在[alias]后面，要删除别名，直接把对应的行删掉就行；<br>当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中；   <h2 id="3-搭建Git服务器"><a href="#3-搭建Git服务器" class="headerlink" title="3. 搭建Git服务器"></a>3. 搭建Git服务器</h2>省略…<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">git命令   任何操作都需要以 git 命令为开头</span><br><span class="line">本地操作：</span><br><span class="line">git init  初始化一个本地仓库  新建为 master主分支</span><br><span class="line">git status  查看当前分支状态</span><br><span class="line">git add  &lt;文件名&gt;   将文件更改添加到分支状态中 相当于文件等待被提交</span><br><span class="line">git commit -m &lt;&quot;描述信息&quot;&gt;  提交并添加描述信息</span><br><span class="line">git branch  查看分支   前面带*号的为当前所在分支</span><br><span class="line">git branch &lt;分支名称&gt;  新建分支</span><br><span class="line">git checkout &lt;分支名&gt;  切换分支</span><br><span class="line">git checkout -b &lt;分支名&gt;  新建分支并切换到此分支</span><br><span class="line">git merge &lt;分支名&gt;   将指定分支名合并到当前分支  一般为切换到主分支使用此命令</span><br><span class="line">git merge --no-ff -m &quot;提交描述&quot; &lt;分支名&gt;   合并分支并提交</span><br><span class="line">git branch -d &lt;分支名&gt;  有新建分支，那肯定有删除分支，假如这个分支新建错了，或者a分支的代码已经顺利合并到 master 分支来了，那么a分支没用了，需要删除，这个时候执行 git branch -d a 就可以把a分支删除了</span><br><span class="line">git branch -D &lt;分支名&gt;  强制删除分支，不管分支是否有未提交合并的代码</span><br><span class="line"></span><br><span class="line">git tag 查看所有标签</span><br><span class="line">git tag &lt;标签名&gt; 在当前状态下新建一个标签，可用来当作版本号使用</span><br><span class="line">git tag -a &lt;标签名称&gt; -m &lt;&quot;标签描述&quot;&gt; &lt;提交id&gt;  在指定的提交状态下新建一个标签</span><br><span class="line">git show &lt;标签名称&gt;   查看标签的详情</span><br><span class="line">git tag -d &lt;标签名&gt; 删除标签</span><br><span class="line">git push origin &lt;标签名&gt;   推送标签到远程仓库</span><br><span class="line">git push origin --tags  推送所有未推送的标签</span><br><span class="line">git push origin :refs/tags/&lt;标签名&gt;   删除远程标签，本地要先删除后才可以</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git checkout &lt;标签名&gt; 切换到标签名指定的状态</span><br><span class="line">git diff &lt;文件名&gt; 查看文件修改内容</span><br><span class="line"></span><br><span class="line">git log      查看提交日志   --pretty=oneline  此参数减少输出信息  穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</span><br><span class="line">git reflog   要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit   查看分支合并图</span><br><span class="line">git reset --hard &lt;HEAD^||提交ID&gt; 穿梭到指定提交版本</span><br><span class="line">HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</span><br><span class="line"></span><br><span class="line">git checkout -- &lt;文件名&gt;  将指定的文件恢复到最近一次 commit或add操作时候的状态</span><br><span class="line">git reset HEAD &lt;文件名&gt;   将指定的文件从暂存区的修改撤销掉（unstage），重新放回工作区</span><br><span class="line">git rm &lt;文件名&gt;		 删除指定的文件</span><br><span class="line"></span><br><span class="line">git stash  把当前工作现场“储藏”起来，等以后恢复现场后继续工作</span><br><span class="line">git stash list 查看暂存状态</span><br><span class="line">git stash apply 恢复暂存状态</span><br><span class="line">git stash drop  删除暂存状态</span><br><span class="line">git stash pop   恢复并删除暂存状态</span><br><span class="line">git stash apply &lt;stash@&#123;0&#125;&gt;  恢复指定的暂存状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">远征仓库操作:</span><br><span class="line">git clone &lt;远程地址&gt;  从远征仓库拷贝过来代码，相当于建立本地分支</span><br><span class="line">git pull 将最新的提交从远程仓库抓取下来</span><br><span class="line">git push  将本地修改后的代码提交到远程仓库</span><br><span class="line">git push &lt;远程仓库名，默认origin&gt; &lt;本地分支名&gt;  将指定的分支推送到远程分支上</span><br><span class="line"></span><br><span class="line">git remote -v 查看远程仓库  -v 为详细信息</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;本地支分支名&gt; &lt;远程仓库名，默认origin&gt;/&lt;远程支分支名&gt; 拉取远程主分支下的支分支。。。</span><br><span class="line">git branch --set-upstream &lt;本地支分支名&gt; &lt;远程仓库名，默认origin&gt;/&lt;远程支分支名&gt;  将本地分支与远程指定的分支关联起来</span><br><span class="line"></span><br><span class="line">//以下为先有本地库，再建立远程库操作所用的命令</span><br><span class="line">git remote add origin &lt;URL地址&gt; 本地库与远征库关联</span><br><span class="line">git push -u origin master 关联后，使用命令第一次推送master分支的所有内容，   -u参数为推送当前分支所有内容</span><br><span class="line"></span><br><span class="line">cat &lt;file&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器]]></title>
      <url>https://dudujie0915.github.io/2016/07/21/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="浏览器内核大全"><a href="#浏览器内核大全" class="headerlink" title="浏览器内核大全"></a>浏览器内核大全</h1><p>根据浏览器内核分门别类,目前浏览器市场上主要有三个内核分类，主要是IE的Trident内核，Mozilla FireFox的Gecko内核和Chrome/safarid的Webkit内核；  </p>
<h2 id="Trident内核"><a href="#Trident内核" class="headerlink" title="Trident内核"></a>Trident内核</h2><ol>
<li>常见Trident内核浏览器：主要是IE浏览器使用，最高版本为IE11，目前IE7/8/9/10/11仍在使用，低版本的IE是产生PC兼容性问题的主要浏览器；目前国内的一些双核浏览器也会使用此内核，比如360安全浏览器等；<img src="/images/trident.jpg" alt="trident"></li>
<li>Edge内核浏览器：目前只在win10上面的Microsift Edge浏览器使用，Edge是Trident的一个分支；</li>
<li>其它Trident内核浏览器：目前使用者非常少，不做考虑；<a id="more"></a>
<h2 id="Gecko内核"><a href="#Gecko内核" class="headerlink" title="Gecko内核"></a>Gecko内核</h2>Mozilla Firefox浏览器使用此内核，还有其它一些小众浏览器使用； </li>
</ol>
<h2 id="Blink-Chromium内核和Webkit内核"><a href="#Blink-Chromium内核和Webkit内核" class="headerlink" title="Blink/Chromium内核和Webkit内核"></a>Blink/Chromium内核和Webkit内核</h2><ol>
<li>基于Blink/Chromium的单核浏览器：最主要的是Chrome浏览器，此外还有Chromium浏览器、Vivaldi浏览器、旗鱼浏览器、新版本的Opera浏览器等（解释：谷歌Chrome/Chromium浏览器从08年创始至今一直使用苹果公司的WebKit作为浏览器内核原型，是WebKit的一个分支，我们可以称之为Chromium引擎；13年发布的Chrome 28.0.1469.0版本开始，Chrome放弃Chromium引擎转而使用最新的Blink引擎（基于WebKit2——苹果公司于2010年推出的新的WebKit引擎）；）；</li>
<li>基于Webkit的浏览器： 主要是Safari浏览器，此外还有遨游云浏览器等（解释：Webkit内核在2010年4月由苹果公司升级引擎为Webkit2）；</li>
<li>国内Trident与Chromium双核浏览器：搜狗浏览器、360急速浏览器、百度浏览器、猎豹浏览器、2345智能浏览器、UC浏览器电脑版等;   </li>
</ol>
<h2 id="Presto内核"><a href="#Presto内核" class="headerlink" title="Presto内核"></a>Presto内核</h2><p>Opera浏览器的7-12版本使用，目前不再使用；   </p>
<p><strong><a href="http://liulanmi.com/" target="_blank" rel="noopener">浏览迷</a>对浏览器内核有详细介绍，并且实时更新浏览器的最新消息</strong></p>
<h1 id="浏览器市场现状"><a href="#浏览器市场现状" class="headerlink" title="浏览器市场现状"></a>浏览器市场现状</h1><p>目前浏览器市场上主要关注的数据是全球性的，目前Chrome已经超过IE称为浏览器市场上占比最大的浏览器，根据有关新闻的报告，2016年6月份Chrome的市场份额达到48.7%,IE和Edge市场份额之和跌至36.7%，Mozilla的火狐浏览器市场份额下滑至8%；<br>关于国内的数据，目前没有权威性的报告，百度统计的浏览器市场份额没有360的统计数据，把360的数据统计到chrome和IE之中了；根据百度统计的结果可以看到Chrome的市场份额目前占比39.86%，IE的市场份额目前占比31.11%，搜狗高速浏览器，2345浏览器和猎豹浏览器目前分别占比从3.9%、3.72%、2.42%，其他浏览器目前占比15.00%；百度统计的结果在IE占比的分析上只包含IE6/7/8/9的数据，剩下的IE浏览器的数据没有显示，其中IE8浏览器目前占比达到18.49%，成为IE市场份额的最主要贡献值，IE6/7也占据了7%左右的市场份额；<a href="http://tongji.baidu.com/data/browser" target="_blank" rel="noopener">百度统计浏览器市场份额</a><br>根据cnzz的统计显示（最新的数据是2014-09-02的），IE浏览器的市场份额为36.29%，奇虎360旗下浏览器市场份额为27.84%，是国内最主要的浏览器；<a href="http://brow.data.cnzz.com/" target="_blank" rel="noopener">cnzz浏览器市场份额</a></p>
<h1 id="多浏览器带来的问题"><a href="#多浏览器带来的问题" class="headerlink" title="多浏览器带来的问题"></a>多浏览器带来的问题</h1><p>多浏览器带来了严重的兼容性问题，这称为前端开发的一个重要的组成部分，被前端开发人员所深恶痛绝，我认为多浏览器带来的兼容性问题<br>主要分为两个部分：一部分是旧的浏览器的问题，另一部分是关于标准支持的问题，其实归根到底还是一个问题；</p>
<h2 id="关于旧的浏览器的问题："><a href="#关于旧的浏览器的问题：" class="headerlink" title="关于旧的浏览器的问题："></a>关于旧的浏览器的问题：</h2><p>主要针对的是IE低版本浏览器（此处所值的低版本是IE6/7及以下版本），现在一般网页支持的最低版本的浏览器为IE8甚至IE9，通过IE的调试工具可以看到IE5.5的版本能够调试，但是很少有浏览器能够做到，我们公司目前需要支持到IE7，前段时间看到淘宝网停止支持IE6/7,最低支持IE8版本，这是BAT公司里面最先抛弃IE7以下版本的说明了，其实BAT的网页并不是所有的页面都支持这么低的版本，但是主要的页面还是支持低版本的；</p>
<h2 id="关于标准的问题："><a href="#关于标准的问题：" class="headerlink" title="关于标准的问题："></a>关于标准的问题：</h2><p>不同的浏览器版本和不同的浏览器品牌对W3C所制定的标准执行的力度是不同的，在低版本的浏览器上没有实现最新的标准，在高版本的浏览器上实现标准也不统一，既包括实现的方式不统一，也包括实现的内容不统一，目前看来，三大浏览器市场Firefox和Chrome对新标准的支持行更好，不过最新版的Edge浏览器对新版本的支持也挺好了；</p>
<h2 id="关于HTML的问题："><a href="#关于HTML的问题：" class="headerlink" title="关于HTML的问题："></a>关于HTML的问题：</h2><p>其实这个问题主要针对的是HTML5的新标签元素，在PC上实现web页面展示的时候，如果在低版本的IE浏览器上显示页面，这个问题是需要考虑的重要部分，只有IE9及以上的版本才开始支持HTML5，如果用HTML5元素生成页面的话，需要做好这方面的兼容性问题，目前一般是通过两种方法实现这个功能（见下面的代码）；<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//方式一：Coding JavaScript</span><br><span class="line"><span class="comment">&lt;!--[if lt IE9]&gt; </span></span><br><span class="line"><span class="comment">&lt;script&gt; </span></span><br><span class="line"><span class="comment">   (function() &#123;</span></span><br><span class="line"><span class="comment">     if (! </span></span><br><span class="line"><span class="comment">     /*@cc_on!@*/</span></span><br><span class="line"><span class="comment">     0) return;</span></span><br><span class="line"><span class="comment">     var e = "abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video".split(', ');</span></span><br><span class="line"><span class="comment">     var i= e.length;</span></span><br><span class="line"><span class="comment">     while (i--)&#123;</span></span><br><span class="line"><span class="comment">         document.createElement(e[i])</span></span><br><span class="line"><span class="comment">     &#125; </span></span><br><span class="line"><span class="comment">&#125;)() </span></span><br><span class="line"><span class="comment">&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">//第二种方法：使用Google的html5shiv包（推荐,注意墙的问题！！！）</span><br><span class="line"><span class="comment">&lt;!--[if lt IE9]&gt; </span></span><br><span class="line"><span class="comment">&lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">但是不管使用以上哪种方法,都要初始化新标签的CSS.因为HTML5在默认情况下表现为内联元素，对这些元素进行布局我们需要利用CSS手工把它们转为块状元素方便布局</span><br><span class="line">/*html5*/</span><br><span class="line">article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关于CSS的问题："><a href="#关于CSS的问题：" class="headerlink" title="关于CSS的问题："></a>关于CSS的问题：</h2><p>这应该是比HTML问题更加复杂的问题，这个问题不仅仅是低版本浏览器的问题，还有CSS3新特性实现的问题；<br>关于低版本浏览器的问题：<br>一些好的特性和写法在低版本的浏览器上不能实现，比如IE7不支持max-width、min-width、max-height、min-height等问题；同样的写法在高版本的浏览器和Chrome、Firefox浏览器上能够正常显示，在低版本的浏览器上不能正常显示；<br>要解决这个问题，前端开发人员不得不进行兼容行的写法，这主要有两种实现思路，一种是直接进行能够适应大部分浏览器的写法，一般在低版本的浏览器上能够正常显示，在高版本的浏览器上也能正确显示（不是一定），这样做的缺点是增加代码量，不仅仅是CSS的代码量，可能还需要改变页面的结构，增加页面的复杂度；另一种实现思路是通过大名鼎鼎的HARK实现，写一套简洁的代码，针对低版本的浏览器做兼容行处理（Firefox和Chrome也存在兼容行问题），下面的代码是简单的兼容性代码；<br>关于CSS3新特性实现的问题：<br>为了检测CSS3的新特性，完成标准的定制，W3C允许各浏览器通过添加前缀的形式实现新特性，这样浏览器市场上出现了Firefox的-moz-、IE的-ms-、Opera的-o-以及Safari和Chrome的-webkit-等，这让前端开发人员为了实现新特性只能把所有的前缀都加上，造成了CSS代码的冗余，为了解决这个问题，市面上出现了一些自动化的工具，自动完成CSS代码的兼容性写法；<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//兼容各大主流浏览器(最新版本)css hack汇总如下</span><br><span class="line"><span class="selector-class">.element</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#000</span>;             <span class="comment">/*w3c标准*/</span></span><br><span class="line">[;color:#f00;];         /*Webkit(chrome和safari)*/</span><br><span class="line"><span class="selector-tag">color</span>:<span class="selector-id">#666</span>\9;           <span class="comment">/*IE8*/</span></span><br><span class="line">*<span class="selector-tag">color</span>:<span class="selector-id">#999</span>;            <span class="comment">/*IE7*/</span></span><br><span class="line">_<span class="selector-tag">color</span>:<span class="selector-id">#333</span>;            <span class="comment">/*IE6*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:root</span> <span class="selector-class">.element</span>&#123;<span class="attribute">color</span>:<span class="number">#0f0</span>\<span class="number">9</span>;&#125;  <span class="comment">/*IE9*/</span></span><br><span class="line">@<span class="keyword">media</span> all and (-webkit-min-device-pixel-ratio:<span class="number">10000</span>), not all and (</span><br><span class="line">-webkit-min-device-pixel-ratio:<span class="number">0</span>) &#123; <span class="selector-class">.element</span>&#123;<span class="attribute">color</span>:<span class="number">#336699</span>;&#125;&#125;  <span class="comment">/*opera*/</span></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">document</span> url-prefix()&#123; <span class="selector-class">.element</span>&#123;<span class="attribute">color</span>:<span class="number">#f1f1f1</span>;&#125;&#125; <span class="comment">/*Firefox*/</span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://blog.csdn.net/freshlover/article/details/12132801" target="_blank" rel="noopener">史上最全的CSS hack方式一览</a><br><a href="http://developer.51cto.com/art/201506/479564.htm" target="_blank" rel="noopener">前端必看！各大浏览器 CSS Hack 收集</a><br><a href="http://www.cr173.com/html/17948_1.html" target="_blank" rel="noopener">CSS hack是什么？IE6\7\8\9\10浏览器的CSS hack大全介绍</a>     </p>
<h2 id="关于JavaScript的问题："><a href="#关于JavaScript的问题：" class="headerlink" title="关于JavaScript的问题："></a>关于JavaScript的问题：</h2><p>这个问题和CSS的兼容性问题同样麻烦，甚至更加的复杂，这个问题在IE和网景公司进行竞争的时候就已经存在，并且延续至今，目前JavaScript的版本已经到了ECMAScript 6，对新版本的支持各个浏览器相差不是太大，主要是历史问题，低版本的浏览器和Firefox的问题，Chrome浏览器对标准的支持相对较好；<br>为了解决JavaScript的兼容性问题，在编写原生代码的时候需要认真考虑这个问题，进行判断和兼容性编写；现在最热门的JQuery库，解决了这个问题，简化了操作；<br><a href="http://www.jb51.net/article/21483.htm" target="_blank" rel="noopener">Javascript 多浏览器兼容性问题及解决方案</a><br><a href="http://www.jb51.net/article/83099.htm" target="_blank" rel="noopener">常用原生JS兼容性写法汇总</a></p>
]]></content>
      
        <categories>
            
            <category> 浏览器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 内核 </tag>
            
            <tag> HARK </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【教程】编写高质量代码:Web前端开发修炼之道]]></title>
      <url>https://dudujie0915.github.io/2015/11/05/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81-Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</url>
      <content type="html"><![CDATA[<h1 id="从网站重构说起"><a href="#从网站重构说起" class="headerlink" title="从网站重构说起"></a>从网站重构说起</h1><p>从一个糟糕的老网页实例说明需要将web的结构，样式和行为分离开来，既html文件，css文件，js文件。<br>W3C组织</p>
<ul>
<li>结构标准:   包括XML标准、XHTML标准、HTML标准； </li>
<li>样式标准：主要指CSS标准； </li>
<li>行为标准： 包括DOM标准和ECMAScript标准。 </li>
</ul>
<p>符合标准的网页，标签中的标签名全部小写，属性加引号，样式和行为存放单独文件。<br>网页维护越来越难的原因： </p>
<ul>
<li>浏览器层面：ie6-ie11、chrome、firebox、oprea、safari、360浏览器、搜狗浏览器、qq浏览器、猎豹浏览器、百度浏览器、uc浏览器、2345浏览器等； </li>
<li>技术层面：不统一； </li>
<li>团队合作层面：体验要求不断增加，表现力要求越来越高，代码越来越复杂，团队要求越来越高。 </li>
</ul>
<p>打造高质量的前端代码，提高代码的可维护性—-在web标准的指导思想下，在实现结构、样式和行为分离的基础上，还要做到三点：精简、重用、有序。<br><strong>总结：Html标签只负责承载内容，样式交给css，行为交给Javascript。做到“精简，重用，有序”。</strong> </p>
<h1 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h1><p><img src="http://oboiq86te.bkt.clouddn.com/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/GetImage.jfif" alt="前端工程师"><br><strong>欲精一行，必先通十行</strong><br>这章主要说明前端需要了解的语言，html， css要精通、及其重要，js,及架构div+css，RIA富媒体应用，jquery,YUI,ps,AI设计等等；<br>团队之间的开发要注意： </p>
<ol>
<li>增加代码可读性—-注释 </li>
<li>重用性—公共组件和私有组件的维护 </li>
<li>冗余和精简的矛盾—选择集中还是选择分散   （合理的前端架构中css和js都会提取公共组件，如何组织需要权衡，完美的解决方案不存在，只能在冗余和精简中尽量找到最佳平衡点） </li>
<li>前期的构思很重要。 </li>
<li>制定规范 </li>
<li>团队合作最大难度不是技术，而是人（沟通很重要，人际交往）</li>
</ol>
<h1 id="高质量的Html"><a href="#高质量的Html" class="headerlink" title="高质量的Html"></a>高质量的Html</h1><h2 id="标签的语义：大家都懂的。"><a href="#标签的语义：大家都懂的。" class="headerlink" title="标签的语义：大家都懂的。"></a>标签的语义：大家都懂的。</h2><h2 id="标签布局"><a href="#标签布局" class="headerlink" title="标签布局"></a>标签布局</h2><p>table布局网页的缺点：</p>
<ol>
<li>代码量大，结构混乱。</li>
<li>标签语义不明确，对搜索引擎不友好 </li>
</ol>
<p>css布局（div+css）：弱化了标签的布局能力，将布局完全放到样式中去控制，而标签重新恢复了原来语义的作用。它与table布局相比具有代码量少，结构精简，语义清晰等优点。<br><strong>总结：在布局的过程中，Html结构才是重点，css是用来修饰结构的，正确的做法是：先确定html,确定语义的标签，再来选用合适的css。</strong></p>
<h2 id="如何确定你的标签是否语义良好："><a href="#如何确定你的标签是否语义良好：" class="headerlink" title="如何确定你的标签是否语义良好："></a>如何确定你的标签是否语义良好：</h2><p>在做完一个页面后，去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性（浏览器会根据标签的语义给定一个默认的样式）。<br>“css裸体日”这个日子的目的就是为了提醒大家选用合适的HTML标签的重要性。————显然我是第一次听说哈。 </p>
<h2 id="标题和内容的实例"><a href="#标题和内容的实例" class="headerlink" title="标题和内容的实例"></a>标题和内容的实例</h2><p>这个实例用的是Html中无语义的标签—–div分隔 和span范围 来架构的， 而正确的做法一般使用h2,p,a来架构；<br>需要特别说明的是：<strong>当页面内标签无法满足设计需要时，才会适当添加div和span等无语义的标签来辅助实现</strong>。 </p>
<h2 id="表单和表格"><a href="#表单和表格" class="headerlink" title="表单和表格"></a>表单和表格</h2><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>一般需要直接submit的内容需要放置在表单内，为了有清晰的语义，一般表单域要用fieldset标签包起来，并用legend标签说明表单的用途，若不想要它自带的默认样式，可将<code>border:none;</code>不想显示设置 <code>display:none</code>,以此来兼顾语义和设计两方面的需求。<br>每个input标签对应的说明文本都需要使用label标签，并通过为input设置id属性，在label中设置“for=someId”来将对应的label和input关联起来。 </p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>虽然在css布局中table不推荐用来布局，但它在二维数据展示方面确实最好的选择。<br>一般用table，我常使用它的<code>&lt;table&gt;&lt;tr&gt;&lt;th&gt;&lt;td&gt;</code>标签，在有需要的时候还可以用他的其他标签，表格标题用caption,表头用thead包围，主体部分tbody包围，尾部tfoot包围。<br><strong>总结：语义化标签应注意的一些问题</strong>      </p>
<ol>
<li>尽可能少地使用无语义标签div和span </li>
<li>语义不明显，既可用P也可用div的地方，建议尽量用p,因为有上下间距，可读性好。（还是视情况而定） </li>
<li>不要使用纯样式标签，如：b,font,u等 ，直接写进css设置。 </li>
</ol>
<h1 id="高质量的css"><a href="#高质量的css" class="headerlink" title="高质量的css"></a>高质量的css</h1><h2 id="怪异模式和标准模式"><a href="#怪异模式和标准模式" class="headerlink" title="怪异模式和标准模式"></a>怪异模式和标准模式</h2><p>在标准模式中，浏览器根据规范表现页面；而怪异模式通常模拟老式浏览器的行为以防止老站点无法工作。<br>他们两者之间的差异比较典型的表现在<strong>IE对盒模型的解析</strong>：在标准模式中，网页元素的宽度=padding+border+width;而在怪异模式中，width本身就包括了padding和border。<br>在怪异模式中：设定width,然后margin:0 auto;是无法居中的。标准模式中可以正常工作。<br>于是我们尽量避免怪异模式，而选用标准模式，这样就出现了DTD(文档类型定义Document Type Definition)；<br>DTD(文档类型定义Document Type Definition)：是一种保证html文档格式正确的有效方法，一个DTD文档包含元素的定义规则、元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。<br>DTD声明：如果漏写DTD声明，FF仍然会按照标准模式来解析，<strong>但在IE中（6.7.8）就会触发怪异模式，现在一般可以直接手动设置为标准模式</strong>。 </p>
<h2 id="如何组织css"><a href="#如何组织css" class="headerlink" title="如何组织css"></a>如何组织css</h2><p>笔者按照职能分为三大类：base、common、page 这三者不是并列结构，而是层叠结构。</p>
<h3 id="base层："><a href="#base层：" class="headerlink" title="base层："></a>base层：</h3><p>最底层，基本层，一般放置粒度最小的通用类–原子类，这一层会被所有页面引用，力求精简，通用，有高度可移植性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*推荐代码：*/</span></span><br><span class="line"><span class="selector-class">.fl</span>&#123;<span class="attribute">float</span>:left;&#125; </span><br><span class="line"><span class="selector-class">.fr</span>&#123;<span class="attribute">float</span>:right&#125; </span><br><span class="line"><span class="selector-class">.mt15</span>&#123;<span class="attribute">margin-top</span>:<span class="number">15</span>;&#125; </span><br><span class="line"><span class="selector-class">.mb15</span>&#123;<span class="attribute">margin-bottom</span>:<span class="number">15</span>;&#125; </span><br><span class="line"><span class="selector-class">.w50</span>&#123;<span class="attribute">width</span>:<span class="number">50px</span>;&#125;  </span><br><span class="line"><span class="selector-class">.cb</span>&#123;<span class="attribute">clear</span>:both;&#125; </span><br><span class="line"><span class="selector-class">.cr</span>&#123;<span class="attribute">clear</span>:right;&#125; </span><br><span class="line"><span class="selector-class">.pr20</span>&#123;<span class="attribute">padding-right</span>:<span class="number">20</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出来，base层结构粒度非常小，非常实用于组合类的结构。<br>base层可分为两大部分:css reset 和 通用原子类:<br>css reset：就是重定义标签的样式，覆盖掉浏览器提供的默认样式；如<code>*{margin:0;padding:0;}</code>，因为浏览器默认的边距是最影响css布局的。最好不要使用,而是罗列出要覆盖的标签元素：如：ol li ul h1 dl dt …. 将冲突降至最低。<br>从笔者的经验来看，base层的类虽然粒度小，但它非常有用,设置大量这样的类<strong>有利于减少page层的代码量，也为css的模块化提供了帮助</strong>。</p>
<h3 id="common层："><a href="#common层：" class="headerlink" title="common层："></a>common层：</h3><p>中间层，高度重用的模块，视为组件（类似于网站内一个一个的同样式的板块）。<br>模块化层面：将页面内的元素拆分成一小块一小块功能和样式相对独立的小模块。类比于 房子（网站），不同的门窗、门窗有不同的小元件（common），这一层最好由一个人负责统一管理。<br>common层是网站级的,不同的网站有不同的common层，而同一个网站只有一个common层。 </p>
<h3 id="page层："><a href="#page层：" class="headerlink" title="page层："></a>page层：</h3><p>页面级的样式，最高层。对重用性没要求.(就好像房间里的画，不同房间会挂不同的画。) </p>
<h2 id="如何划分css模块"><a href="#如何划分css模块" class="headerlink" title="如何划分css模块"></a>如何划分css模块</h2><p><strong>一句话概括:封装、多用组合少用继承的原则。</strong><br><strong>将相似部分提取出来，再进一步拆分成更小的模块。</strong><br><strong>原则：</strong> </p>
<ul>
<li><strong>模块和模块之间尽量不要包含相同的部分,如果有相同部分,应将他们提取出来,拆分成一个独立的模块.</strong> </li>
<li><strong>模块应在保证数量尽可能少的原则下,做到尽可能简单,以提供重用性.</strong></li>
</ul>
<h2 id="css命名"><a href="#css命名" class="headerlink" title="css命名"></a>css命名</h2><ul>
<li>使用英语 </li>
<li>骆驼命名法（从第二个单词开始首字母大写，如dropMenu,subNavMenu） </li>
<li>划线命名法（- 或_ 如drop-menu ,sub_nav_menu）<br>使用骆驼命名法和划线命名法可以清楚的将单词区分开来，提高可读性。推荐这两种方式组合使用。<strong>一般骆驼命名法用于区别不同单词，划线用于表明从属关系。</strong> </li>
<li>子选择符：滥用子选择符容易留下冲突隐患，为了降低风险，不推荐轻易使用子选择符。<br><strong>总结:base层和common层是公共的，一般由一个人负责，不会出现冲突，page层多人合作使用，容易冲突，在命名css时，如果模块多次反复出现，应该将它归为common层，不用考虑冲突问题，出现次数少，则归为page层。</strong> </li>
<li>page层多人合作很容易引起命名冲突，为解决这一问题，一般每个人会分配一个标识符，然后给命名加上该前缀的方法来解决。 </li>
</ul>
<h2 id="多用组合，少用继承"><a href="#多用组合，少用继承" class="headerlink" title="多用组合，少用继承"></a>多用组合，少用继承</h2><p>继承的思路是将一个复杂且包含变化的类，拆分成几个复杂但稳定的子类。首先明确一个抽象的父类，父类有着几乎所有的方法和属性，子类继承父类，根据需求添加新的方法和属性，覆盖掉与父类有变化的方法和属性。<br>缺点:使用继承的话,任何一点小的变化也需要重新定义一个类,很容易引起类的爆炸式增长,产生一大堆有着细微不同的子类.<br>组合的思路是将一个复杂的类分成容易产生变化的部分和相对稳定的部分,将容易变化的部分拆分出去,每一种可能的变化设计成一个个单独的类,类之间没有继承关系,遵循了面向对象设计的”单一职责”原则.这些容易变化的类的实例赋值给主体类作为一个属性,实现了类的组合.<br>用组合的方式,可大大减少类的数量.<br><strong>注:margin是一个有点特殊的样式，相邻的margin-left;margin-right不会重合，但是相邻的margin-top;margin-bottom会产生重合，所以相邻的标签不要混合使用，统一使用margin-top或margin-bottom。</strong></p>
<h2 id="低权重原则"><a href="#低权重原则" class="headerlink" title="低权重原则"></a>低权重原则</h2><p>标签权重是 1；class权重是 10；id 权重是100;<br><strong>当有冲突时，会选择权重高的样式，权重一样时，就近原则，最后定义的为最近，css权重应该尽可能的低。</strong>  </p>
<h2 id="css-sprite"><a href="#css-sprite" class="headerlink" title="css sprite"></a>css sprite</h2><p>将网站的多张背景图片合并到一张大图片上。<br><strong>可以解决a标签hover状态时背景图片出现瞬间空白的问题。</strong><br>每次图片加载会发出http请求，一张图片需要一条http请求，http请求数越多，访问服务器的次数越多，那server压力就越大，css sprite亦可以减小服务器的压力: </p>
<ol>
<li>只能用于作为背景的图片background-image </li>
<li>不能用于对于横向和纵向都平铺的图片。至于原因，自己去测试就知道了。 </li>
</ol>
<h2 id="haslayout"><a href="#haslayout" class="headerlink" title="haslayout"></a>haslayout</h2><p>是IE浏览器一个专有的属性，用于css的解析引擎。有时候网页会在ff下面运行正常，但到IE下就不正常，往往是因为hasLayout没有触发的原因。<br>可以通过设置width,height,position:relative来触发，但一个更好的解决办法是zoom:1可以触发hasLayout; </p>
<h2 id="块级元素和行内元素-可通过修改display属性来切换块级和行内"><a href="#块级元素和行内元素-可通过修改display属性来切换块级和行内" class="headerlink" title="块级元素和行内元素(可通过修改display属性来切换块级和行内)"></a>块级元素和行内元素(可通过修改display属性来切换块级和行内)</h2><p>块级元素：可设置宽高，margin padding 正常使用，独占一行<br>行内元素：不能设置宽高，margin padding 在水平方向会产生边距效果，竖直方向不会产生边距效果，在同一行内。<br>display:inline-block 行内块级元素；可设置宽高，可设置margin;padding;却不独占一行  （IE6/7不支持，可通过触发haslayout来解决）      </p>
<h2 id="relative-absolute和float"><a href="#relative-absolute和float" class="headerlink" title="relative,absolute和float"></a>relative,absolute和float</h2><ol>
<li>只有设置了position属性时，left top right bottom z-index属性才会激活，否则设置了也无效。 </li>
<li>position设置为relative或absolute都可以改变元素在文档流中的位置。网页虽然看起来是二维结构，也是有z轴的，默认所以元素都在z-index:0这一层—-这就是<strong>文档流</strong>。 </li>
<li>不设置position，那么网站的默认position：static . </li>
<li><p>position设置为relative或absolute都会让元素“浮”起来，也就是z-index&gt;0时，它会改变正常情况下的文档流。 </p>
<blockquote>
<p>position:relative—会保留自己在z-index:0层的占位，属于占位上浮。<br>position:absolute—会完全脱离文档流，不保留占位，这样就通常会覆盖掉下面的元素。<br>他们的left,bottom,top.right四个值是相对于 自己最近设置了position的祖先元素，若都没有设置，则想对于body元素      </p>
</blockquote>
</li>
<li><p>float:左右浮动，它也能改变文档流，但是不会上浮，只会在z-index:0层改变正常的文档流排列，影响周围的元素。 </p>
</li>
</ol>
<h2 id="水平居中的几种方式"><a href="#水平居中的几种方式" class="headerlink" title="水平居中的几种方式"></a>水平居中的几种方式</h2><ol>
<li>文字、图片等行内元素的水平居中——text-align:center   这个属性能够解决在<strong>文字，图片，行内元素</strong>的水平居中。 </li>
<li>确定宽度的块级元素水平居中—–margin:0 auto; </li>
<li>不确定宽度的块级元素水平居中<br><strong>A.table 标签实现:</strong><br>table本身不是块级元素，不设定宽度的话，它的宽度由内部元素的宽度“撑起”，仅需设置margin:0 auto就可以居中（例：分页<code>&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;ul&gt;&lt;li&gt;</code>）<br>缺点：增加了无语义标签，加深了标签的嵌套层数。<br><strong>B方案:</strong><br>将要居中的标签转换为行内元素，然后在父标签设置text-align:center;  缺点：因为转换成了行内元素，可能会带来一些限制。<br><strong>C方案:</strong><br>通过给父标签设置float,position:relative;left:50%,子标签设置position:relative;left:-50%;来实现。</li>
</ol>
<h2 id="竖直居中"><a href="#竖直居中" class="headerlink" title="竖直居中"></a>竖直居中</h2><ol>
<li>父标签不确定，子标签为文本，图片，块级元素的竖直居中——通过给父标签设置相同的上下边距来实现居中padding </li>
<li>父标签高度确定，单行文本竖直居中———-line-heiht来实现 </li>
<li>父标签高度确定，多行文本，图片，块级元素竖直居中<br><strong>A方案:</strong><br>vertical-align属性：当父元素为td或th是，改属性才会生效，后来查证，对inline-block等内联元素都有效。<strong>对于块级元素可设置display:table-cell来激活这个属性使之有效。</strong><br><strong>B方案:</strong><br>通过给父子两层元素分别设置top:50%，top:-50%来实现，也需要设置position：relative；position：absolute; <h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2>一个页面经常会分为好几块，每次呈现给用户的最好先是主体内容，这样视觉效果会好些，感觉网速很快。<br>在设计的过程中，需要把主体内容的html标签要保证在其他内容之前加载，（就是将主体内容的html标签顺序靠前）  </li>
</ol>
<h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>该属性在设置position后激发，z-index越大， 元素位置越靠上。也可设置为负数，这样，元素会在body之下。  </p>
<h1 id="高质量的Javascript"><a href="#高质量的Javascript" class="headerlink" title="高质量的Javascript"></a>高质量的Javascript</h1><p>这章的内容我看的最久,这是跟我js基础没打好有着莫大的关系，但是还是耐着性子看完了， 不懂的东西都是百度上搜索，理解后再继续。下面是记录下来的笔记。</p>
<h2 id="如何避免JS冲突"><a href="#如何避免JS冲突" class="headerlink" title="如何避免JS冲突"></a>如何避免JS冲突</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>在多人合作一个网站时，每个人都会写自己的JS代码，定义变量的时候有可能会引起命名冲突，如何避免这种冲突隐患呢？<br>一种最简单有效的办法是“<strong>匿名函数</strong>”将脚本包起来，<strong>让变量的作用域控制在匿名函数之内</strong>。<br>匿名函数：(function (){})() 前面的括号内是函数体，后面的()表示执行。<br>如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> name,user=<span class="string">"test"</span>;      <span class="comment">//包含在这个匿名函数中的变量，作用域不再是window,而是局限在函数内部。 因为各自包在不同的匿名函数内，也就不再互相冲突了。 </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p><strong>用匿名函数将脚本包起来，可以有效的控制全局变量，避免冲突隐患。</strong> </p>
<h3 id="解决匿名函数之间的通信问题"><a href="#解决匿名函数之间的通信问题" class="headerlink" title="解决匿名函数之间的通信问题"></a>解决匿名函数之间的通信问题</h3><p>上面的匿名函数确实解决了冲突,但是如果两个代码段之间需要访问彼此的变量,那就被分隔开了,没法访问对方作用域中的变量.<br>一个比较好的解决办法是”在window的作用域下定义一个全局变量”,但是从上面的冲突来看,全局变量是引起冲突的杀手,如果又这样定义,就违背了我们使用匿名函数的初衷,所以应该严格控制全局变量的数量!<br><strong>为了控制全局变量的数量,用Hash对象作为全局变量。  var GLOBAl={};  //一个对象类型的变量作为全局变量，扩展性好;</strong><br>定义好对象类型变量后,在匿名函数A中定义GLOBAL的属性：GLOBAL.str1=”aaa”;   在匿名函数B中可以直接访问var b = BLOBAl.str1;<br>这样又出现了一个问题，当在匿名函数B中它也定义一个属性BLOBAl.str1=”bbb”; 这个时候就会把A块中的属性str1给覆盖掉.如何避免这种冲突呢？不可能每个开发者在使用GLOBAL对象之前，都要查找一下绑定了哪些属性。<br>这时，命名空间就出现了，它是一种特殊的前缀，在js中它其实是通过一个{}对象来实现的。我们可以给每个匿名函数声明不同的命名空间，然后每个匿名函数中GLOBAL对象的属性都不要直接挂在GLOBAl对象上，而是挂在此匿名函数的命名空间下，既：window全局的GLOBAL.命名空间.属性变量  ,这样申明属性名称的时候，即使同名，空间不一样也不会引起冲突。如： GLOBAL.A={};// 定义命名空间； GLOBAL.A.str1=”aaa”;//定义属性变量<br>复杂的匿名函数中，你还可以生产二级命名空间，如GLOBAL.A={};//一级命名空间，GLOBAL.A.CAT={};GLOBAL.A.DOG={};//二级命名空间；<br>生成命名空间是一个很常用的功能，可以将其封装为一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> GLOBAL=&#123;&#125;; </span><br><span class="line">GLOBAL.namespace=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> arr=str.split(<span class="string">"."</span>),o=GLOBAL; </span><br><span class="line"><span class="keyword">for</span>(i=(arr[<span class="number">0</span>]==<span class="string">"GLOBAL"</span>)?<span class="number">1</span>:<span class="number">0</span>; i&lt;arr.length; i++)&#123; </span><br><span class="line">o[arr[i]]=o[arr[i]] || &#123;&#125;; </span><br><span class="line">o=o[arr[i]]; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>调用： GLOBAL.namespace(A.DOG);      GLOBAL.namespace(GLOBAL.B);</strong><br>总结:解决js冲突——-命名空间+全局变量+匿名函数 很好的结合使用才能更好的解决冲突。 </p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>添加必要的代码注释，可大大提高可维护性，对团队合作来说，是很重要的。<br>注释添加的信息包括：功能说明；工程师姓名；工程师联系方式；代码最后修改时间；<br>让JS不产生冲突，需要避免全局变量的泛滥，合理使用命名空间，以及给代码添加注释。     </p>
]]></content>
      
        <categories>
            
            <category> 性能优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
