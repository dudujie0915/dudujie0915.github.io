---
title: CSS揭秘
date: 2017-04-06 15:43:57
tags: [教程,CSS]
categories: CSS
---
# 关于本书
## 前提
- 已彻底掌握CSS 2.1；
- 了解并使用最流行的CSS 3特性；
- 了解SVG；
- 读懂简单、原生的JS代码；
- 听说过 CSS预处理器；
- 高一数学；

<!-- more -->

## 浏览器支持与退回机制
- 某些特性得到浏览器支持，但是不同的浏览器表现上有细微的差异，可能需要一个浏览器前缀（应该把标准语法排在最后），或者在语法上存在着细微的差别；
- 提供退回机制可以确保网站不会在低版本浏览器中挂掉，只是看出来没那么炫而已；
- 可以使用[Modernizr](http://modernizr.com)这样的工具给根元素（<html>）添加一些辅助类，这样可以针对支持或不支持某些特性的浏览器来分别编写样式；
- 用@supports（慎用）规则实现回退，可以将其视作浏览器“原生”的Modernizr；
- 可以自己编写JS代码，检测某个样式属性是否被支持，核心思路就是在任一元素的element.style对象上检查该属性是否存在；
- 浏览器可以解析某个CSS特性并不代表它已经实现（或正确实现）了这个特性；

# 引言
## Web标准：是敌还是友
### 标准的制定过程
- W3C并不“生成”标准，它扮演了一个论坛的角色，技术规范（基本上）并不是由W3C的工作人员编写完成的，CSS规范通常是由CSS工作组（主要是W3C会员公司，主要包括浏览器厂商等，所有浏览器厂商比W3C有更多的发言权）的成员来编写的；W3C 免费、开放；制定规则不是闭门造车；
- 规范的制定过程：①编辑草案（ED）；②首个公开工作草案（FPWD）；③工作草案（WD）；④候选推荐规范（CR）；⑤提名推荐规范（PR）；⑥正式推荐规范（REC）；

### CSS3、CSS4以及其他传说
- 一项规范如果要推进到最终阶段，其中的每项特性都必须具备两个独立的实现和全面的测试；
- 尽管“CSS3”这个名词非常流行，但它实际上并没有在任何规范中定义过；

### 冰与火之歌：浏览器前缀
- 每个浏览器都可以实现这些实验性的（甚至是私有的、非标准的）特性，但是在名称前面加上自己特有的前缀；
- 最常见的前缀分别是Firefox的-moz-、IE的-ms-、Opera的-o-已经Safari和Chrome的-webkit-；
- 为了解决浏览器前缀编写困难的问题，用工具自动化来实现：
    像[CSS3，Please！](http://css3please.com)和[pleeease](http://pleeease)在线网站，自动生成必要的前缀；    
    [Autoprefixer](http://github.com/ai/autoprefixer)采用[Can I Use...](http://caniuse.com)的数据库来判断必要的前缀，它是在本地完成编译的，类似预处理器；
    [-prefix-free](http://leaverou.github.io/prefixfree)在浏览器中进行特性检测是否需要前缀；
    类似[Stylus](http://stylus-lang.com)和[LESS](http://lesscss.org)或[Sass](http://sass-lang.com)的预处理器本身不自带，但第三方有常用属性加前缀的mixin；
- 浏览器前缀是一场史诗般的失败；
- 在现在浏览器中，实验性特性主要是通过配置开个来启动；

## CSS编码技巧
### 尽量减少代码重复
保持代码的DIY和可维护性是代码开发中最大的挑战之一，代码可维护性的最大要素是尽量减少改动时要编辑的地方；这不仅是后期修改的问题，灵活的CSS更容易扩展：在写出基础样式之后，只用极少的代码就可以扩展出不同的变体，因为只需要覆盖一些变量就可以了；
[减少代码重复](http://oboiq86te.bkt.clouddn.com/CSS%E6%8F%AD%E7%A7%98/%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D.html)
1. 代码易维护 vs. 代码量少  
    有时间不可兼得，比如上面超链接里的代码，最终的代码比一开始的版本略长，比如下面的代码片段
    ```
    border-width: 10px 10px 10px 0;
    //修改为
    border-width: 10px;
    border-left-width: 0;
    ```
2. currentColor  
    CSS中有史以来第一个变量；它并没有绑定一个固定的颜色值，而是一直被解析为color；它本身就是很多CSS颜色属性的初始值，比如border-color和outline-color,以及text-shadow和box-shadow的颜色值；
3. 继承  
    inherit可以用在任何CSS属性中，而且它总是绑定到父元素的计算值（对于伪元素来说，则会取生成该伪元素的宿主元素）；表单元素的字体设置为与页面中其他部分相同，可以使用`input,select,button{font:inherit;}`；超链接的颜色设定为与页面中其它文本相同，可以使用`a{color:inherit;}`；对于背景上同样有用；

### 相信你的眼睛，而不是数字
- 视觉上的错觉在任何形式的视觉设计中都普遍存在，需要我们有针对性的调整；
- 我们眼睛看到一个完美垂直居中的物体时，会感觉并不居中，需要物体从中心点稍微向上挪一点；
- 圆形的字体比矩形字体要稍微放大一点；
- 给容器四边指定相同的内边距，实际效果看起来并不相等，原因在于字母的形状在两端都比较整齐，而顶部和底部则往往参数不齐，需要减少顶部和底部的内边距；

### 关于响应式网页设计
- 使用媒体查询，每个媒体查询都会增加成本；只要用对了，它就是利器；
- 媒体查询的断点不应该由具体的设备来决定，而应该根据设计自身来决定；
- 避免不必要额媒体查询的方法：①使用百分比长度取代固定长度；②当需要在较大分辨率下得到固定宽度，使用max-width而不是width；③为替换元素设置一个max-width，值为100%；④背景铺满一个容器，background-size: cover都可以做到（移动端上不太明智，带宽问题）；⑤当图片（或其它元素）以行列式进行布局时，让视口的宽度来决定列的数量；弹性盒布局或display: inline-block加上常规的文本折行行为，都可以实现；⑥使用多列文本时，指定column-width（列宽）而不是指定column-count（列数），这样可以在较小的屏幕上自动显示为单列布局；
- 实现弹性可伸缩的布局，并在媒体查询的各个断点区间内指定相应的尺寸；

### 合理使用简写
- 合理使用简写是一种良好的防卫性编码方式，可以抵御未来的风险；
- 要明确地去覆盖某个具体的展开式属性并保留其他相关样式，就需要用展开属性；
- 如果只为某个属性提供一个值，那它会扩散并应用到列表中的每一项；

### 我应该使用预处理器吗？
1. 预处理器的种类：  
    [Stylus](http://stylus-lang.com)    
    [LESS](http://lesscss.org)      
    [Sass](http://sass-lang.com)
2. 优点：  
    为CSS的编写提供了一些便利，比如变量、mixin、函数、规则嵌套、颜色处理等；    
    如果使用得当，它们在大型项目中可以让代码更加灵活；
3. 缺点：
    CSS的文件的体积和复杂性可能会失控；    
    调试难度会增加（目前问题基本解决）；    
    在开发过程中引入了一定程度的延时（差不多一秒钟）；   
    更高的学习成本，要么强制协作者接受我们的选择，要么话费额外的时间来培训；   
    抽象泄露法则，预处理器有自身的bug；    
    网站开发者可能会不自觉地“依赖”和“滥用”；
4. 未来：    
    很多受处理器启发的特性都已经以各种方式融入到原生CSS中了；
    原生特性通常比预处理器的版本强大得多，因为它们是动态的；   
    在引入预处理器的问题上需要冷静决策；

# 背景与边框
## 半透明边框（1）
[半透明边框](play.csssecrets.io/translucent-borders)
1. 难题：      
    默认情况下，背景会延伸到边框所在的区域下面，所以我们设置的边框半透明会被背景颜色所遮挡；
2. 解决方案：   
    CSS3中通过background-clip属性来调整默认行为带来的不便；   
    这个属性的初始值是border-box，意味着背景会被元素的border-box(边框的外沿框)裁切掉；    
    如果把这个属性的值设为padding-box，浏览器会用内边距的外沿来把背景裁切掉；



