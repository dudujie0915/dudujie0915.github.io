---
title: 【教程】CSS权威指南《第三版》
date: 2016-08-12
tags: [教程,CSS]
categories: CSS
---
# 一、CSS和文档
## 1. CSS2的media属性：
- all，aural，brailla，embossed，handheld，print，projection，screen，tty，tv；
- all、screen、print得到广泛支持；
- 可以直接在link中使用，也可以直接在css文件中使用，或者在style中使用也可以；

## 2. 候选样式表：
- rel属性的值设为alternate stylesheet，定义候选样式表，用户选择时调用；
- 浏览器支持的话，会使用link元素的title属性值生成一个候选样式列表，默认显示第一个link或者是title名为Default的（不确定，需要实验）；
- 为候选样式表定义相同title值，把他们分组在一起，用户可在不同的媒介中选择不同的样式表；
<!-- more -->

## 3. @import指令：
- @import它必须放在其他css规则之前，可以放在style标签中，或者是css文件中；
- 可以有多个@import，但是低版本解析可能有问题（或许是ie5一下的版本，需要实验）；
- 可以添加media属性；
- 绝对路径和相对路径都可以；

## 4. 向后可访问性：
```html
<style type="text/css"><!--
@import url(sheet2.css);
h1{color:maroon;}
body{background:yellow;}
--></style>
```
这样表示，较老的浏览器会将style标记完全忽略，还会忽略声明（目前应该不存在这个问题，需要验证）；

## 5. css注释：
	不能嵌套；

## 6. 内联样式：
一个内联style属性中只能放一个声明块，二不能放整个样式表，因此，不能在style属性中放@import，也不能包含完整的规则；style属性的值中只能是规则中出现在大括号之间的部分；通常不推荐使用style属性；

# 二、选择器
![css声明](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/css%E5%A3%B0%E6%98%8E.png)
- 元素选择器（如p{}）、
- 选择器分组和声明分组（如h2,p{}）、
- 通配选择器（*{}）、
- 类选择器和多类选择器（如.class{}）、
- ID选择器（如#id{}）、
- 属性选择器（如h1[class]{}，可以根据具体的属性值选择，也可以根据部分属性值选择）、
- 特定属性选择类型（如*[lang|="en"]{}）
- 使用文档结构：
	后代选择器（如 h1 em{}）
	选择子元素（如 h1>em{}） （我使用较少）
	选择相邻兄弟元素（如 h1+em{}）（我使用较少）
- 伪类和伪元素：
- 类选择器和id选择器使用需要主要，还有两类选择器区分大小写；
- 属性选择器（根据部分选择）（需要验证支持情况）
![子字符串匹配性选择器](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8.png)
- 伪类和伪元素：
![链接伪类](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB.png)
![动态伪类](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%8A%A8%E6%80%81%E4%BC%AA%E7%B1%BB.png)
![动态伪类2](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%8A%A8%E6%80%81%E4%BC%AA%E7%B1%BB2.png)
	为了为顺序很重要，通常建议“link-visited-hover-active”（具体愿意以后发文说明）；
	选择第一个子元素 :first-child
	根据语言选择 *:lang(fr){}
- 伪元素选择器：（属性的限制需要了解）
	设置首字母样式 :first-letter
	设置第一行样式  :first-line
	设置之前和之后元素的样式   :before和:after

# 三、结构和层叠
## 1. 特殊性：
![特殊性](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E7%89%B9%E6%AE%8A%E6%80%A7.png)
	实际上，特殊性值0,0,1,0比值0,0,0,13更高。
	通配选择器特殊性：其特殊性为0,0,0,0；
	内联样式特殊性：其特殊性为1,0,0,0；
	重要声明!important:级别最高；

## 2. 继承：
- 在HTML中，对于向上传播有一个例外：应用到body元素的背景样式可以传递到html元素（html是文档的根元素），相应地可以定义其画布；
- 不能继承的属性: 一般的，大多数框模型属性（包括外边距、内边距、背景和边框）都不能继承；a标签的样色，样式；
- 继承的值根本没有特殊性，甚至连0特殊性都没有；
- 0特殊性比无特殊性要强；
- 继承有bug：在不同的浏览器中显示不一样，所有设置global.css（通用样式）；

## 3. 层叠：
![层叠](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%B1%82%E5%8F%A0.png)
- 按权重和来源排序：
![声明权重](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%A3%B0%E6%98%8E%E6%9D%83%E9%87%8D.png)
- 按特殊性排序：较高特殊性强于较低特殊性；
- 按顺序排序：后出现原则；
![排序](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E6%8E%92%E5%BA%8F.png)
- 非CSS表现提示：它被处理为特殊性为0，并出现在创作人员样式表的最前面；只要有创作人员或者读者样式，这种表现提示就会被覆盖，但是用户代理的样式不能将其覆盖。

# 四、值和单位
## 1. 数字：
CSS中有两类数字：整数和实数（小数）；

## 2. 百分数
## 3. 颜色：
颜色名、RGB颜色、RGBA颜色
![颜色](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E9%A2%9C%E8%89%B2.png)
- 大多数Web浏览器能够识别多达140个颜色名，包括前面的17个。
- RGB颜色可以用百分数值（范围在0%~100%）或者整数（范围在0~255）表示
- 十六进制RGB颜色（三个数值范围介于00~FF，语法是#RRGGBB）（如果组成十六进制数的3组数各自是成对的，可以采用#RGB的简写记法）
![web安全颜色](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/web%E5%AE%89%E5%85%A8%E9%A2%9C%E8%89%B2.png)

## 4. 长度单位：
- 所有长度单位都可以表示为正数或者负数，其后跟一个标签（不过有些属性只接受整数）；另外可以使用实数；所有长度单位后面都有一个长度单位（只有一个例外，长度为0时，后面不需要跟单位）
- 绝对长度单位：英寸（in）、厘米（cm）、毫米（mm）、点（pt）、派卡（pc）
- 相对长度单位：em,ex,px,rem等
    em:相对于当前元素的font-size值，如字体14px，那么当前内容的 1em=14px；

## 5. URL：
相对路径和绝对路径；url与内容之间不能有空格；

## 6. 关键字：
none，normal，inherit（继承父元素的值）等；

## 7.其他单位：
(其他单位在CSS2中使用，当前是否使用需测试)
- 角度值----度(deg)、梯度(grad)、弧度(rad)
- 时间值----毫米(ms)、秒(s);
- 频率值----赫兹(Hz)、兆赫(MHz)

# 五、字体
## 1. 字体系列:
- 特定字体系列(如Times、Verdana、Helvetica或Arial)
- 通用字体系列(Serif字体、Sans-serif字体、Monospace字体、Cursive字体、Fantasy字体)
- 使用通用字体系列：属性font-family定义
- 指定字体系列：属性font-family定义
    注：强烈建议在所有font-family规则中都提供一个通用字体系列（原因：如果没有找到指定字体，会找一个与指定字体最接近的通用字体）
- 设置多个字体（首先确定这些字体的优先顺序，然后用逗号把他们连起来，如：
![多字体](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%A4%9A%E5%AD%97%E4%BD%93.png)
    使用引号：
	    ①只有当一个字体名称中有一个或多个空格（如New York），或者如果字体名包括#或者$之类的符号，才需要在font-family声明中加引号；
	    ②如果没有引号，尽管规则的余下的部分会得到处理，但用户代理有可能忽略这个特定的字体名;
	    ③字体名中如果只包含一个词,而且这个词与font-family的任何关键字都不冲突,就不需要加引号,通用字体系列名在指定具体的通用系列时不能加引号,如果加上引号,代表特定字体;
	    ④双引号或单引号都可以,但是如果把一个font-family规则放在style属性里,则需要使用该属性本身未曾使用的那种引号;

## 2. 字体加粗和变细：
- 属性font-weight定义 
     关键字100-900、bold、bolder,400等价于normal,700等价于bold（bolder的使用方法，根据字体的设置级别）
     关键字lighter

## 3. 字体大小：
- 属性font-size定义
    2个相对大小关键字larger和smaller；
    7个绝对大小值xx-small、x-small、small、medium、large、x-large、xx-large；
    百分数值总是根据从父元素继承的大小来计算；
    字体可以继承，继承的是计算值而不是百分比，百分比可以累积；
    使用长度单位（不建议）；
    使用px定义

## 4. 字体风格：
- 属性font-style定义
    normal（默认）、italic、oblique
    italic（斜体）和oblique（倾斜）的区别

## 5. 字体变形:
- 属性font-variant定义
    normal(默认)、small-caps

## 6. font属性:
![font](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/font.png)
- ①只是font的前3个值允许采用任何的顺序，后两个font-size、font-family要按照以此顺序作为声明中的最后两个值，font声明必须有这两个值；
- ②font可以设置line-height，并且总是在font-szie之后，两者用斜线(/)与分割；
- ③适当的使用简写，在使用简写属性font时，所以被忽略的值都会重置为其默认值；
- ④如果希望一个Web页面结合用户操作系统的设置，使用系统字体，这些值用于取得操作系统中元素的字体大小，自体系列，字体加重，字体风格，字体变形（后面两个被废除），并将其应用到一个元素。这些值如下：caption（用于有标题的控件，如按钮），icon（用于对图标加标签），menu（用于菜单，即下拉菜单和菜单列表），message-box（用于对话框），small-caption（用于对小控件加标签），status-bar（用于窗口状态条）；注意，系统字体可能只能整体设置；（注意，以前不知道）
- @font-face规则：
    ①重要，在css2中有，但是css2.1中删除，css3中重新；
	②字体名匹配；
	③智能字体匹配；
	④字体合成；
	⑤字体下载；

# 六、文本属性
## 1. 缩进和水平对齐：
- 缩进text-indent：①所有元素第一行都可以所以给定长度，可以是负值，最常见的用途是段落的首行缩进；②块级元素可以使用，行内元素无法使用，图像之类的替换元素也无法使用（行内元素的缩进可以使用左内边距或者外边距创造这种效果）；③负值最常见的用途是一种“悬挂缩进”，即第一行悬挂在元素中余下部分的左边；④可以使用所有长度单位（包括百分数值）；⑤这个属性可以继承；
- 水平对齐text-align：①值left，center，right会导致元素中的文本分别左对齐，居中，右对齐；②只能应用于块级元素；③西方语言默认值是left，希伯来语和阿拉伯语之类的语言默认值是right；④值justify，两段对齐，显示方式有问题，不统一；⑤css没有指定应该如何处理连字符；

## 2. 垂直对齐：
- 行高line-height控制了行间距；
- 构造文本行；
- 指定line-height值：默认值normal，通常是字体大小的1.2倍（只是通常），大多数值都是简单的长度单位；
- 行高和继承：line-height值从父元素继承时，要从父元素计算，而不是在子元素上计算；解决继承问题的办法是制定一个数，有它设置缩放因子，此时缩放因子将是继承值而不是计算值，该数会应用到该元素及其所有的子元素;

## 3. 垂直对齐文本:
- vertical-align属性值应用与行内元素和替换元素,此属性不能继承;此属性只接受八个关键字、一个百分数值(相对于元素的line-height值)或一个长度值，包括baseline（默认值）、sub、super、bottom、text-bottom、moddle、top、text-top;应用到表单元格时,只能识别baseline、top、middle和bottom等，并且影响元素的垂直对齐；
- 基线对齐：vertical-align:baseline，如果是一个图像或者表单输入元素，或者是其他替换元素----那么该元素的底端与其父元素的基线对齐；
- 上标和下标：vertical-align:sub声明会使用一个元素变成下标，无具体规定元素降低的距离，所以不同用户代理，距离可能不同；super为上标，同样，距离不定；
- 底端对齐：vertical-align:bottom,text-bottom指行内文本的底端，替换元素或者其它类型的非文本元素会忽略这个值；
- 顶端对齐：vertical-align:top；
- 居中对齐：vertical-align:middle,往往应用于图像；
- 百分数：会把元素的基线（或者替换元素的底边）相对于父元素的基线升高或者降低指定的量（指定的百分数要计算为该元素line-height的百分数，二不是相对于其父元素的line-height），正百分比使元素升高，负值则会使其降低。

## 4. 字间隔和字母间隔:
- 字间隔:word-spacing,可以我正长度值或负长度值,这个长度会增加到字之间的标准间隔,默认值normal与设置值为0是一样的;"字"没有明确定义;
- 字母间隔:letter-spacing,①值同字间隔一样,与字间隔遇到同样的问题;可以用来突出强调效果;②间隔与对齐:值可能受text-align属性值的影响;无法为word-spacing或letter-spacing定义一个可继承的缩放因子来取代计算值;

## 5. 文本转换:
text-transform,默认值none对文本不做任何改动,将使用源文档中原有的大小写,uppercase和lowercase将文本转换为全大写或全小写字符,capitalize只对每个单词的首字母大写;

## 6.文本装饰:
- ①text-decoration,值underline下划线,overline上划线,line-through贯穿线,blink文本闪烁,none删除装饰;可以在一个规则中结合多种装饰(例如a:link,a:visited{text-decoration:underline overline;} );
- ②怪异的装饰:text-decoration不能继承；改变装饰的颜色可以定义子元素的颜色和子元素的装饰属性；

## 7. 文本阴影：
text-shadow，CSS2支持，css2.1不支持，css3支持；默认无阴影，可以定义一个或多个阴影；每个阴影由一个颜色和三个长度值定义，前两个长度 值确定了阴影与文本的偏移距离，第三个长度值可选，定义了阴影的“模糊半径”；负长度值会使阴影落在原文的左上方；

## 8. 处理空白符：
white-space，它会影响用户代理对源文档中空格、换行和tab字符的处理；值normal会丢掉多余的空白符，值pre，空白符不会被忽略；值nowrap会防止元素中的文本换行，可以使用white-space替换表单元格上的nowrap属性；值pre-wrap会使文本保留空白符，但是文本行会正常换行；值pre-line会合并空白符，但保留换行符；
![white-space](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/white-space.png)

## 9. 文本方向：
- direction，影响块级元素中文本的书写方向，表中列布局的方向、水平内容填充其元素框的方式，及两端对齐元素中最后一行的位置；对于行内元素，只有当unicode-bidi属性设置为embed或bidi-override时才会应用direction属性；有值ltr和rtl；
- unicode-bidi：
![unicode-bidi](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/unicode-bidi.png)

# 七、基本视觉格式化
## 1. 基本框
元素框：内容区、内边距、边框、外边距；  
内容的背景会应用到内边框，外边框通常是透明的，从中可以看到父元素的背景；内边距不能是负值，外边距可以；边框没有设定颜色，那么边框将取元素内容的前景色，边框与内容和内边距有相同的颜色，边框的宽度绝对不能为负；  
包含块：包含块有最近的块级祖先框、表单元格或者行内块祖先框的内容边界构成；

## 2. 块级元素
### 2.1 水平格式化：
①width影响的是内容区的宽度；  
②设定padding、border、margin后会隐式的增加width的值；  
③正常流中块级元素框的水平部分综合就是等于父元素的width；  

#### 2.1.1 水平格式化的“7大属性”：
①margin-left,border-left,padding-left,width,padding-right,border-right,margin-right,这些属性和块级框的水平布局有关，这七个属性的值加在一起必须是元素包含块的宽度；  
②只有3个属性可以设置为auto：width，margin-left，margin-right，其余的必须设置为特定的值，或者默认宽度为0；  
③width不许设置为auto或者某种类型的非负值；

#### 2.1.2 使用auto
①从每种程度上讲，可以使用auto弥补实际值与所需总和的差距；（如七个属性和为400px，无内边距或边框，右外边距和width都是100px，做外边距为auto，那么做外编剧的宽度将是200px）；   
②如果所有的三个属性都设置为非auto的每个值，此时总会把margin-right强制为auto（如三个值都是100px，七个属性和为400px，那么margin-right会自动变为auto，此时margin-right的值为200px）；   
③如果两个外边距都是显式的设置，而width设置为auto，width值将自动填充所需要的值，从而达到需要的总宽度（即父元素的内容宽度）；

#### 2.1.3 不只一个auto
①如果两个外边距都设置为auto，那么元素在其父元素中居中；   
②将某个外边距以及width设置为auto，设置为auto的外边距会减为0，然后width会设置为所需的值，使得元素完全填充其包含块；  
③如果3个属性都设置为auto，那么两个外边距都会设置为0，而width会尽可能的宽（width默认为auto），这种结果与默认情况是相同的，即没有外边距或者width显式声明任何值；

#### 2.1.4 负外边距
外边距可以为负，如果设置了负外边框，那么子元素的边框可能会大于父元素的宽；如果子元素的整体的width大于父元素的宽度，那么子元素的margin-right会默认为auto，此时auto的值为负数；
**内边距、边框和内容宽度（及高度）绝对不能为负，只有外边距能小于0；**

#### 2.1.5 百分数
如果width、内边距和外边距设置为百分数值，会应用相同的基本规则；**基本原则是：只使用百分数将无法创建完全灵活的元素布局（即所有的属性都可设置），，除非你不行使用边框；**

#### 2.1.6 替换元素
非替换元素的所有规则适用于替换块元素，只有一个例外：如果width为auto，元素的宽度则是内容的固有宽度；高宽成比例缩放，除非height自己也显式的设置为一个特定值。

### 2.2 垂直格式化 ###
一个元素的more高度由其内容决定，还受内容宽度的影响，宽度越小，高度越高；   
如果块级元素的指定高度大于显示内容所需的高度，多余的高度会产生一个视觉效果----好像有额外的内边距一样；   此时用户代理的具体行为将取决于overflow属性的值；
如果块级元素的指定高度小于显示内容所需的高度，浏览器一般会向元素增加一个滚动条以便查看所有内容；   

#### 2.2.1 垂直属性
①垂直格式化也有七个相关的属性：margin-top、margin-bottom、padding-top、pading-bottom、border-top、border-bottom和height；这7分属性的值必须等于元素包含块的height，这往往是块级元素父元素的高度的height值（因为块级元素的父元素几乎都会计元素）；   
②7个属性值3个可以设置为auto：height、margin-top、margin-bottom；其他的必须设置为特定的值，或者默认为0（没声明border-style）,如果已经设置了border-style，边框的宽度会设置为值medium（这个值的定义并不明确）；   
③如果正常六种的一个块元素的margin-top和margin-bottom设置为auto，它会自动计算为0，但是这样就不能很容易的将正常流元素在其包含块中垂直居中；   
④height必须设置为auto或者是某种类型的非负值；

#### 2.2.2 百分比高度
如果没有显式声明包含块的height，百分比会重置为auto；

#### 2.2.3 auto高度
最简单的情况下，如果块级正常流元素height:auto，显示其高度将恰好足以包含其内联内容（包括文本）的行高；
如果块级正常流元素height:auto，且只有块级子元素，默认高度将是最高块级子元素的外边框到最低块级子元素外边框边界之间的距离，此时子元素的外边距会“超出”包含这些子元素的元素；  

#### 2.2.4 合并垂直外边距
垂直相邻外边距合并，只是用于外边距，而且是同级元素的合并（不知道此话是否正确）

#### 2.2.5 外负边距
如果垂直外边距都设置为负值，浏览器会 取两个外边距绝对值的最大值；如果一个正外边距与一个负外边距合并，会从正外边距减去这个负外边距的绝对值；

### 2.3 列表项 ###
列表项前面通常有一个标志，这个标志不是列表项内容区的一部分；list-style-position可以决定标志放在列表项的内容之外还是列表项的内容开始处；

## 3. 行内元素 ##
### 3.1 行布局 ###
单行行内元素和多行行内元素的比较；   
text-align设置不同的值的时候显示的不同；

### 3.2 基本术语和概念 ###
- 匿名文本：指所有未包含在行内元素中的字符串；空格也是匿名文本的一部分；
- em框：在字体中定义，也称为字符框；
- 内容区：在非替换元素中国，内容区可能有两种，一种是元素中各字符的em框串在一起构成的 框，另一种是由元素中字符字形描述的框；在替换元素中，内容区就是元素的固有高度再加上可能有的外边框。边距和内边距；
- 行间距：是font-size值和line-height值只差，只能用于非替换元素；
- 行内框：通过想内容区增加行间距来描述；对于非替换元素，元素行内框的高度等于line-height的值；对于替换元素，元素行内框的高度等于内容区的高度；
-----
![](http://i.imgur.com/SKGboDx.png)

### 3.3 行内格式化 ###
line-height实际上只影响行内元素和其他行内内容，而不影响块级元素（至少不会直接影响）；为块级元素设置line-height值，但是这个值只是应用到块级元素的内联内容时才会有视觉影响；   

### 3.4 行内非替换元素 ###
- 建立框：行内框是有font-size和line-height的差决定的；
- 垂直对齐：如果改变行内框的垂直对齐，会应用同样的高度确定原则；
- 管理line-height：避免内容重叠----①对font-size有改变的元素结合使用em单位；②增加段落的line-height；
- 缩放行高：设置line-height的最好办法是使用一个原始数字值（即不带单位的值），这个数会成为缩放因子，该因子是一个继承值而非计算值；如果设置line-height的值1.0，那么行高恰好能包含行内容，而没有多余的空间；
- 增加框属性：行内元素的边界是由font-size控制；内边距、外边距和边框不改变行高，但是会影响文本的显示样式，这样可能会影响行高，比如设置内边距，外边距等，这样会影响整体的行高；

### 3.5 行内替换元素 ###
一般认为行内替换元素（如图像）有固定的宽度和高度，这可能导致行框比正常要高；这不会改变行中任何元素的line-heitght值，包括替换元素本身，只会让行框的高度恰好包含替换元素（以及所有框属性）；
- 增加框属性：为行内替换元素增加内边距、边框和外边据会增大其行内框，负外边距会是替换元素行内框小于正常大小，可能大致行内替换元素挤入其他行（这个是唯一办法）；
- 替换元素和基线：默认行内替换元素位于基线上；替换元素没有自己的基线，实际上下外边距边界与基线对齐；

## 4. 改变元素显示 ##
使用display元素改变；
-  改变角色：通过使用diaplay的值block和line改变为块元素或者行内元素的角色，但是元素本身不会改变，只是元素的显示方式不同；
- 行内块元素：line-block是一个混合产物，它会作为替换元素放在行中；它的底端默认地位于文本框的基线上，而且内部没有分割符；   
在行内块元素内部，会像块级元素一样设置内容的格式，它有属性width和height；
- rin-in元素：rin-in可以使某些块级元素成为下一个元素（一个块级行内框）的行内部分；rin-in框是从文档的父元素中继承属性，而不是说它们放在那个元素中就从哪个元素继承属性；**关注一下支持性！！！**
- 计算值：如果元素是浮动元素或定位元素，display的计算值可能改变；

# 八、内边距、边框和外边距 #
## 1. 基本元素框 ##
所有文档元素都生成一个矩形框，这称为元素框，它描述了一个元素在文档布局中所占的空间大小；
- 宽度和高度：一个元素width被定义为从左内边距到右内边距的距离，height被定义为从上内边距到下内边距的距离；它们不能应用到行内非替换元素； **宽高如何显示的问题在CSS3中定义了：[CSS3 box-sizing 属性](http://www.w3school.com.cn/cssref/pr_box-sizing.asp)**  
- 外边距和内边距：如果元素有背景，背景会延伸到内边距中，但不会延伸到外边距；

## 2. 外边距 ##
最简单的是设置margin，marging默认值为0；实际中，浏览器对外边距提供了预定的样式，所有最好是进行重置样式；
- 长度值和外边距：（margin: top right bottom left;）   
- 百分数和外边距：**元素的外边距设置为百分数值，百分数值相对于父元素的width计算的（上下边距也是如此）**；
- 值复制：(margin: top+bottom right+left) (margin:top+right+bottom+left) (margin:top left+right bottom)
- 单边外边距属性：margin-left、margin-right、margin-top、margin-bottom,可以同时使用多个单边属性 ；
- 外负边距和合并外边距：设置外负边距会使内容超过父元素的width；正常流中垂直相邻外边距会合并；
- 外边距和行内元素：①上下外边距应用到行内非替换元素无效；②左右外边距应用到行内非替换元素有效，并且左外边距应用到此行内元素的开始处，右外边距应用到此行内元素的末尾；③如果对行内非替换元素应用负外边距，元素的上下外边距不受影响，行高不受影响，但是左右两端可能与其他内容重叠；④为行内替换元素设置的外边距影响行高，可能使行高增加或减少，这取决于上下外边距的值，行内替换元素左右外边距与非替换元素的左右外边距的作用一样；

## 3. 边框 ##
边框宽度默认为medium，此值无明确定义，通常2px；边框默认样式为none；默认的边框颜色是元素本身的前景色，如果没有声明边框颜色，他将与元素的文本颜色相同，如果一个元素无任何背景，那么元素的边框颜色就是父元素的文本颜色；
- 边框和背景：元素的背景是内容、内边距和边框区的背景；
- 有样式的边框：border-style定义了10个不同的非inherit样式，包括默认值none；样式值hidden等价于none，不过应用于表时除外，对于表，hidden用于解决边框冲突；double属性值不确定显示样式；①多种样式：(border-style:top right bottom left),可以用多个值设置不同的边框；②单边样式：border-top-style、border-right-style、border-bottom-style、border-left-style；单边样式和多种样式结合使用时，一般把border放在前面，单边颜色放在后面；
- 边框宽度：可以使用border-width、border-top-width、border-left-width、border-bottom-width、border-right-width，可以设置长度值，或者使用三个关键字（宽度比较：thin<medium（默认值）<thick，具体的宽没有定义，用户代理可以自定义）之一；只有当有边框样式时才有边框宽度，因为边框样式默认为none，所有边框样式需要显式定义，当边框样式为none时，边框宽度为0；
- 边框颜色：border-color、border-top-color、border-right-color、border-bottom-color、border-left-color；边框颜色值transparent，用于创建有宽度但不可见的边框（透明边框）；
- 简写边框属性：border-bottom、border-top、border-left、border-right，在设置时，具体值的顺序并不重要，还可以省略一些值（不能省略边框样式，如果省略，默认为none），使用其默认值，且每个值只有一个；
- 全局边框：border设置，应用到所有4个边，如果希望一个元素有不同的边框，则需要使用另外的某个边框属性（可以利用层叠）；
- 边框和行内元素：对于行内非替换元素，上下边框增加不会影响行高，但是边框会显示出来，左右边框会正常显示；

## 4.内边框 ##
使用padding定义；默认元素没有内边距；内边框不合并；
- 百分数值和内边距：内边距可以设置百分数值，百分数值相对于其父元素的width计算；
- 单边内边距：padding-left、padding-right、padding-top、padding-bottom；
- 内边距和行内元素：左右内边距可见，行高不变，上下内边距也会向元素上面和下面延伸；
- 内边距和替换元素：不论替换元素是块级元素还是行内元素，内边距都会围绕其内容，背景色将填入该内边距；可以向图片应用内边距；

# 九、颜色和背景 #
## 1. 前景色 ##
设置元素的前景色，最简单的办法是利用属性color；   
通常最好同时设置前景和背景色；   
- 替换属性：最基本的用法，替换body属性text、link、alink和vlink
- 影响边框：如果未设置边框颜色，前景色会应用到边框；
- 影响表单元素：可以为表单元素设置color值；
- 继承颜色：color是可以继承的；

## 2. 背景 ##
元素的背景区包括内容框和内边距，边框画在背景之上；CSS可以使用纯景作为背景，也可以使用图像做背景；**所有的背景属性都不能继承；**
- 背景色：background-color，可以是合法颜色，也可以是transparent（默认值）；不能继承；
- 背景图像：background-image，默认值是none，可以指定一个url值；允许向任何元素应用背景图像，可以是块级元素也可以是行内元素；不能继承；设置背景图像的同时最好再指定一个背景色；
- 有方向的重复：background-repeat，值repeat-x和repeat-y分别导致图像只是在水平或者垂直方向上重复，no-repeat则不允许在任何方向上平铺；默认的，背景图像将会从一个元素的左上角开始；
- 背景定位：①background-position，默认值为0% 0%，可以用关键字top、bottom、left、right、center（通常会成对出现，一个对应水平方向，一个对应垂直方向，如果只出现了一个关键字，则认为另一个关键字是center），②可以使用长度值（以图像的左上角为偏移点），③也可以使用百分数值（如果用百分数值设置位置，水平值总是先出现，如果只有一个百分数值，这额值将作为水平值，垂直值假设为50%；）；④根据background-position，将相对于元素的内边距边界放置原图像；⑤允许关键字与其他值混用；⑥如果使用长度值或者百分数值，可以使用负值将原图像拉出元素的背景区；
- 有方向的重复（深入）：根据background-position的值的不同，平铺的起始位置也是不同的；
- 关联：background-attachment，声明原图像相对于可视区是固定（fixed）的；默认值scroll，会导致背景随其余文档滚动；
- 汇总：background，可以从各个其他背景属性取一个值，而且可以采用任何顺序；实际上对background中值的顺序有一个小小的限制----如果background-position有两个值，它们必须一起出现，而且如果这两个值是长度值或者百分数值，则必须按水平值在前垂直值在后的顺序；如果省略了某些值，就会自动填入相应属性的默认值；background没有必不可少的值，只要至少出现一个值就行；

# 十、浮动和定位 #
## 1. 浮动（float） ##
### 1.1 浮动元素 ###
- 会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局；
- 一个元素浮动时，其他内容会“环绕”该元素；
- 浮动元素周围的外边距不会合并；
- 要浮动一个非替换元素，必须为该元素声明一个width，否则，元素的宽度趋于0；
- float:none用于防止元素浮动；默认元素为这个值；

### 1.2 浮动的详细内幕 ###
- 浮动元素的包含块是其最近的块级祖先元素；
- 浮动元素会生成一个块级框，而不论这个元素本身是什么；
- 浮动元素的左（或右）外边框不能超过其包含块的左（或右）内边界；
- 浮动元素的左（或右）外边界必须是源文档中之前出现的左浮动（或右浮动）元素的右（或左）外边界，除非后出现浮动元素的顶端在先出现浮动元素的底端下面；防止元素相互覆盖；
- 左浮动元素的右外边界不会在其右浮动元素的左外边界的右边；一个右浮动元素的左外边界不会在其左边任何左浮动元素的右外边界的左边；
- 一个浮动元素的顶端不能比其父元素的内顶端更高；如果一个浮动元素在两个合并外边距之间，放置这个浮动元素就好像在两个元素之间有一个块级父元素；
- 浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高；
- 如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高；
- 左（或右）浮动元素的左边（右边）有另一个浮动元素，前者的右外边界不能在其包含块的右（左）边界的右边（左边）；即浮动元素不能超过其包含元素的边框，除非它太宽，本身都放不下；
- 浮动元素必须尽可能高地放置；
- 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远；

### 1.3 实用行为 ###
- 浮动元素比父元素高时，会超出其父元素的底端；
- 浮动元素会延伸，从而包含其所有后代浮动元素；
- 负外边距可能导致浮动元素移到其父元素的外面；
- 浮动元素比其父元素更宽时，浮动元素会超出左或右内边界，究竟是超出左内边界还是右内边界，取决于元素以何种方式浮动；

### 1.4 浮动元素、内容和重叠 ###
- 行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素“之上”显示；
- 块框与一个浮动元素重叠时，其边框和背景在该浮动元素“之下”显示，而内容在浮动元素之上显示；

### 1.5 清除 ###
clear，值有left、right、both、none；  
清除区域：是在元素上外边距之上增加的额外间隔，不允许任何浮动元素进入这个范围之内；这意味着元素设置clear属性时，它的外边距并不改变；

## 2. 定位 ##
### 2.1 基本概念 ###
- 定位的类型：通过使用position属性，可以选择4种不同类型的定位：static（元素框正常生成）、relative(元素框偏移某个距离)、absolute（元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块）、fixed（元素框的表现类似与将position设置为absolute，不过其包含块是视窗本身）；
- 包含块：①“根元素”的包含块是由用户代理建立；②对于一个非根元素，如果其position值是relative或static，包含块则由最近的块级框、表单元格或者行内块祖先框的内容边界构成；③对于一个非根元素，如果其position值是absolute，包含块设置为最近的position值不是static的祖先元素（可以是任何类型）；
- 偏移属性：三种定位机制使用了4个属性来描述定位元素各边相对于其包含块的便宜，它们是：top、left、right、bottom；

### 2.2 宽度和高度 ###
- 设置宽度和高度：可以直接使用width和height设置，也可以使用top、left、right、bottom来描述4个边的放置位置，使元素的宽度和高度由这些偏移隐含确定；如何设置了外边距、边框或内边距，此时如果为height和width显式指定了值，可能会使定位元素延伸超出其包含块，解决这个问题可以去除height和width声明，或者显式地将其设置为auto；
- 限制宽度和高度：使用min-width、min-height、max-width、max-height可以限制宽度和高度；

### 2.3 内容溢出和剪裁 ###
- 溢出：利用overflow属性控制溢出问题，属性值包含visible（元素的内容在元素框之外也可见）、scroll（元素的内容会在元素框的边界处剪裁，不过始终提供某种滚动机制使额外的内容能够看到）、hidden（元素的内容会在元素框的边界处剪裁，不过不会提供滚动接口使用户访问超出剪裁区域的内容）、auto（允许用户代理来确定采用何种行为，一般解释为“只有必要时提供滚动条”）；
- 内容剪裁：属性clip可以改变剪裁区域的形状，auto（表示元素的内容不应剪裁）、rect(top,right,bottom,left)（剪裁为一个矩形框，4个值不是边偏移，而是距元素左上角的距离；如果一个剪裁矩形涵盖元素左上角20*20px的一个正方形，可以用rect(0,20px,20px,0)表示；4个值只允许长度值和auto，auto相当于将剪裁边界设置为适当的内容边界）；

### 2.4 元素可见性 ###
使用visibility控制真个元素的可见性，visible（可见）、hidden（不可见，但是会占据位置，影响布局）、collapse(对于非表元素，collapse与hidden含义相同)；

### 2.5 绝对定位 ###
- 包含块和绝对定位元素：①绝对定位元素额包含块是最近的position值不为static的祖先元素；②通常会选择一个元素作为绝对定位元素的包含块，将其position指定为relative而且没有偏移；③可能需要给body元素为其所有的后代建立一个包含块，而不是让用户代理选择初始包含块；④元素绝对定位时，还会为其后代元素建立一个包含块；⑤如果文档可滚动，定位元素会随着它滚动（绝对定位元素是固定定位元素的后代除外）；
- 绝对定位元素的放置和大小：①如果绝对定位元素设置top、right、bottom、left，不设置宽高，那么宽高会根据四个偏移属性来定位大小；②如果四个偏移属性和宽高同时设置了，那么其中的值可能是错误的，相应的错误值会被忽略掉；③到底哪个值是错误的，取决于很多因素，而且根据元素是否是替换元素有所不同；
- 自动边偏移：①元素绝对定位时，left设置为auto，元素的左边界会相对于其包含块的左边界放置（假设其包含块是初始包含块）；②对于top，定位元素的顶端要相对于其未定位前本来的顶端位置对齐（换句话说，元素的position值为static时，处于的静态位置就是其顶边应在的位置）；
- 非替换元素的放置和大小：①一般元素的大小和位置取决于其包含块；②如果left、width和right都设置为auto，左边界置于其静态位置（假设使用从左到右的语言）；③元素的width设置为“收放得正好合适”，说明该元素的内容区宽带恰好只能包含其内容（而没有多余空间）；④非静态位置属性（从左到右的语言是right）要适当设置，以保证余下 的距离；⑤如果左右外边距都设置为auto，而left、width和right不是auto，此时左右外边距会设置为相等的值，实际上让元素居中；如果外边距不为auto，用户代理会忽略right的值（从左到右的语言中），并重置right的值；⑥如果左外边距为auto，则会重置左外边距；⑦一般地，如果只有一个属性设置为auto，就会修改这个属性来满足下面的等式`left+margin-left+border-left-width+padding-left+width+padding-right+border-right-width+margin-right+right=包含块的width`；⑧如果只是把width设置为auto，left、right，margin-left和margin-right不为auto，元素会延伸到必要的宽度，而不是“收缩”内容；⑨对于垂直轴，规则和水平轴非常类似；
- 替换元素的放置和大小：①替换元素有固定的高度和宽度，其大小不会改变，因此在替换元素定位中没有“恰当收放”行为的概念；②如果width设置为auto，则width的实际使用值由元素内容的固有宽度决定；如果显式声明了width，则width设置为该值；③从左到右的语言中，如果left值为auto，要把auto设置为静态位置；从右向左的语言中，则吧right的auto值替换为静态位置；④如果left或right仍为auto，则将margin-left或margin-right的auto值替换为0；⑤如果此时margin-left和margin-right都还定义为auto，则把它们设置为相等的值，从而将元素在其包含块中居中；⑥在此之后，如果只剩下一个auto，则将其修改为等于等式的余下部分；⑦与非替换元素一样，如果值过度受限，用户代理会忽略right的值；⑧垂直轴的布局与水平轴的规则类似；
- Z轴上的放置：①利用z-index，可以改变元素相互覆盖的顺序，z-index的值越大，层次越靠前，离读者越近；②所有整数都可以作为z-index的值，包括负数，负数层次更靠后，离读者更远；③没有特别要求z-index值是连续的;④为一个元素指定了z-index值（不是auto），该元素就会建立自己的局部叠放上下文（该元素位于此上下文z轴的0位置），这意味着元素的所有后代相对于该祖先元素都有其自己的叠放顺序；⑤如果元素设置为z-index:auto，可以将其处理为z-index:0；

### 2.6 固定定位 ###
- 固定定位的包含块是视窗，元素完全从文档流中去除；
- 可以使用固定定位创建帧式界面，也可以在屏幕上放置一个“永久性”元素；

### 2.7 相对定位 ###
- 通过使用偏移属性移动定位元素；
- 元素相对定位时，会从其正常位置移走，不过原来占据的空间不会消失；
- 如果相对定位一个元素，它会立即为其所有子元素建立一个新的包含块；这个包含块相对于该元素原本所在的位置；
- 如果遇到过度受限的相对定位，一个值会重置为另一个值得相反数，right总是等于-left（从左到右的语言中），bottom总是等于-top；

# 十一、表布局 #
## 1. 表格式化 ##
### 1.1 表的视觉编排 ###
- 在CSS中，内部表元素生成矩形框，这些框有内容、内边距和边框，但是没有外边距（设置外边距会被忽略，只有总标题例外）；
- 表编排规则：表格单元是矩形，不过不必都是相同的大小；给定表格列中的所有表格单元宽度相等，一个表格行中的所有表格单元则高度相等；不同表格行的高度可能不相等；

### 1.2 表显示值 ###
- 在XML中无法从根本上知道哪些元素可能是表的一部分，所有引入了一组display值（在html代码中也可以使用），与表有关的值由table（指定一个元素定义了一个块级表，相当于html元素的table）、inline-table（指定一个元素定义了一个行内级表，与inline-block类似）、table-row（指定一个元素是一个单元格的行，相当于html元素的tr）、table-row-group（指定一个元素是一个或多个行的组，相当于html元素的tbody）、table-header-group（标题行，可以是多行的标题行组，相当于html元素的thead）、table-footer-group（脚注行，可以是多行的脚注行组，相当于html元素的tfoot）、table-column（指定一个元素是一个单元格的列，相当于html元素的col元素）、table-column-group（声明一个元素是一个或多个列的组，相当于html元素的colgroup元素）、table-cell（指定一个元素是表中的单个单元格，相当于html元素的th或td）和table-caption（定义一个表的总标题，建议只有一个）；
- 以行为主：css将其表模型定义为“以行为主”；
- 列：在css中列和列组只能接受4种样式border（只有当border-collapse属性值为collapse时才能为列和列组设置边框）、background（只有当单元格及其行有透明背景时，列或列组的背景才可见）、width（定义了列或列组的最小宽度）和visibility（如果一个列或列组的visibility为collapse，则该列或列组中所有单元格都不显示；如果为非collapse值，则会被忽略）；

### 1.3 匿名表对象 ###
- 可能未包含足够的元素，css为此定义了一种机制，可以将“遗漏的”组件作为匿名对象插入；
- 插入对象规则：①一个table-cell元素的父元素不是table-row元素，则会在该元素及其父元素直接插入一个匿名table-row对象，所插入的这个对象将包含该table-cell元素的所有连续兄弟；②一个table-row元素的父元素不是table、inline-table或table-row-group元素，则会在该元素及其父元素之间插入一个匿名的table元素，所插入的这个对象将包含该table-row元素的所有连续兄弟；③一个table-column元素的父元素不是table、inline-table或table-row-group元素，则会在该元素及其父元素之间插入一个匿名的table元素;④一个table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则会在该元素及其父元素之间插入一个匿名的table元素；⑤一个table或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素，则在该table元素与其子元素之间插入一个匿名的table-row对象；这个匿名对象将包含该子元素的所有不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的连续兄弟；⑥一个table-row-group、table-header-group、table-footer-group元素的子元素不是table-row元素，则在该元素及其子元素之间插入一个匿名table-row对象，这个匿名对象包含该子元素的所有本身非table-row对象的连续兄弟；⑦一个table-row元素的子元素不是table-cell元素，则在该元素和其子元素之间插入一个匿名table-cell对象，这个匿名对象包含该子元素的所有本身非table-cell元素的连续兄弟；

### 1.4 表层 ###
为了完成表的显示，css定义了6个不同的“层”，可以分别放表的不同方面，如下图所示：![table](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/table.png)
基本上，对应表各个方面的样式都在其各自的层上绘制；顶层对应表单元格，将最后绘制；列样式在行样式的下面，所以行背景会覆盖列背景；默认的，所有元素背景都是透明的；

### 1.5 表标题 ###
- 利用属性caption-side，可以把标题内容放在table之上，也可以放在table之下，而不论该表标题出现在表结构中的哪个位置（在HTML中，captain元素只能出现在开始table元素的后面）；
- 表标题格式化好像它直接放在表框之前（或之后）的一个块框，有两点不同：一是表标题仍能从表y继承值，二是用户代理在考虑如何处理表前面的run-in元素时会忽略表标题框；
- captain-side的值有top（默认值）和bottom，应用于display值为table-caption的元素；

## 2. 表单元格边框 ##
- border-collapse：collapse（采用合并边框模型）、separate（默认，采用分隔边框模型）、inherit，应用于display值为table或inline-table的元素；

### 2.1 分隔单元格边框 ###
- 采用这种模型，表中的每个单元格与其他单元格分开一定距离，而且单元格的边框彼此不会合并；
- 在分隔边框模型中，不能为行、行组、列和列组设置边框；如果这些元素声明了边框属性，都会被CSS兼容的用户代理所忽略；
- 边框间距border-spacing:length、inherit,默认值为0；应用于display值为table或inline-table的元素，会应用于表本身，而不是单个的单元格；除非border-collapse值为separate，否则会忽略该属性；可以为这个属性指定一个或两个长度值，如果一个值代表上下左右都是这个值，如果两个值，第一个代表水平间隔，第二个代表垂直间隔；表外围的单元格边框与表元素本身的内边距之间也可以指定间隔值；
- 处理空单元格empty-cells:
	show（默认，会画出空单元格的边框和背景，就好像这些表单元格有内容一样）、hide（不会画出该单元格的任何部分，就好像这个单元格被设置为visibility:hidden）、inherit；应用于display值为table-cell的元素；除非border-collapse值为separate，否则会忽略该属性；
	如果一个单元格包含内容（“内容”不仅包含文本、图像、表单元等，还包含&nbsp;和除CR(回车)、LF(换行)、tab和空格符以外的所有其他空白符），则不能认为是空的；
	如果一行中所有单元格都为空，而且empty-cells值都是hide，则整行将处理为好像这个行元素设置为display:none；

### 2.2 合并单元格边框 ###
合并单元格边框和分隔单元格边框的区别
![合并单元格边框和分隔单元格边框的区别](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E8%BE%B9%E6%A1%86.png)
- 合并边框布局：`row width = (0.5*width0)+padding-left1+width1+padding-right1+border-width1+padding-left2+...+padding-rightn+(0.5*border-widthn)`;如果边框的宽度是一个奇数，用户代理将采用合适的方式绝对边框在表格线上显示；
- 边框合并：
![边框合并规则](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E8%BE%B9%E6%A1%86%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99.png)

## 3. 表大小 ##
### 3.1 宽度 ###
- 确定表的宽度，有两种不同的方法：固定宽度布局和自动宽度布局；无论使用何种宽度算法，高度都是自动计算；两者之间最显著的差异是速度，使用固定宽度表布局时，相对于自动宽度模型，用户代理可以更快地计算出表的布局；
- table-layout:auto(默认)、fixed、inherit,应用于display值为table或inline-table的元素；
- 固定宽度：这种方法的所有列宽度都是由表的第一行定义，非首行的单元格指定的width值都会被忽略；如果一个单元格的内容放不下，该单元格的overflow值将决定单元格内容是剪裁、可见还是生成一个滚动条；
![固定宽度](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%9B%BA%E5%AE%9A%E5%B8%83%E5%B1%80.png)
- 自动布局：在用户代理查看完表的所有内容之前无法确定表的布局（即自动布局要求用户代理每得到一个新单元格时都是完成整个表的布局）；
![自动布局1](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%801.png)
![自动布局2](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%802.png)

### 3.2 高度 ###
- 直接由height属性显示设置高度，代表最小高度；
- 如果表的高度是auto，其高度则是表中所有行的行高加上所有边框和单元格间隔的综合；
- 表的高度计算很大程度上留给用户代理来决定，要尽可能避免设置高度；

### 3.3 对齐 ###
- 水平对齐使用text-align属性；
- 垂直对齐（很容易影响行高）使用vertical-align属性：①top，单元格内容顶端与其行顶端对齐；对于跨行单元格，单元格内容的顶端与其所跨的第一行的顶端对齐；②bottom，单元格内容底端与其行底端对齐；对于跨行单元格，单元格内容的底端与其所跨的最后一行的底端对齐；③单元格内容的中间与其行中间对齐；对于跨行单元格，单元格内容的中间与其所跨行的中间对齐；④baseline，单元格的基线与其行的基线对齐；对于跨行单元格，该单元格的基线与所跨的第一行的基线对齐；

# 十二、列表与生成内容
CSS允许创作人员定义自己的计数模式和格式，而且可以将这些计数器与任何元素关联，而不只是有序列表；

## 1. 列表 ##
### 1.1 列表类型 ###
list-style-type: disc(默认) | circle | square | decimal | decimal-leading-zero | upper-alpha | upper-latin | lower-alpha | lower-lation | upper-roman | lower-roman | lower-greek | armenian | georgian | none,应用于display值为list-item的元素

## 2. 生成内容 ## 
CSS2和CSS2.1包含一个称为生成内容的新特性。这是指由浏览器创建的内容，而不是由标志或内容来表示。
列表标志就是生成内容。

### 2.1 插入生成内容 ###
为了向文档中插入生成内容，可以使用:before和:after伪元素。这些伪元素会根据content属性把生成内容放在一个元素内容的前面或后面。如`a[href]:before{content:"(link)";}`      
生成内容会放在元素的内部，所以元素的边框会包围生成内容；在CSS2.1中，除了列表标志，无法把生成内容放在元素框之外；     
- CSS2和CSS2.1中明确地进制浮点或定位:before和:after内容，还禁止使用列表样式属性以及表属性；     
- 如果:before和:after选择器的主体是块级元素，则display属性只接受值none、inline、block和marker。其他值都处理为block；     
- 如果:before和:after选择器的主体是一个行内元素，属性display只能接受值none和inline。所以其他值都处理为inline。    

生成内容有一个很有意思的方面，它由与之关联的元素继承值（比如color的继承）；当然，这种继承值只适用于可继承的属性；

### 2.2 指定内容 ###
要生成内容，需要利用content属性来描述生成的内容     
![指定内容](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E6%8C%87%E5%AE%9A%E5%86%85%E5%AE%B9.png)     
**string：**     
①串值会原样显示，即使其中包含某种标记也不例外。如`h1:before{content:"<em>&para;</em>;color:gray;"}`会直接把em标签原样显示；     
②如果要生成一个换行（回车），不能直接使用`<br>`，而要使用串`\A`，这是CSS表示换行的方法；如果一个长串，需要分成多行则用`\`符号转义;还可以使用转义来指示十六进制Unicode值，如`\00AB`；     

**uri：**     
利用URI值，只需要指向一个外部资源（如图像、视频，音频或用户代理支持的其他任何资源），然后插入到文档中适当的位置；如果用户代理出于某种原因不支持所指定的资源，此时要求用户代理完全忽略这个资源，不插入任何内容（如无法识别SVG的浏览器插入SVG图像）；     

**attr(\<identifier\>)（插入属性值）：**     
获取一个元素的属性值，使之作为文档显示的一部分，如`a[href]:after{content:" [" attr(href) "]";}`,前面的示例增加串值的原因是为了使生成内容与具体内容不冲突，可选的；     
所有属性值都可以作为生成内容插入：alt文本、class或id值 ，以及任何属性；如果一个属性不存在，会在相应位置插入一个空串；     
CSS2.x定义属性引用的返回值是未解析的串；因此，如果一个属性的值包含标记或字符实体，会原样显示；     

**生成引号：**     
生成内容有一种特殊形式，即引号，CSS2.x提供了一种有效的方式来管理引号及其嵌套行为；由于提供了open-quote等成对的content值以及属性quotes，使得生成引号的管理称为可能；      
![生成引号](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E7%94%9F%E6%88%90%E5%BC%95%E5%8F%B7.png)     
除了关键字none和inherit外，唯一合法的值是一对或多对串；在一对串中，前一个串定义了开始引号（open-quote），第二个串定义了结束引号；     
串本身是引号时，也可以用引号将其包围；双引号可以由单引号包围，反之亦然；如`quotes: '"' "'"`；     
值open-quote和close-quote用于插入合适的引号符号（不同语言有不同的引号）；它们使用quotes值来确定如何工作；     
如果想使用“弯引号”而不是普通的直引号，quote规则要写作：`quote{quotes: '\201C' '\201D';}`；     
利用quotes，只要愿意，可以定义任意多层嵌套引用模式；     
如果引号的嵌套层次大于已定义的引号对数，最后一对引号将重用于更深层次的嵌套；     
如果有多段引用文本，通常会忽略每一段的结束引号，而只显示开始引号，只是最后一段例外，可以使用no-close-quote值达到这个效果；如果想为最后一段增加一个结束引号，需要为最后一段指定类，并为其:after内容声明一个close-quote；     
开始一个引用层次时，所有元素都有相同的嵌套层次，知道遇到一个close-quote，此时引用嵌套层次减1；no-open-quote关键字会让引用嵌套层次增1，但不生成符号，其效果与no-close-quote对称；     

**计数器：**     
CSS2没有满足于只是提供HTML中的简单计数，它增加了两个属性和两个content值，从而可以定义几乎所有计数格式，包括采用多种样式的小节计数器；     
创建计数器的基础包括两个方面，一是能设置计数器的起点（counter-reset），二是能将其递增一定的量（counter-increment）；
![counter-reset](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/counter-reset.png)      
- 计数器标识符只是创作人员创建的一个标签，可以随便命名；
- 只要重置（或递增）标识符，就足以使之建立；
- 默认地，计数器重置为0；
- 如果重置为另一个数，可以在标识符后面声明这个数；
- 可以在标识符-整数对中一次重置多个标识符，如果少了一个整数，则默认为0；
- 计数器的值允许是负值；     
`h1{counter-reset: chapter 4 section -1 subsec figure 1;}`      

![counter-increment](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/counter-increment.png)      
counter-increment接受标识符-整数对，其中整数部分可以是0，也可以是负数或正数；如果它的标识符-整数对少了一个整数，则默认为1而不是0；     

- 要具体显示计数器，还需要结合使用content属性和一个与计数器有关的值；     
- 任何元素都可以利用计数器；    
- 计数器由同一个元素递增和使用时，递增发生在计数器显示之前；类似的，如果计数器在同一个元素中重置和显示，重置也在计数器显示发生之前。     
- 如果希望一个递增计数器第一次显示0，只需将该计数器重置为-1；     
- 可以利用规则改写BASIC程序清单的传统格式；    
- 可以为每个计数器定义一个列表样式，作为counter()格式的一部分；    
- 没有为计数器**指定样式关键字，它默认为decimal计数样式；如果愿意，甚至可以将计数器设置为使用样式disc、circle、square和none；     
- 即使规则看上去会让计数器递增，但实际上display为none的元素并不会递增计数器；相反，visibility为hidden的元素确实会递增计数器；     

把多个计数器串在一起创建一种多级计数；为了达到很深的嵌套层次，需要创建足够多的计数器，这种做法很快会变得相对笨拙；     
CSS2.x描述了计数器的作用域概念：每层嵌套都会为给定计数器创建一个新的作用域；
```css
/*以常规HTML方式实现嵌套表计数：*/
ol{counter-reset:ordered;}
ol li:before{counter-increment:ordered; content:counter(ordered) ". ";}
/*这些规则会使有序列表（甚至嵌套在其他列表中的有序列表）从1开始计数，并且逐项增1，这正是HTML一直以来的做法。*/
```
如果希望有序列表这样（如：1、1.1、1.2、1.2.1、1.2.2、1.3、2.1等）计数，使每层嵌套都创建一个新计数器追加到老计数器上，可以用counters()实现；
```css
ol{counter-reset:ordered;}
ol li:before{counter-increment:ordered; content:counters(ordered) ". ";}
```

# 十三、用户界面样式
## 1. 系统字体和颜色 ##
### 1.1 系统字体 ###
CSS2定义了6个系统字体关键字：     
- caption：由标题控件使用的字体样式，如按钮和下拉控件；
- icon：操作系统图标标签所用的字体样式，如硬盘驱动器、文件夹和图标文件；
- menu：下拉菜单和菜单列表中文本使用的字体样式；
- message-box：对话框中文本使用的字体样式；
- small-caption：由标题小控件的标签使用的字体样式；
- status-bar：窗口状态条中文本使用的字体样式； 

这些值只能用于font属性，它们本身就是简写形式；     
如果用户代理想要“抽取”计算环境中显示每种元素所用的字体系列，就绝对能保证这种字体对浏览器一定可用；如果所需的系统字体样式不可用或者无法确定，用户代理可用在一组近似的字体样式中猜测；如果无法做出这种的猜测，用户代理就应当使用一种“用户代理默认字体”；

### 1.2 系统颜色 ###
CSS3颜色模块废弃了系统颜色关键字，而增加了新的属性appearance；强烈建议不要使用系统颜色；只在CSS2中使用，CSS2.1中也废弃了这些关键字；      
总共有28个系统关键字，不过CSS没有明确地定义这些关键字；相反，对各个关键字的含义只有一些概况（而且非常简短）的描述；     
CSS2将系统颜色关键字定义为不区分大小写，不过建议使用混合大小写写法，这样颜色名更可读；     
系统颜色关键字本质上是含糊的，这是一个明显的缺点，不同的用户代理可能以不同的方式解析这些关键字，即使这些用户代理在同一个操作系统上运行；因此，在使用这些关键字时，不要指望肯定会有一致的结果；

## 2. 光标 ##
光标（在CSS规范中称为“指示设备”）,它有鼠标、写字板、图形书写板甚至光学读取系统之类的设备控制；在大多数Web浏览器中，光标对于提供交互反馈很有用； 
CSS2允许改变光标图片，这说明创建一个类似于操作系统中桌面应用的Web应用会容易得多；这是通过cursor属性完成的：     
![cursor](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/cursor.png)     
默认值auto只表示用户代理应当确定最适合当前上下文的光标图标；这与default不同，后者要求图标是操作系统的默认光标；默认光标通常是一个箭头，不过也不一定，这取决于当前的计算环境；
***     
**指示和选择光标：**     
值pointer会把光标图标改为与移过超链接时的光标相同；利用cursor，可以将任何元素定义为像链接一样改变光标图标；这可能会让用户糊涂，所以建议不要经常这么做；另一方面，利用cursor可以更容易地利用非链接元素创建交互式、脚本驱动的屏幕部件，然后适当地改变图标；     
Web浏览领域中另一个很常见的光标图标是text图标，只要用户能选择文本，就会出现这个图标；这往往是一个“I”光标，作为一个视觉提示，指示用户可以拖拽-选择光标下的内容；     
指示交互性的另一个办法是使用值crosshair，它会把光标图标变成一个十字符号，这往往是一对彼此呈直角交叉放置的短信，其中一条垂直，另一条水平，看上去就像一个加号（+）；它也可以类似于称号（或小写的“x”），甚至是手枪瞄准镜内显示的准星图标；十字符号通常用于屏幕捕捉程序，入股用户想准确地知道正在点击哪一个像素，这就很有用；
***     
**移动光标：**     
创作人员需要指示一个屏幕元素可以移动时就会使用move，它通常显示为一个加粗的十字线，线的两端分别有箭头；也可以显示为一个“拳头”，用户点击并按下鼠标按钮时图标中的“手指”是弯曲的；     
一些与move相关的cursor值：e-resize、ne-resize等；Windows和大多数图形化Unix-shell用户会把这些值识别为鼠标光标放在窗口一边或角落时出现的图标； 
***    
**等待和前进：**      
wait和progress都指示程序正在忙；它们并不相同：wait表示用户要等待知道程序不忙为止，而progress指示用户完全可以继续与程序交互，尽管它很忙；在大多数操作系统中，wait可能显示为一块表（可能有旋转的指针）或者显示为一个沙漏（可能在自己倒来倒去）；progress通常表示为一个旋转的“沙滩球”，或者是一个箭头，而且在这个箭头的一旁有一个小沙漏； 
***    
**提供帮助：**        
指示用户得到某种形式的帮助，用值help；help有两种常见的表现方式，可能是一个问号；也可能是一个箭头，箭头旁边有一个小问号；如果已经确认某些链接指向更多信息，或者这些链接指向的信息有助于用户更好地理解网页，help就很有用；
***
**图形光标：**        
- 使用一个URL值可以指定定制光标，如`a{cursor:url{globe.cur},pointer;}`；
- 在cursor语法定义中，URL必须跟有一个由逗号和某个通用关键字；
- 用户代理必须支持URL里所用的文本格式，如果用户代理不支持这种格式，就会转而使用后面跟着的通用关键字；
- 对于可能采用的任何图形光标，cursor都要求有后路；
- 作为后路的关键字之前可以指定多个光标文件；
- 如果用户代理支持动画图形文件来替换光标，就可以实现动画光标；

## 3. 轮廓 ##
轮廓有点类似于边框，不过二者有两个重要的区别：首先，轮廓不像边框那样参与到文档流中，因此轮廓出现或消失时不会影响文档流，即不会导致文档的重新显示，但是轮廓可能会覆盖其他元素；其次，轮廓可能不是矩形，这意味着行内元素的轮廓可能不同于该元素的边框，利用轮廓，用户代理可以“合并”部分轮廓，创建一个连续但非矩形的形状；     
用户代理不一定需要支持非矩形轮廓；它们可能会像处理边框一样设置行内非替换元素的轮廓格式；不过，兼容用户代理必须确保轮廓不能占据布局空间；     
轮廓和边框还有一个根本的差异：它们不是同一种东西，所以可以在同一个元素上共存；    
轮廓画在边框的外面（非强制，但是约定成俗）；     
一般认为轮廓是用户界面的一部分，这是因为它们最常用于指定当前焦点；如果一个用户使用键盘导航从一个链接跳到另一个链接，那么当前有焦点的链接往往会有一个轮廓；

### 3.1 设置轮廓样式 ###
轮廓最基本的方面就是样式，利用outline-style设置；     
| | | 
| ------------- | ----- |
| 值 | none、dotted、dashed、solid、double、groove、ridge、inset、outset、inherit |
| 初始值： | none |
| 应用于： | 所有元素 |
| 继承性： | 无 |
| 计算值： | 根据指定确定 |
轮廓与边框样式的值相比，少了一个关键字hidden；只能为一个outline-style值指定一个关键字（而边框可以指定最多4个关键字）；实际效果是一个元素周围必然有相同的轮廓样式，而不论轮廓是否是矩形；

### 3.2 设置轮廓宽度 ###
可以用outline-width定义轮廓的宽度；
| | | 
| ------------- | ----- |
| 值 | thin、medium、thick、\<length\>、inherit |
| 初始值： | medium |
| 应用于： | 所有元素 |
| 继承性： | 无 |
| 计算值： | 绝对长度；如果轮廓的样式是none或hidden，则为0 |
outline-width与border-width直接唯一真正的区别是整个轮廓只能声明一个宽度（类似于轮廓样式）；一个值只允许有一个关键字；

### 3.3 设置轮廓颜色 ###
可以用outline-color定义轮廓的颜色；
| | | 
| ------------- | ----- |
| 值 | invert、\<color\>、inherit |
| 初始值： | invert（或用户代理特定的值；） |
| 应用于： | 所有元素 |
| 继承性： | 无 |
| 计算值： | 根据指定确定 |
边框与轮廓之间最有意思的差别就出现在这里：轮廓颜色有关键字invert，而且这是默认值；反色轮廓意味着要对轮廓所在的像素完成反色转换，这个过程可以确保无论轮廓后面是什么都将可见；如果一个用户代理出于某种原因无法支持反色转换，则会使用元素的color计算值；     
如果想为轮廓定义一种特定的颜色，只需使用任何合法的颜色值；这里可能存在一个缺点，轮廓颜色有可能与其周围额像素颜色很接近，这种情况下用户将无法看清，正是如此才定义了invert；     
类似于轮廓样式和宽度，对整个轮廓只能定义一种颜色；

### 3.3 设置轮廓颜色 ###
类似于border属性，轮廓也有一个简写属性outline，允许一次就完成轮廓样式、宽度和颜色的设置；
| | | 
| ------------- | ----- |
| 值 | \<outline-color\> \<outline-style\> \<outline-width\>、inherit |
| 初始值： | 对简写属性未定义 |
| 应用于： | 所有元素 |
| 继承性： | 无 |
| 计算值： | 见各个属性（outline-color）等等 |
由于给定轮廓必须采用某种统一的样式、宽度和颜色，所以outline是关于轮廓的唯一简写属性；     
如果想要模拟一个反色边框，可以先设置一个轮廓，为其宽度制定一个长度值，然后设置该元素的外边距等于或大于该宽度；由于轮廓画在外边距“之上”，所以它会填入其部分空间；     
轮廓不会参与到文档流中，因此即使因为焦点的改变使轮廓从一个链接移动到另一个链接上，也不会导致文档重新显示；如果创作人员使用边框指示焦点，文档布局就会不停地变化和跳跃；轮廓可以得到与边框相同的效果，但不会跳跃；      
CSS2中轮廓不会覆盖元素框的可见部分，而只可能覆盖外边距（透明外边距）；     
CSS2有一些方面很模糊，其中包括它明确地拒绝两个轮廓相互重叠时的行为，也没有定义元素被其他元素部分模糊时对其轮廓会有怎样的影响；

# 十四、非屏幕媒体 #
## 1. 设计特定于媒体的样式表 ##
利用HTML和CSS中定义的机制，可以将样式表限制为仅用于某种特定媒体；对于基于HTML的样式表，可以通过media属性对媒体做出限制，在link和style元素中用法是一样的：
```css
<link rel="stylesheet" type="text/css" media="print" href="aa.css">
<style type="text/css" media="projection，screen">
body{font-family:sans-serif;}
</style>
```
media属性可以接受一个媒体值或者媒体值表（各媒体值之间用逗号分隔）；     
在样式表本身，还可以在@import规则上限制媒体：
```
@import url(aa.css) screen,projection;
@import url(bb.css) print;
```
如果没有为样式表增加媒体信息，他会应用于所有媒体；如果希望一组样式只应用于一种媒体，那么就要向样式表显式地增加媒体信息；     
@media块的大小不限，可以包含任意多个规则；如果创作人员只能控制一个样式表，@media块则可能是定义特定媒体样式表的唯一途径；如果使用CSS对一个使用XML语言的文档应用样式，而这个XML语言中没有media属性或相应属性，这种情况下，也必须使用@media块；

## 2. 分页媒体 ## 
在CSS术语中，分页媒体是把文档表示处理为一系列离散“页面”的媒体；屏幕没提示一种连续性媒体：文档表示为一个可滚动的“页面”；实例：打印资料（书，杂志和激光打印机输出等）、幻灯片；

### 2.1 打印样式 ###
最常见到的分页媒体是文档的打印输出（如Web页面、字处理文档、电子表格或成张的输出），打印样式会应用于“打印预览”模式的文档显示；     
**屏幕与打印的区别：**     
- 除了明显的物理差异外，还有很多样式上的不同；
- 最基本的差别是字体选择，最合适屏幕设计的字体是sans-serif字体，但是在打印媒体中serif字体更可读；
- 另一个主要区别在于字体大小，点作为Web上的字体大小不是一个好的选择（在不同浏览器和操作系统上会有不一致大小的显示），使用点（甚至厘米或派卡）在打印设计中是完全可行的（因为打印设备知道其输出区域的物理大小，打印机可以处理物理世界的长度单位，如点）；
- 另外，大多数打印输出中都没有背景，为了节省用户的打印油墨，大多数Web浏览器都预先配置为不打印背景色和图像；如果确实想要在打印输出宏看到这些背景，就必须在首选项中修改一个选项；无法通过CSS强制打印背景色 ，不过可以使用一个打印样式表确保不打印背景；
- 在分页媒体中更难使用多列布局；解决方法是使用CSS建立多列布局（可能通过浮动实现），然后编写一个打印样式表，将内容回复称单列打印；     
***
**定义页面大小：**       
CSS定义了描述页面组件的页框，页框基本上由两个区组成：	
- 页面区，这是页面中放内容的部分；它类似于正常元素框中的内容区，因为页面区的边界相当于页面中布局的初始包含块；
- 外边距框，这是围绕页面区的部分；

在CSS2.1中，创作人员只能设置外边距区的大小，使用@page规则来完成设置；*在CSS2中还可以设置页框的大小，用属性size设置，这个属性从CSS2.1中去除了，原因是缺乏实现支持*；      
关于页框真正有意思的是，它与字体没有任何关系，所以不能使用长度单位em和ex来描述外边距区或页面区，这里只允许指定百分数和“尺度”单位，如英寸、厘米或点；
***
**选择页面类型：**     
CSS2允许通过命名@page规则创建不同的页面类型；*可以通过page属性实现向文档中的不同元素指定命名页面类型（此属性也已经从CSS2.1中去除）*；       
通过特殊伪类，可以处理更多通用页面类型，在CSS2和CSS2.1中都有定义；`:first`允许向文档中的第一个页面应用特殊样式，可以使用`:left`和`:right`对左页和右页分别设置样式，模拟书脊左右两边的书页；
***
**分页：**      
![分页](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%88%86%E9%A1%B5.png)       
可以使用属性page-break-before和page-break-after影响分页，它们接受同样的一组值；
默认值auto只是说明不要求在元素之前或之后分页，这与正常的打印输出相同；      
always值导致在设置样式的元素之前（或之后）放一个分页符；     
值left（元素在左页的顶部打印）和right（元素在右页的顶部打印）的做法与always相同，只不过它们更进一步定义了继续打印哪种类型的页面，前面可能插入一个或两个分页符；     
值avoid，它会让用户代理尽量避免（无法绝对保证）在一个元素之前或之后放置分页符；      

![分页2](http://oboiq86te.bkt.clouddn.com/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E7%89%88/%E5%88%86%E9%A1%B52.png)     
利用page-break-inside，可以不采用默认做法而另作选择：请求用户代理尽量避免在一个元素内部放置分页符；
***
**orphans和widows：**    
为了对分页提供更精确的控制，CSS2定义了传统打印排版和桌面发布中都很常见的两个属性orphans和widows，它们目的一样，只是实现角度不同；值widows定义了放在页面顶部的元素在不导致前面增加分页符的前提下所包含的最小行框数；orphans的作用恰好与之对应：它定义了不会导致元素前增加分页符的前提下可以出现在页面底部的最小行框数；orphans和widows都必须满足；
***
**分页行为：** 
由于CSS2允许一些奇怪的分页样式，它关于所允许的分页符和“最佳”分页符定义了一组行为；这些行为可以知道用户代理如何在不同的情况下处理分页；     
实际上只有两个通用位置上允许有分页符：     
第一个是两个块级元素框之间；如果分页符在两个块框之间，则分页符之前的元素的margin-bottom值重置为0，分页符后的元素的margin-top值也重置为0；不过以下两个规则允许在两个元素框之间放置分页符：     
- 第一个元素的page-break-after值或第二个元素的page-break-before值是always、left或right；不论其他元素的值是什么（甚至可能是avoid），都必须在元素间放置分页符（这是强制分页符）；
- 第一个元素的page-break-after值是auto，第二个元素的page-break-before值也是auto，而且它们没有一个page-break-inside值不为avoid的共同祖先元素；

第二个允许放分页符的通用位置是一个块级框中的两个行框直接；这是由两个规则控制：
- 只有当元素开始于分页符之前之间的行框数小于该元素的orphans值时，才可能在两个行框之间出现分页符；类似的，值只有当分页符之后行框与元素结束处之间的行框数小于widows值时，才可能在两个行框直接插入分页符；
- 如果元素的page-break-inside值不是avoid，可能在行框之间放分页符；

在这两种情况下，倘若无论分页符如何放置都无法使这两个规则同时满足，则会忽略控制分页符放置的第二条规则；一个元素指定了page-break-inside:avoid，但是它比一整页还长，则允许在该元素内部插入一个分页符，换句话说，会忽略在行框之间放置分页符的第二个规则；    
如果忽略各组规则中的第二个规则后扔不能很好地放置分页符，还可以忽略其他规则；在这种情况下，用户代理很可能忽略所有分页属性值，就好像它们都设置为auto一样，不过这种方法在CSS规范中没有定义（或未做要求）；     
除了前面的规则外，css还定义了一组“最佳”分页行为（非必要，但是是合理的指导，有助于得到理想的分页行为）：
- 尽可能少分页；
- 让所有不是以强制分页符结尾的页面都有相同的高度；
- 避免在有边框的块内部分页；
- 避免在表内部分页；
- 避免在浮动元素内部分页；

***
**重复元素：** 
分页媒体往往要求有一个页头；页头是指在每个页面上都出现的一个元素；在CSS2中可以使用固定定位元素指定页头，如`div#runhead{position:fixed;top:0;right:0;}`,在文档输出到一个分页媒体时，这会把它放到每个页框的右上角；这个规则也会把该元素放在连续媒体视窗的右上角；
***
**页面外的元素：**       
对于元素定位在页框之后的情况，CSS2没有指出用户代理应该怎么做，所以要由用户代理自己确定解决方案；     
有两个建议非常重要：首先，内容应该能稍稍超出页框，从而允许生成"出血版"，这说明对于超出页框的部分内容，不会生成额外的页面；其次，用户代理要注意不能只是为了满足定位信息而生成太多空页面；     
还有两个建议指出，用户代理不能只是 为了避免某些元素而把元素定位到奇怪的位置，另外放在页框之外的内容也能以多种方式表现（CSS的某些元素很有用也很复杂，不过有些看上去则很直接明了）；

### 2.2. 投影样式 ### 
投影是一种常用的分页媒体，它描述了投影到一个大屏幕上的信息，适合很多观众观看，PPT是当前最知名的投影媒体之一；
支持透明媒体CSS的浏览器（*需要确认，不清楚支持情况*）
***
**建立幻灯片：** 
如果把一个文档分成一系列幻灯片，需要一种办法来定义各幻灯片之间的界限，这个工作使用分页属性完成；到底使用page-break-before还是page-break-after，很大程度上取决于文档如何构造；
***
**定位元素：** 
在定位元素时，其初始包含块就是元素所在的页框；因此，如果希望每个幻灯片的标题出现在幻灯片的底部，可以用`h2{page-break-before:always;position:absolute;bottom:0;right:0;}`表示；     
类似于打印媒体，固定定位元素会出现在幻灯片中的每一个页框中；这说明可以将一个元素（如文档标题）放在每一个幻灯片上，这种技术可以用于创建每一页上的页脚、图形边栏等；
***
**关于投影的考虑：** 
创建投影样式表时需要提前考虑一个特定的分辨率；可能需要对不同的分辨率创建不同的样式表；如果采用对比强烈的颜色，投影文档对观众来说往往更可读；


## 3. 声音样式 ##
CSS2.1废弃了媒体类型aural以及与之相关的所有属性，CSS3使用媒体类型speech来表示文档的语音表现；
